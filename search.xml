<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[写博有道可循]]></title>
    <url>%2Funcategorized%2F%E5%86%99%E5%8D%9A%E6%9C%89%E9%81%93%E5%8F%AF%E5%BE%AA%2F</url>
    <content type="text"><![CDATA[定计划按周期坚持执行，从技术到艺术，从自我管理到团队管理，甚至是生活琐碎中的形形式式，只要你有所感悟，想分享想抒发的，都是你口袋中的素材。 分类 实战类：背景-&gt;排查-&gt;解决-&gt;防止 入门系列：技术选型分析-&gt;相关的demo来研究体验-&gt;初步的结合业务实践-&gt;团队培训 套路 构思文章概要（设计） 根据概要去写文章（编码） 检查文章是否有错别字 条例是否清晰（测试） 调整文章结构（重构） 发布文章（投产） ps-文中涉及到代码的地方，尽量使用code的样式展示，并只展示核心代码片段，在文章末尾给出完整代码地址。 推广先在博客平台全面同步（博客园、csdn、简书、开源中国、知乎、掘金、技术头条、segmentfault），再到独立博客、个人公众号。并且要清楚发布清楚平台的规则，例如可以选择发布到首页，寻找提高曝光率的机会。 在博客中添加主动推送到搜索平台的代码，或者在平台的站长工具上传sitemap，创建博客的SEO，并做适当的SEO优化。]]></content>
  </entry>
  <entry>
    <title><![CDATA[招聘的面试之道]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2F%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%2F</url>
    <content type="text"><![CDATA[简历看人 是否有错别字（细心、责任心） 是否正确、逻辑清晰（出品质量、思维能力） 是否特出重点（归纳能力） 是否有技术相关社会化活动，像开源、解答、博客（热情程度） 介绍专长 是否有激情 沟通能力是否过关 技术能力是否足够 是否符合团队文化 基础检验 基础点原理题3～4题，要能考验技术是否扎实 技术深度检验 你用过为止，觉得最牛逼或者最佩服的框架是哪个？介绍一下这个框架的整体工作原理流程？ 符合企业文化 为人简单直接 办事专一不浮躁 能信任身边的团队伙伴，不孤军作战自以为是，乐于分享帮助他人 做最好，不做只好 企业文化到底是什么呢？ 行为面试在你哪个项目，遇到过最大困难或挑战，是什么和如何解决的（是否有独立解决问题的能力） 代入工作环境，设立一个虚拟场景考验（是否有良好编码习惯、异常处理规范、代码逻辑缜密、开发效率） 示例Android基础 创建数组对象时预留内存空间的目的是什么？缺点是什么？ 若空间不足时添加新元素，则需要先重新申请一块足够大的连续的内存空间，并将所有元素移到新空间上，再添加新元素（因为数组中元素地址要求连续，所以对跳跃查找十分友好）。 可能会浪费一部分的内存空间。 对集合的读取、插入、删除，在数组与链表两种数据结构中分别如何选用 数组：读取 链表：插入、删除 使用StringBuffer、StringBuilder、String 之间去编辑字符串的区别 java.lang.StringBuffer是线程安全的可变字符序列。 StringBuilder线程不安全不同步，但速度更快，一般情况下选用（超16字符时使用） String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象（消耗系统性能），然后将指针指向新的 String 对象。 try catch 为什么被设计出来？使用有哪些注意点？ 需要返回错误的类型、信息，不与正常代码混淆。 不要在循环中使用，应移出循环外捕获异常 不应随便捕获，来避免不可预知的错误发生 final、protected、private修饰方法的区别 final是任何人都不能修改方法，包括子类的重写，但可以使用； protected是只有自己和子类可以使用，子类可重写，而外部其它类不知道该方法的存在； private是只有自己可以使用，子类以及外部其它类都不知道该方法的存在。 assets目录与res目录的区别 res：会被编译器转成R.java去编译，每个资源会有ID标识，获取资源方式：R.xx.yy（raw没被压缩存在于apk，R中的内容是其映射；drawable是失真压缩的二进制） assets：不会被编译，存在于apk，通过AssetManager访问，，可访问子目录，获取资源方式：文件路径+文件名 ListView与RecyclerView的区别 深度 阐述Thread+Handler+MessageQueue相互间的工作流程。 关系：Thread拥有Looper，Looper拥有Handler和MessageQueue，但Looper拥有Handler的前提是需要一个绑定过程，就是在实例化Handler时传指定Looper到实例方法中，不传的话默认是获取当前线程的Looper进行绑定。所以在主线程实例化Handler且不指定Looper的话，其handleMessage就会在主线程执行。 消息队列：线程默认都绑定着一个MessageQueue，handleMessage是依靠Looper轮询消息队列后，将消息分发下来所触发的。当队列中没消息时，线程会自动阻塞，除非我们手动销毁线程，否则等到有新消息后就继续轮询。 子线程：子线程默认是没有Looper的，即是不会自动开始消息轮询和分发，所以如果要在子线程实例化Handler的话，必须先给子线程创建配置Looper并将其启动。 通信：其它线程利用Handler向往当前目标线程发消息时，当前目标线程会将Message塞入子线程的MessageQueue去，待轮询分发消息后，触发执行handleMessage。 为什么要为线程Thread设计一个Runnable接口，去作为线程实例化时的入参？ 避免Thread单继承的局限和多Thread之间可以共享Runnable中的资源 除了上述的方式实现多线程，还有其它哪些方式？如何实现？ AsyncTask 重写几个关键函数： onPreExecute：执行异步线程前的回调，处理UI的初始化，是在主线程中回调 doInBackground：执行异步线程任务，其中可调用publishProgress，从而回调onProgressUpdate，来显示进度 onProgressUpdate：进度回调，在主线程中回调的 onPostExecute：返回异步线程任务的执行结果，在主线程中回调 onCancelled：将异步线程任务状态置为取消后，需自行在doInBackground判断任务的状态进行实质性的阻止中断，即回调此函数]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《资治通鉴》听书后感]]></title>
    <url>%2F%E4%B9%A6%2F%E5%90%AC%E4%B9%A6%E5%90%8E%E6%84%9F%2F%E3%80%8A%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4%E3%80%8B%E5%90%AC%E4%B9%A6%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[待续]]></content>
      <categories>
        <category>书</category>
        <category>听书后感</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[书单]]></title>
    <url>%2F%E4%B9%A6%2F%E4%B9%A6%E5%8D%95%2F%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[听书 [ ]《晓说》 [ ]《ggtalk》 [ ]《逻辑思维/得到App》 [x]《资治通鉴》 阅读 [ ]《系统之美》 [ ]《黑客与画家》 [ ]《毛泽东传》 [ ]《乐之本事：古典乐聆赏入门》 [ ]《深度学习入门》 [ ]《单页Web应用》 [ ]《剑指Offer》 [x]《Objective-C》 [x]《批判性思维工具》 [x]《Head First 设计模式》 [x]《iOS应用逆向工程：分析与实战》 [x]《产品经理入门攻略》 [x]《图解HTTP》 [x]《算法图解》 [x]《程序员的自我修养 - 链接、装载、库》 [x]《程序员的自我修养》 [x]《MacTalk 跨越边界》 [x]《你的第一本保险指南》 [x]《菜场经济学》 学习 [ ]《Javascript》 [ ]《Vue》 [ ]《Node.js》 [ ]《Sketch》 [ ]《管理》 [ ]《iOS高手课》 [ ]《架构》 [x]《iOS基础及进阶》 [x]《Swift入门》 [x]《Flutter入门》 [x]《数据分析入门》 [x]《人工智能入门》 [x]《项目管理入门》 [x]《Android入门》 [x]《Python入门》 音乐鉴赏 [ ]《贝多芬》 油画鉴赏 [ ]《DailyArt》 视频TED]]></content>
      <categories>
        <category>书</category>
        <category>书单</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发一个Android App]]></title>
    <url>%2FAndroid%2F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAndroid-App%2F</url>
    <content type="text"><![CDATA[从0到1，搭建一个简单的Android App。中间会夹着某些知识点的全量内容，方便下次开发时直接在这里根据自己当时的总结翻找回顾（官方的文档其实也已经很全很方便翻阅）。因为本人是iOS开发出身，所以中间也会夹着些和iOS相似概念的类比，举一反三地思考，加强记忆。 Android应用构成 主干 AndroidManifest：应用的配置，系统需要根据里面的内容运行APP的代码，显示界面； Activity：可以理解为一个视图控制器，在MVC模式下充当C这样的角色； Fragment：表示Activity 中的片段，可组合或重复使用，具有它自己的生命周期和输入事件； Service：在后台执行长时间运行操作而不提供界面的服务； ContentProvider：内容提供者，在进程间进行数据交互和共享，即跨进程通信 BoardcastReceiver：广播接收器，是一个全局的监听器，监听接收应用发出的广播消息，并做出响应 四肢 View：Android里的图形界面都是由View和ViewGroup以及他们的子类构成的，或可直接将XML布局看作是View； Adapter：也可以看作是另一个控制器，介于Activity和View之间，配合集合性的View使用； Model：是指应用逻辑层（也叫领域层）的对象，如 Account、Order 等等，这些对象是应用程序中的一些核心对象，负责应用的逻辑计算，有许多与业务逻辑有关的方法或操作。仅仅只有getter、setter的用来传递数据的对象，只能叫Value Object，并不是真正的Model层； AsyncTask：轻量级异步类，实现多线程、工作线程与主线程（UI线程）之间的通信； 衣服（Res） layout：页面的布局 values：存放属性值，例如颜色、间隔、本地化 drawable：存放图片 xml：存放自定义的配置 anim：动画效果 mipmap：存放icon和launch图 menu：菜单选项 内脏 aar：含资源的库包集合 jar：纯代码库包 module：源码级的Library，在同一个工程中供主项目Module去引用依赖 应用配置文件 AndroidManifest具体包含的内容有： 为应用的 Java 软件包命名； 描述应用的各个组件，包括构成应用的 Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理的 Intent 消息。这些声明向 Android 系统告知有关组件以及可以启动这些组件的条件的信息； 确定托管应用组件的进程； 声明应用必须具备哪些权限才能访问 API 中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限； 列出 Instrumentation类，这些类可在应用运行时提供分析和其他信息。这些声明只会在应用处于开发阶段时出现在清单中，在应用发布之前将移除； 声明应用所需的最低 Android API 级别；（在build.gradle也能指定） 列出应用必须链接到的库。（3.0的AS之后由build.gradle指定） 它就好比iOS中的Info.plist，包含各种应用运行前或运行时所需的配置项 在&lt;manifest&gt;此元素的属性中： package表示应用的包名； android:versionName表示商店上给用户所看的版本号； android:versionCode表示开发者内部的版本号，一般作为标识每次生成的包的号码； &lt;manifest&gt;中的元素 &lt;uses-feature&gt; 将APP所依赖的硬件或者软件条件进行声明，需在单独的&lt;uses-feature&gt;元素中指定每个功能； android:name 指定的功能名。 android:required 是否必须功能。 android:glEsVersion 需要的Opengl ES版本。 &lt;uses-permission&gt; 声明需要使用的权限，一般只设置 android:name= 属性，可选的权限有 android.permission.INTERNET android.permission.WRITE_EXTERNAL_STORAGE &lt;application&gt; 描述应用的配置，包含多个子元素来描述应用中的组件； android:allowBackup 是否允许APP加入到备份还原的结构中。 android:fullBackupContent 是否支持RTL（Right To Left）布局，targetSdkVersion在17以上起效。 android:icon APP的图标，一般就使用mipmap(-hdpi)下对应的ic_launche图片。 android:label 用户可读的标签，标签必须设置成一个字符串资源的引用，使其为可配置可定位。 android:theme 应用使用的主题，指向style资源的引用，各个activity也可以用自己的theme属性设置自己的主题。 android:name Application子类的全名，需包括其整体路径，当应用启动时，这个类的实例被第一个创建，这个属性是可选配置。 &lt;activity&gt; 是&lt;application&gt;中的元素，声明一个实现应用可视化界面的Activity，任何未在该处声明的Activity对系统都不可见，并且永远不会被执行； android:name activity的名称，如果第一个字符是点，就需要加上包名。 android:label 同application android:configChanges 在运行时发生配置更改时，默认情况下会关闭 Activity 然后将其重新启动，但使用该属性声明配置将阻止 Activity 重新启动，并保持运行状态，系统会调用其 onConfigurationChanged()方法。 orientation 设备旋转 keyboardHidden 键盘显隐 android:launchMode 如何启动Activity的指令，一共有四种指令，默认情况下是standard。 standard 可以多次实例化，遵循元素进栈出栈的特性，可位于Activity堆栈中的任何位置。 singleTop 可以多次实例化，但如果要开启的activity在任务栈的顶部已经存在，就不会创建新的实例，而是调用 onNewIntent() 方法。避免栈顶的activity被重复的创建。 singleTask 单一实例模式，如果要激活的activity，在任务栈里面已经存在，就不会创建新的activity，而是复用这个已经存在的activity，调用 onNewIntent() 方法，并且清空这个activity任务栈上面所有的activity。 singleInstance 单一实例模式，整个手机操作系统里面只有一个实例存在，不同的应用去打开这个activity共享公用的同一个activity，运行在自己独立的任务栈里面，并且任务栈里面只有它一个实例存在。 android:theme 同application的theme &lt;meta-data&gt;一般是&lt;activity&gt;中的元素，是一个name-value对，提供给其父组件，数据会被组成一个Bundle对象，可以通过PackageItemInfo.metaData字段使用； android:name android:resource android:value &lt;intent-filter&gt;一般也是&lt;activity&gt;中的元素，指明activity可以以什么样的意图(intent)启动，其子元素包括 &lt;action&gt;元素，表示activity作为一个什么动作启动，android.intent.action.MAIN表示作为主activity启动 &lt;category&gt;元素，表示action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity。 示例： &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.test.app"&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;application android:name="com.test.app.TestApplication" android:networkSecurityConfig="@xml/network_security_config" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;service android:name="com.test.app.service.TestAidlService" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="com.test.app.service.TestAidlService"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;activity android:name="com.test.app.activity.MainActivity" android:theme="@style/AppTheme.NoActionBar"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name="com.test.app.activity.DetailActivity" android:parentActivityName="com.efn.testapp.activity.MainActivity" android:theme="@style/AppTheme.NoActionBar" &gt; &lt;!-- The meta-data tag is required if you support API level 15 and lower --&gt; &lt;meta-data android:name="android.support.PARENT_ACTIVITY" android:value="com.test.app.activity.MainActivity" /&gt; &lt;/activity&gt; &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.efn.testapp.fileprovider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_provider"/&gt; &lt;/provider&gt; &lt;/application&gt; &lt;/manifest&gt; UI控制器 Activity官方文档 Android中的Activity，在MVC中就可以直接看作是C，即Controler，与iOS的ViewControler的定位一致。但MVP或MVVM中，可能就需要改视为V，即View更多一些，因为它的业务逻辑会进一步被分化到Presenter或者ViewModel上，只是保留简单地管理View的部分，下面在设计模式一节再详谈。 开发Activity的基本步骤： 创建Activity，最主要的是实现onCreate()，初始化 Activity 的必需组件，其它生命周期的方法可以按需要实现 官方文档； onCreate 创建 onStart 即将可见 onResume 已经可见 onPause 聚焦在其他activity上 onStop 不再可见 onDestroy 准备销毁 在onCreate()中必须调用 setContentView() ，传递布局的资源ID以定义Activity用户界面的布局。 在清单文件中声明 Activity，指定你要的意图过滤器intent-fliter 启动Activity 创建意图 Intent对象，传入将要打开的子Activity的class 不需要回调的调用 startActivity() 需要回调的调用 startActivityForResult()，并实现 onActivityResult()，通过requestCode参数标识来源，resultCode参数标识处理结果 需要额外参数的，对intent调用 putExtra(“key”, “value”)进行设置 结束Activity finish() 结束当前Activity finishActivity() 结束之前启动的另一个Activity 在startActivity()或finish()后调用overridePendingTransition()，传入进入动画和退出动画的资源ID，即可自定义启动Activity的动画效果。 Activity一般继承AppCompatActivity就能带有ActionBar（AS中创建Activity是默认继承它的），也就是iOS中的NavigationBar。为了可以兼容旧版的actionBar，support v7提供的ActionBarActivity（其实就是一个AppCompatActivity的空继承）。 在被打开的Activity中，如果是使用自定义toolbar，且不用兼容旧系统的actionBar，则可以这样指定标题和后退按钮 Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setTitle("xx"); toolbar.setTitleTextColor(Color.BLACK); toolbar.setNavigationIcon(R.drawable.ic_toolbar_back); 若是自定义的toolbar但不需要兼容actionBar，则需要先将布局中自定义的toolbar设定为actionBar，并关闭相关的自定义属性 Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); //为了兼容旧版本上的actionBar（Toolbar是新的代替工具） ActionBar actionBar = getSupportActionBar(); if(actionBar != null) &#123; //actionBar.hide(); actionBar.setHomeButtonEnabled(false); actionBar.setDisplayShowHomeEnabled(false); actionBar.setDisplayShowTitleEnabled(false); &#125; TextView titleView = findViewById(R.id.detail_main_title); titleView.setText(title + "详情"); Button backButton = findViewById(R.id.detail_main_back_btn); backButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; DetailActivity.this.finish(); overridePendingTransition(R.anim.anim_back_in, R.anim.anim_back_out); &#125; &#125;); 片段 Fragment官方文档 可以在一个 Activity 中组合多个片段，从而构建多窗格界面，并在多个 Activity 中重复使用某个片段。 片段必须始终托管在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。Fragment的生命周期如下： onAttach/onDettach onCreate/onDestroy onCreateView/onDestroyView onActivityCreate onStart/onStop onResume/onPause 当您将片段作为 Activity 布局的一部分添加时，其位于 Activity 视图层次结构的某个 ViewGroup 中，并且片段会定义其自己的视图布局。您可以通过在 Activity 的布局文件中声明片段，将其作为 元素插入您的 Activity 布局，或者通过将其添加到某个现有的 ViewGroup，利用应用代码将其插入布局。 开发Fragment 如果是普通的Fragment，可以通过onCreateView()返回布局的根视图（View） @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment return inflater.inflate(R.layout.example_fragment, container, false); &#125; inflater参数可利用来加载布局（有点像Activity中的setContentView()） container参数是片段布局将插入到的父级ViewGroup（来自Activity） savedInstanceState参数是在恢复片段时，提供上一片段实例相关数据的Bundle inflate()但最后一个布尔型参数，指示是否应在扩展期间将扩展布局附加至 ViewGroup（第二个参数）的布尔值。 getArguments()获取传递进来的其它参数 getView()获取当前的ViewGroup 如果是DialogFragment，则需要重写onCreateDialog()，并返回一个自定义的Dialog（否则父类默认会返回一个空白的Dialog），示例： @Override public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) &#123; Dialog alertDialog = new Dialog(getContext()); alertDialog.requestWindowFeature(Window.FEATURE_NO_TITLE); View customView = initView(null, null); alertDialog.setContentView(customView); alertDialog.setCanceledOnTouchOutside(true); alertDialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); WindowManager.LayoutParams windowParams = alertDialog.getWindow().getAttributes(); windowParams.width = (int) (getResources().getDisplayMetrics().widthPixels - getResources().getDisplayMetrics().density * 40); windowParams.height = (int) (getResources().getDisplayMetrics().heightPixels - getResources().getDisplayMetrics().density * 100); alertDialog.getWindow().setAttributes(windowParams); return alertDialog; &#125; //initView() ··· if (inflater == null) &#123; view = LayoutInflater.from(getContext()).inflate(R.layout.detail_advise_main, container); &#125; else &#123; view = inflater.inflate(R.layout.detail_advise_main, container, false); &#125; ··· //在view上设置控件 效果如下图 ListFragment暂时没用到，但原理基本一致。 在Activity的布局中插入片段，将片段当作视图来为其指定布局属性，创建此Activity布局时，系统会将布局中指定的每个片段实例化，并为每个片段调用onCreateView()方法，以检索每个片段的布局。这个实现比较简单，不细说。 通过编程方式展示，用于运行时，只需指定要将片段放入哪个ViewGroup，示例 FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); ExampleFragment fragment = new ExampleFragment(); fragmentTransaction.add(R.id.fragment_container, fragment); //还有replace()、remove()、addToBackStack()这些事务操作更改方法 fragmentTransaction.commit(); 运行时的编程也有第二种方式展示Fragment DetailAdviseFragment fragment = new DetailAdviseFragment(); //此处为一个DialogFragment fragment.setOnPressButtonListener(DetailActivity.this); Bundle bundle = new Bundle(); bundle.putString("advise", "something"); fragment.setArguments(bundle); //设置Fragment的参数 fragment.show(getSupportFragmentManager(), "detailAdviseFragment"); 与Activity通信的话，正向就是通过FragmentManager的findFragmentById找出fragment，反向就是通过Fragment定义接口，Activiyt实现接口（下面的监听者一节再介绍这样的接口实现） 最后，说一个使用频率应该颇高的示例，利用Fragment实现多标签切换的效果。 先定义一个Activity，组织一个ViewPager和两个数据源，数据源包括作为单个标签主体的Fragment的列表和标签标题的列表。 public class MyActivity extends AppCompatActivity &#123; ViewPager mViewPager; List&lt;Fragment&gt; mFragmentList; String[] mTitles = new String[]&#123;"标签1","标签2"&#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; ··· //find view mFragmentList = new ArrayList&lt;Fragment&gt;(); mFragmentList.add(MyFirstFragment.getInstance(network)); mFragmentList.add(MySecondFragment.getInstance(network)); MyFragmentPagerAdapter adapter = new MyFragmentPagerAdapter(getSupportFragmentManager(), mFragmentList, mTitles); mViewPager.setAdapter(adapter); mTabLayout.setupWithViewPager(mViewPager); ··· &#125; &#125; 布局 &lt;LinearLayout ···&gt; &lt;android.support.design.widget.TabLayout ··· app:tabIndicatorColor="@color/colorBlue" app:tabIndicatorHeight="5dp" app:tabSelectedTextColor="@color/colorBlue" app:tabTextColor="@color/colorDark" /&gt; &lt;android.support.v4.view.ViewPager ···/&gt; &lt;/LinearLayout&gt; 其次ViewPager和数据源之间，需要一个适配器才能进行工作，系统已经准备好了这种功能的适配器FragmentPagerAdapter，继承它自定义自己的数据逻辑 public class MyFragmentPagerAdapter extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; mFragmentList; private String[] mTitles; public MyFragmentPagerAdapter(FragmentManager fm, List&lt;Fragment&gt; fragmentList, String[] titles) &#123; super(fm); this.mFragmentList = fragmentList; this.mTitles = titles; &#125; @Override public Fragment getItem(int i) &#123; return mFragmentList.size()&gt;0 ? mFragmentList.get(i) : null; &#125; @Override public int getCount() &#123; return mFragmentList.size(); &#125; @Nullable @Override public CharSequence getPageTitle(int position) &#123; return mTitles[position]; &#125; &#125; 最后就是定义Fragment，这里采用单例的方式，提供数据输入口刷新页面内容，假如整个App里面只有一处展示到这个ViewPager，且使用频率又较高，那使用这种方式有一定的好处。 public class MyFirstFragment extends Fragment &#123; public DataModel mDataModel; private static MyFirstFragment mFragment; public static MyFirstFragment getInstance(DataModel model) &#123; if (mFragment == null) &#123; mFragment = new MyFirstFragment(); &#125; mFragment.mDataModel = model; return mFragment; &#125; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; super.onCreateView(inflater, container, savedInstanceState); View view = inflater.inflate(R.layout.my_first_fragment_layout, container, false); return view; &#125; @Override public void onResume() &#123; super.onResume(); View view = getView(); ···//find view ，setup view &#125; &#125; 这就完成了一个标签切换功能，效果如下 效果如下图 视图 View布局-官方文档 每个ViewGroup都是看不见的用于组织子View的容器，而它的子View可能是输入控件，又或者在UI上绘制某块区域的小部件。 View：所有可视化控件的父类，提供组件描绘和事件处理方法，例如Button、TextView等； ViewGroup：View类的子类，可拥有子控件，可以看作是容器，例如各种Layout类。 Android UI中的控件都是按照这种层次树的结构堆叠得，而创建UI布局的方式有两种，自己在Java里写代码或者通过XML定义布局，后者显得更加方便和容易理解！ UI布局的层次结构图如下 当App加载上述的布局资源时，Android会将布局中的每个节点进行实例化成一个个（类名对应元素名称的）对象。可以为这些对象定义一些额外的行为，查询对象的状态，或者修改布局。 容器类有 FrameLayout 框架布局，所有的控件都会默认出现在视图的左上角 layout_gravity（可设值：center、top、bottom、left、right、right|bottom） LinearLayout 线性布局 layout_weight orientation：布局方向（可设值：horizontal/vertical） divider：分割线的样式 showDividers：加分割线的位置（可设值：middle/end/beginning/none） AbsoluteLayoit 绝对布局，为了布局的适配，基本不使用此种布局。 RelativeLayout 相对布局，有子控件相对于父容器的布局，也有子控件直接相对的布局 layout_above：（属性值为ID的引用名） layout_alignLeft/Top/Right/Bottom layout_alignParentLeft/etc. layout_toLeftOf/etc. layout_alignBaseLine layout_centerInParent TableLayout 表格布局，将子元素的位置分配到行或者列中，一个TableLayout由许多的TableRow组成 ConstraintLayout 约束性布局 CoordinatorLayout 协调布局 layout_behavior PercentFrameLayout PercentRelativeLayout GridLayout 各种容器概括图 基本的属性有 layout_width/height：（可设值：match_parent/wrap_content/XXdp，配合weight使用时注意设为0dip） layout_centerHrizontal/centerVertical/centerInparent：是否水平/垂直/相对父元素居中 layout_margin layout_marginLeft/Top/Right/Bottom/Start/End（4.2版本开始应使用Start和End分别代替Left和Right，系统能根据用户所设置的语言，例如需要从右到左排序的阿拉伯语，自行控制这个padding的位置，使用Start就可以交由系统处理，若还使用Left就有失偏颇，除非要兼容旧的系统版本则需要一并设置上） layout_padding layout_paddingLeft/Top/Right/Bottom/Start/End addStatesFromChildren：布尔值，viewgroup的drawable属性是否把它的子类的drawable的state包含进来。 tag descendantFocusability：当一个为view获取焦点时，定义viewGroup和其子控件两者之间的关系，可设值： beforeDescendants：viewgroup会优先其子类控件而获取到焦点 afterDescendants：viewgroup只有当其子类控件不需要获取焦点时才获取焦点 blocksDescendants：viewgroup会覆盖子类控件而直接获得焦点（一般在ListView的自定义Item布局的根布局加上使用此值，能解决因子控件将焦点获取而导致点击item时变化的是子控件但item本身的点击没有响应的问题。） splitMotionEvents：布尔值，定义布局是否传递touch事件到子布局 layoutMode：（可设值：clipBounds剪辑子控件的边界/opticalBounds可视的子控件边界） background：本元素的背景 foreground：设置布局的前景图，前景图不会被子元素覆盖 foregroundGravity：设置布局前景图的位置 foregroundInsidePadding scrollX/Y：最初的水平/竖直滚动的偏移，以像素为单位 focusable：布尔值，是否能获得焦点（按键） focusableInTouchMode：布尔值，是否可以通过touch获取到焦点 fitsSystemWindows：布尔值，布局调整时是否考虑系统窗口(如状态栏) fadeScrollbars：布尔值，滚动条是否自动隐藏 fadingEdge：设置拉滚动条时，边框渐变的方向（可设值：none边框颜色不变、horizontal水平方向颜色变淡、vertical垂直方向颜色变淡）。 fadingEdgeLength：滚动条渐变长度 filterTouchesWhenObscured：布尔值，所在窗口被其它可见窗口遮住时，是否过滤触摸事件 visibility：是否可见（可设值：gone/visible/invisible虽不可见，但占据布局位置) scrollbars：设置滚动条（可设值：none/horizontal/vertical） scrollbarStyle：可设值： outsideInset：ScrollBar显示在视图(view)的边缘,增加了view的padding. 如果可能的话,该ScrollBar仅仅覆盖这个view的背景. insideInset：该ScrollBar显示在padding区域里面,增加了控件的padding区域,该ScrollBar不会和视图的内容重叠. outsideOverlay：该ScrollBar显示在视图(view)的边缘,不增加view的padding,该ScrollBar将被半透明覆盖 insideOverlay：该ScrollBar显示在内容区域里面,不会增加了控件的padding区域,该ScrollBar以半透明的样式覆盖在视图(view)的内容 isScrollContainer：布尔值，设置当前View是否为滚动容器（是否可以为输入法腾出空间而隐藏） scrollbarFadeDuration：褪色时间 scrollbarDefaultDelayBeforeFade：设置滚动条N毫秒后开始淡化，以毫秒为单位。 scrollbarSize：设置滚动条大小 scrollbarThumbHorizontal/Vertical：设置水平/垂直滚动条的drawable scrollbarTrackHorizontal/Vertical：设置水平/垂直滚动条背景（轨迹）的drawable scrollbarAlwaysDrawHorizontalTrack/VerticalTrack：布尔值，设置水平滚动条是否含有轨道 scrollbarAlwaysDraw：布尔值，设置垂直滚动条是否含有轨道 requiresFadingEdge：定义褪色时滚动边缘（可设值：none/horizontal/vertical） nextFocusLeft/Right/Up/Down/Forward：Up键按下之后，哪一个控件获得焦点（被选中） clickable：布尔值 longClickable：布尔值 saveEnabled：布尔值，设置是否在窗口冻结时（如旋转屏幕）保存View的数据 drawingCacheQuality：设置绘图缓存质量（可设值：auto/low/hight） keepScreenOn：布尔值，View在可见的情况下是否保持唤醒状态 duplicateParentState：布尔值，如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等）。 注意根据目前测试情况仅仅是获取绘图状态，而没有获取事件，也就是你点一下LinearLayout时Button有被点击的效果，但是不执行点击事件。 minHeight/Width soundEffectsEnabled：布尔值，设置点击或触摸时是否有声音效果 hapticFeedbackEnabled：布尔值，实现单击某个视图，系统提供一个触力反馈（震动一下） contentDescription：图片不可见时的文字描述（盲人） onClick：触发方法 overScrollMode：滚动到边界时的效果（可设值：ifContentScrolls/always/never） alpha：透明度，小数表示占比 translationX/Y：X/Y轴的偏移距离 transformPivotX/Y：从某点的X/Y轴偏移距离 rotation：旋转（X和Y轴同时） rotationX/Y scaleX/Y：设置X/Y轴缩放比例 verticalScrollbarPosition：设置垂直滚动条的位置（可设值：defaultPosition/left/right） layerType：绘图是否开启硬件加速（可设值：none/hardware/software） layoutDirection：定义布局图纸的方向 textDirection：文字排列方向 textAlignment：文字对齐方式（可设值：inherit/…） importantForAccessibility：设置可达性的重要行（可设值：noHideDescendants/…） accessibilityLiveRegion： labelFor：添加标签 measureAllChildren：布尔值，测量时是否考虑所有所有子控件，不考虑则按是否显示来测量 animateLayoutChanges：布尔值，添加默认布局动画 clipChildren：布尔值，子控件是否要在它应有的边界内进行绘制 clipToPadding：布尔值，ViewGroup是否允许在padding中绘制（配合clipChildren适合做放大等的点击特效，不用去更改布局，只需加入这两个属相并引入动画效果即可实现） layoutAnimation：设置layout动画 animationCache：定义子布局也有动画效果 persistentDrawingCache alwaysDrawnWithCache：定义子布局是否应用绘图的高速缓存 拿最强大的ConstraintLayout举例 &lt;android.support.constraint.ConstraintLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/login_btn" ... app:layout_constraintTop_toTopOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintBottom_toBottomOf="parent" /&gt; &lt;EditText android:id="@+id/password_textview" ... app:layout_constraintVertical_bias="0.5" app:layout_constraintBottom_toTopOf="@+id/login_btn" app:layout_constraintTop_toTopOf="@id/accoutn_textview" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent"/&gt; &lt;EditText android:id="@+id/accoutn_textview" ... app:layout_constraintVertical_bias="0.8" app:layout_constraintBottom_toTopOf="@+id/password_textview" app:layout_constraintTop_toTopOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" /&gt; &lt;TextView android:id="@+id/separate_line" ... app:layout_constraintVertical_bias="0.2" app:layout_constraintTop_toBottomOf="@+id/login_btn" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" /&gt; &lt;Button android:id="@+id/guest_btn" ... app:layout_constraintHorizontal_bias="0.3" app:layout_constraintVertical_bias="0.2" app:layout_constraintTop_toBottomOf="@+id/separate_line" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintBottom_toBottomOf="parent"/&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 在Activity中使用以下方法应用布局，当然也可以在运行时用代码 setContentView(R.layout.main_layout);找到布局后接着使用以下方法根据资源ID获取布局中的视图 Button myButton = (Button) findViewById(R.id.my_button);ToolBar自定义示例（不能用android:style，只能用android:theme） &lt;android.support.design.widget.AppBarLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/AppTheme.AppBarOverlay" &gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" app:contentInsetEnd="0dp" app:contentInsetLeft="0dp" app:contentInsetRight="0dp" app:contentInsetStart="0dp" app:popupTheme="@style/AppTheme.PopupOverlay"&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical" android:layout_gravity="center"&gt; &lt;TextView android:id="@+id/toolbar_title" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_weight="2" android:textAlignment="center" android:textColor="@color/colorBlack" android:gravity="center" /&gt; &lt;TextView android:id="@+id/toolbar_subtitle" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_weight="1" android:textAlignment="center" android:textColor="@color/colorDark" android:layout_gravity="center"/&gt; &lt;/LinearLayout&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.AppBarLayout&gt; ListView其实ListView本身没多少内容需要讲，其主要得依靠一个扩展(继承)于BaseAdapter的适配器，来获取数据源的Item数、Item标识、Item视图 mMyAdapter = new MyAdapter(this, R.layout.list_item, datas); mListView = (ListView) findViewById(R.id.list); mListView.setAdapter(mMyAdapter);//不能赋null mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; updateData(mMyAdapter.getItem(position)); &#125; &#125;); public class MyAdapter extends ArrayAdapter&lt;GameInterface&gt; &#123; private ArrayList&lt;ModelInterface&gt; mDatas; private int resourceId; private Context context; public MyAdapter(Context context, int resourceId, ArrayList&lt;ModelInterface&gt; objects) &#123; super(context, resourceId, objects); this.mDatas = objects; this.resourceId = resourceId; this.context = context; &#125; @Override public int getCount() &#123; return mDatas == null ? 0 : mDatas.size(); &#125; @Override public GameInterface getItem(int position) &#123; if (mDatas == null || mDatas.size() &lt;= position)&#123; return null; &#125; return mDatas.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ModelInterface game = (ModelInterface) getItem(position); View view; ViewHolder viewHolder; if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, null); viewHolder = new ViewHolder(); viewHolder.titleView = (TextView) view.findViewById(R.id.title_view); viewHolder.contentView = (TextView) view.findViewById(R.id.content_view); view.setTag(viewHolder); //缓存 &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); &#125; viewHolder.titleView.setText("title"); viewHolder.contentView.setText("content"); return view; &#125; class ViewHolder &#123; TextView titleView; TextView contentView; &#125; &#125; RecyclerView对比ListView，RecyclerView可以理解为一个加强版的ListView，它更灵活、自定义更容易，回收机制也更完善、性能更好、滑动更流畅。灵活体现在RecyclerView所细分的各司其职的对象 LayoutManager //布局管理器 ListView GridView 瀑布流 Adapter //适配器 ItemAnimator //Item的动画 ItemDecoration //Item的分割 其次RecycleView还提供了： 提供了局部刷新 支持嵌套滑动（NestedScrollView或者CoordinatorLayout） 把点击事件的控制权完全的交给开发者，避免了Item与其内的控件点击事件的冲突 创建一个最普通的RecyclerView示例 mMyRecyclerView = findViewById(R.id.my_recyclerview); mMyAdapter = new MyAdapter(this); mMyAdapter.setOnItemClickListener(this); // 创建RecyclerView的布局管理器 LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false); mMyRecyclerView.setLayoutManager(layoutManager); mMyRecyclerView.setAdapter(mMyAdapter); // 创建Item分割样式 DividerItemDecoration dividerItemDecoration = new DividerItemDecoration(this, DividerItemDecoration.VERTICAL); dividerItemDecoration.setDrawable(getResources().getDrawable(R.drawable.inset_recyclerview_divider)); mMyRecyclerView.addItemDecoration(dividerItemDecoration); // 创建（默认）Item动画效果 mMyRecyclerView.setItemAnimator(new DefaultItemAnimator()); /// RecyclerView Adapter public class MyAdapter extends RecyclerView.Adapter &lt;MyAdapter.ViewHolder&gt; &#123; private LayoutInflater mLayoutInflater; private Context mContext; private ArrayList&lt;ReportModel&gt; datas; private OnClickItemListener mOnItemClickListener; public interface OnClickItemListener &#123; void onClickItem(Model model); &#125; public MyAdapter(Context context) &#123; this.mLayoutInflater = LayoutInflater.from(context); this.mContext = context; this.datas = new ArrayList&lt;ReportModel&gt;(); &#125; @NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; //当Item的ViewHolder复用池中不够显示数量时需创建ViewHolder的方法进行回调式的封装（对应着需显示的View，而View由RecyclerView内部创建） return new MyViewHolder(mLayoutInflater.inflate(R.layout.list_item , viewGroup, false)); &#125; @Override public void onBindViewHolder(@NonNull final MyViewHolder viewHolder, int i) &#123; //对复用的ViewHolder进行更新，也采用回调式的封装 final Model model = (Model)datas.get(i); viewHolder.titleView.setText("title"); viewHolder.contentView.setText("content"); viewHolder.accountSubTitle.setText(report.getCreatedUser()); viewHolder.imageView.setImageResource(R.drawable.item_image); viewHolder.itemLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mOnItemClickListener.onClickItem(model); &#125; &#125;); &#125; &#125; @Override public int getItemCount() &#123; return datas == null ? 0 : datas.size(); &#125; public static class MyViewHolder extends RecyclerView.ViewHolder &#123; public TextView titleView; public TextView contentView; public ImageView imageView; RelativeLayout itemLayout; MyViewHolder(View view) &#123; super(view); titleView = view.findViewById(R.id.list_item_title); contentView = view.findViewById(R.id.list_item_content); imageView = view.findViewById(R.id.list_item_iamge); itemLayout = view.findViewById(R.id.list_item_relative_layout); &#125; &#125; public void setOnItemClickListener(OnClickItemListener listener) &#123; this.mOnItemClickListener = listener; &#125; &#125; 其它集合View ViewPager（代替以往的Gallery） HorizontalScrollView（代替以往的Gallery） GridView NestedScrollView 控件 TextView类似iOS中的UILable &lt;TextView android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/colorBlue" android:gravity="bottom" android:textAlignment="center" android:padding="4dp" android:text="@string/title" android:textColor="@color/colorBlack" android:textStyle="bold" ···/&gt; EditView类似iOS中UITextField、UITextView &lt;EditText android:layout_width="250dp" android:layout_height="wrap_content" android:gravity="center_vertical" android:background="@android:drawable/edit_text" android:imeOptions="actionDone" android:hint="请输入密码" android:inputType="textPassword" android:textColorHint="@color/colorDark" ···/&gt; //TextView.OnEditorActionListener editView.setOnEditorActionListener(this); @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; Log.d("", "text: " + v.getText().toString()); return false; &#125; Button &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮" ···/&gt; ImageView &lt;ImageView android:layout_width="0dp" android:layout_height="30dp" android:src="@drawable/ic_image" android:gravity="center" ···/&gt; imageView.setImageResource("R.id.image"); ProgressBar &lt;ProgressBar android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:visibility="gone"/&gt; progressBar.setVisibility(View.VISIBLE); progressBar.setVisibility(View.GONE); Spinner &lt;Spinner android:entries="@array/distribute_platform" android:spinnerMode="dialog" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:layout_margin="5dp" android:textColor="@color/colorBlack" /&gt; &lt;resources&gt; &lt;string-array name="distribute_platform"&gt; &lt;item&gt;1&lt;/item&gt; &lt;item&gt;2&lt;/item&gt; &lt;item&gt;3&lt;/item&gt; &lt;/string-array&gt; &lt;/resources&gt; SearchView &lt;SearchView ··· android:iconifiedByDefault="false" android:queryHint="请输入gameCode搜索"&gt; &lt;/SearchView&gt; SearchView mSearchView = findViewById(R.id.search_bar); mSearchView.setEnabled(true); mSearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() &#123; // 当点击搜索按钮时触发该方法 @Override public boolean onQueryTextSubmit(String query) &#123; // 查询、过滤 return true; &#125; // 当搜索内容改变时触发该方法 @Override public boolean onQueryTextChange(String newText) &#123; if (newText.isEmpty()) &#123; // 刷新界面 &#125; return false; &#125; &#125;); Switch &lt;Switch android:layout_width="wrap_content" android:layout_height="@dimen/test_config_list_item_height" android:scaleX="2" android:scaleY="2" android:textOff="" android:textOn="" android:gravity="center" ··· /&gt; //CompoundButton.OnCheckedChangeListener switch.setChecked(true); switch.setOnCheckedChangeListener(this); @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; Integer buttonPosition = (Integer) buttonView.getTag(buttonNumber); ··· &#125; 监听者 Listener可以用到监听者的场景包括： 按钮点击事件的响应 下级页面的回调方法提供 列表Item或其子控件的点击事件的响应 导航栏的Item点击事件的响应 TextView编辑动作的监听 其实它就和iOS中的代理模式如出一辙，linstener是去实现Interface的，delegate对象是认领遵循一个Protocol的，它们在概念上的区别是： 协议，是当委托对象执行某方法中，需要一个遵循某协议的对象帮忙完成该协议中的事情时，就会委托它所持有的delegate属性(代理对象)去执行协议方法 监听，是当执行某方法的中的主体，认为此时需要告知它所持有的需要知道此刻此情况的监听者的话(因此获取通知的方法是主体所定义)，就会调用listener属性(监听者)去执行接口定义中获取通知的方法 示例 // demo1 public class MySecondActivity extends AppCompatActivity &#123; public CallbackListener mCallbackListener; public interface CallbackListener &#123; void onCallback(Model model); &#125; private void doSomething() &#123; ··· this.mCallbackListener = this.context; mCallbackListenr.onCallback(data); ··· &#125; &#125; public class MyFirstActivity extends AppCompatActivity implements MySecondActivity.CallbackListener &#123; private void onCallback(Model model) &#123; // update ··· &#125; private void doSomething() &#123; Intent intent = new Intent(this, MySecondActivity.class); startActivity(intent); &#125; &#125; // demo2 Button button = findViewById(R.id.button_id); button.setOnClickListener(new View.OnClickListener() &#123; //创建一个实现OnClickListener接口的内部匿名类并同时进行实例化new，监听按钮的点击 @Override public void onClick(View v) &#123; ··· &#125; &#125;); 当然，Interface并不仅仅局限于监听者这个概念上，作为解耦、抽象的利器，作用范围非常广，就看怎么去结合你的设计模式去利用，例如对多种同类的模型对象进行抽象，使展示页面与这种种类逻辑解耦，就可以用到接口设计，等等。 资源资源-官方文档 Android应用的资源，是指代码使用的附加文件和静态内容，例如位图、布局定义、界面字符串、动画说明等，都集中存放于res（src/main/res）和assets文件夹下，这样才能起到资源脱离代码实现外部化，以便单独对其进行维护。 所有资源ID都在项目的R类中进行定义，该类由aapt工具自动生成，在R类中通过资源类型+资源名称这样的组合来访问资源。例如： //代码中 R.string.hello //XML中 @string/hello //格式模板 [&lt;package_name&gt;.]R.&lt;resource_type&gt;.&lt;resource_name&gt; @[&lt;package_name&gt;:]&lt;resource_type&gt;/&lt;resource_name&gt; 同一种资源类型resource_type，还可区分不同的语言和屏幕密度。 resres中包含以下常见的资源类型 animator：定义属性动画 drawable：存放位图文件、可绘制对象 mipmap：启动器的可绘制对象 layout：定义界面布局 menu：定义应用菜单 raw：以原始形式保存的任意文件，运行时通过 Resources.openRawResource() ， 资源ID为R.raw.filename values：包含字符串、整型数和颜色等简单值。像控件、字符等的颜色(colors)，间距(dimens)，字符串(strings)，控件样式(style) xml：自定义的配置，运行时通过 Resources.getXML() 读取 font：字体 &lt;resources xmlns:android="http://schemas.android.com/apk/res/android"&gt;//导入可引用R类中的资源ID &lt;item name="ic_menu_camera" type="drawable"&gt;@android:drawable/ic_menu_camera&lt;/item&gt; &lt;/resources&gt; 如果还要引用其它辅助功能的话，布局上则需要带上 xmlns:app=”http://schemas.android.com/apk/res-auto&quot; 和 xmlns:tools=”http://schemas.android.com/tools&quot; 的声明，不过一般只在Layout上使用较多。 assetsassets/中的文件没有资源ID，因此只能使用AssetManager读取这些文件。如需访问原始文件名和文件层次结构，就应考虑将某些资源保存在assets/目录。 模型 Model数据的获取、存储、数据状态变化都将是Model层的任务。而单单描述一个事物对象属性的类，只能称之为Value Object，是模型层的一部分而已。 先从Model层的架构说起，按Google和Boilerplate的说法，Model层的结构可以分别按如下两图设计 Repository层的作用时屏蔽底层细节，使上层不需要知道数据的细节，包括像网络、数据库，内存等等的这些数据的操作细节。 View层：处理用户的交互和输入事件，并且触发Presenter中的相应操作。 Presenter层：Presenters 订阅（subscibe） RxJava的Observables，负责处理订阅周期，处理由DataManager提供的数据，并调用View层中的相应方法展示数据。 Model层：负责获取、保存、缓存以及修改数据。负责与本地数据库、其他数据存储、restful APIs、以及第三方SDKs的交互。 DataManager：结合并且转化不同的Helpers类为Rx操作符，向Presenter层提供Observables类型的数据（provide meaningful data to the Presenter），并且同时处理数据的并发操作（group actions that will always happen together.）。这一层也包含实际的Model类，用于定义当前数据架构，也就是不同人所说的Entry，Bean，Pojo等。DataManager就好比上面的Repository 其次，再说Model层中的Model实体类的实现，包括 构成方法：自定义构造方法，如果实体比较复杂，可能会用到工厂模式或者是建造者模式 序列化：比如实现Serializable接口，Parcelable接口。 Json解析：有时候直接使用的是json数据，比如@SerializedName注解。 自定义方法：对Model的字段有setter，getter方法，toString的实现，在处理hash的时候，需要实现equals和hashcode方法。 关于持久化的实现，最近使用过一个出名的持久化第三方库Realm。Realm是由美国YCombinator孵化的创业团队历时几年打造，它是第一个专门针对移动平台设计的数据库，是一个跨平台的移动数据库引擎，是由核心数据引擎C++打造，拥有独立的数据库存储引擎，可以方便、高效的完成数据库的各种操作。Realm具有开源、简单易用、跨平台、线程安全这些优点，在Mac上有可视化工具Realm Browser辅助。Java的仓库戳这里👇。 Realm的使用步骤： 主工程build.gradle中的dependencies添加 classpath “io.realm:realm-gradle-plugin:x.y.z”，应用Module的build.gradle中apply plugin: ‘realm-android’ 在MainActivity或者自定义的Application的OnCreate()中初始化 Realm.init(this); Model类继承RealmObject Model的所有属性设置为private并实现对应的getter和setter 查 Realm realm = Realm.getDefaultInstance(); Model model = mRealm.where(Model.class).findFirst(); RealmResults&lt;Model&gt; results = realm.where(Model.class).findAll(); RealmResults&lt;Model&gt; results = realm.where(Model.class).equalTo("key", "value").findAll(); results = results.sort("key", Sort.DESCENDING); List&lt;Model&gt; models = realm.copyFromRealm(results); //除了findAll()，还有sum()、average()、min()、max()、findAllSorted() 增 Realm realm = Realm.getDefaultInstance(); realm.beginTransaction(); Model model = realm.createObject(Model.class); model.setName("Bob"); model.setSex("male") //realm.copyToRealm(model); //可在beginTransaction外先生成好model和设置好属性，再直接使用此方法在beginTransaction中同步到Realm数据库中，最后也需要commitTransaction realm.commitTransaction(); /* 也可使用内部匿名类的方式创建Transaction mRealm.executeTransaction(new Realm.Transaction() &#123; @Override public void execute(Realm realm) &#123; //··· &#125; &#125;); */ 改 Realm realm = Realm.getDefaultInstance(); RealmResults&lt;Model&gt; results = realm.where(Model.class).equalTo("name", "Bob").findAll(); //查唯一值的条件 if (result.size() &gt; 0) &#123; realm.beginTransaction(); Model model = result.get(0); model.setSex("Female"); realm.commitTransaction(); &#125; 删 Realm realm = Realm.getDefaultInstance(); RealmResults&lt;Model&gt; results = realm.where(Model.class).equalTo("key", "value").findAll(); //查唯一值的条件 if (result.size() &gt; 0) &#123; realm.beginTransaction(); Model model = result.get(0); model.deleteFromRealm(); //results.deleteFirstFromRealm(); //results.deleteLastFromRealm(); //results.deleteAllFromRealm() realm.commitTransaction(); &#125; 网络请求方面，一般会选择使用okhttp。 适配器 AdapterAdapter是用来帮助填充数据的，将各种数据以合适的形式显示到view上，提供给用户看！ Adapter和iOS中UITableViewController非常相似，继承BaseAdapter就好比遵循了UITableDelegate和UITableViewDataSource两个协议，为自定义的需要而实现数据源和视图的输出方法。 Adapter的继承结构图如下 实际开发中用得最多的其实是BaseAdapter，它是一个抽象类，实现了ListAdapter和SpinnerAdapter两个接口，而这两个接口都是Adapter这个接口的扩展接口。 ListAdapter定义了 areAllItemsEnabled() 是否所有Item可选择点击 isEnabled() 某一位置上的Item是否可选择点击两个方法 在BaseAdapter的实现中默认都为true SpinnerAdapter定义了 getDropDownView() 返回下拉视图的方法 BaseAdapter的实现中默认是通过调用它自己的getView()返回 Adapter定义的方法中，关键且常被重写的方法为 getCount() 返回数据的总数 getItem() 返回某行数据的模型 getItemId() 返回某行数据的ID，一般就是位置索引 getView() 返回某行的自定义视图 继承BaseAdapter的开发步骤： 获取并持有数据源 实现数据相关的输出方法（getCount、getItem、getItemId） 定义内部的ViewHolder类，包含每行需显示的控件属性，不同类型行的ViewHolder需分开定义 实现视图相关的输出方法（getView），第一次创建view时，将对应的ViewHolder对象塞入要返回的view的tag中，同时对ViewHolder对象中的控件设置上数据值；下次获取到view时只需从tag中取出ViewHolder对象更新控件的数据值即可，达到了控件复用的效果。 另一个使用率较高的就是RecyclerView.Adapter，与BaseAdapter有相似之处，也有不同之处，其具体开发步骤： getItemCount() 返回Item的总数，注意判空 getItemViewType() 返回Item视图的类型 onCreateViewHolder() 根据上一点的方法返回类型，创建ViewHolder，给Adapter去关联view onBindViewHolder() 触发绑定ViewHolder，在这个方法中，我们只需负责更新ViewHolder对象中控件的数据值即可，所以，我们可以为RecyclerView.Adapter指定它的泛型。 说到RecyclerView.Adapter，有一个比较出名的第三方BaseRecyclerViewAdapter，封装了很多便利的方法供直接调用和省去很多接口的实现，也基本能满足大部分效果的需求，有兴趣可以去额外了解下-随意门。 ArrayAdapter： 例化时可以使用泛型构造，可在构造函数的第二个参数绑定一个layout，第三个参数绑定数据源（其内部使用此数据源去实现getCount、getItem等方法，无需亲自实现一遍） 增加了很多和数组相对应的操作，如add()、addAll()、insert()、clear()、remove()、sort()、setNotifyOnChange()（控制以上操作方法执行后是否自动执行notifyDataSetChanged()，当参数为false时则需手动执行。应用场景为当处理的数据量大时，可在处理前设置为false，处理后手动执行notifyDataSetChanged()） ArrayAdapter默认期望布局文件里只有一个TextView，实现稍微复杂的TextView可在构造方法中传入指定的Field ID，实现复杂布局时需重写getView()方法。 ArrayAdapter默认下会调用List中对象的toString()方法去设置TextView 一个小技巧，当使用固定的数据源时，可在res中直接创建数据源的xml，然后给ListView布局中引用（系统内部创建ArrayAdapter去接收）， &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;resources&gt; &lt;string-array name="myarray"&gt; &lt;item&gt;语文&lt;/item&gt; &lt;item&gt;数学&lt;/item&gt; &lt;item&gt;英语&lt;/item&gt; &lt;/string-array&gt; &lt;/resources&gt; &lt;ListView android:id="@id/list_test" android:layout_height="match_parent" android:layout_width="match_parent" android:entries="@array/myarray"/&gt; SimpleAdapter：更方便地套用Item的显示样式 SimpleAdapter myAdapter = new SimpleAdapter(getApplicationContext(), listitem, R.layout.list_item, new String[]&#123;"header", "name", "says"&#125;, new int[]&#123;R.id.header, R.id.name, R.id.says&#125;); SimpleCursorAdapter：过时的一种类，其实就是存入一个Cursor对象，由其内部利用cursor读取数据，用于在数据库获取简单文本显示的listView。不太推荐使用，直接扩展BaseAdapter，自行读取数据库会更好。 FragmentPagerAdapter：顾名思义 getCount() 返回title或者fragment的总数 getItem() 返回指定位置的fragment getPageTitle() 返回指定位置的title 创建了Adapter后，最后记得设置到ListView或者RecyclerView的adapter属性中去。 跨应用通信 AIDL服务-官方文档AIDL-官方文档 在开发跨应用通信前，首先必须去了解4大组件之一的服务是什么东西，看完服务的文档，才能理解跨应用的工作原理。 这里简单概括一下，服务可以分为前台、后台、绑定这三种类型，均需自行创建线程执行操作，否则是在主线程上执行。前台和后台的服务生命周期结束是由调用者或自己所控制，绑定服务则全由发起绑定的应用组件所管理。可以使用Service和IntentService创建服务，前者需自行创建线程执行操作，否则会影响应用性能，后者则由其内部使用工作线程逐一处理所有启动请求。而进程间通信 (IPC)就是利用绑定实现的，一般描述是发起绑定的为客户端，提供服务的为服务端。 下面再讲述如何使用AIDL（安卓接口定义语言）。 AIDL是什么，它是可以被利用去所定义的客户端与服务使用进程间通信 (IPC) 相互通信时都认可的编程接口。 实现的主要步骤如下： 使用Java语言在.aidl文件中定义出AIDL接口，然后分别保存在服务和客户端的源码中（src/ 目录），一般是指定一样的具体路径，例如服务的.aidl文件存放于服务项目下的src/main/aidl/com/xx/yy/IXxAidlInterface.aidl，那么客户端的.aidl文件则存放于客户端项目下的同名路径下（作为副本存在，因为客户端也需具有对interface类的访问权限），其中com.xx.yy就是服务所在项目的包名，注意确保两端的aidl文件内容也是一致的。 编译后，IBinder接口文件–IXxAidlInterface.java文件会被自动生成（与aidl文件名同名），。 IXxAidlInterface.java里具有一个名为Stub的内部抽象类(继承自Binder并实现IXxAidlInterface)，用它来给服务扩展Binder类并重写实现AIDL接口中的方法。 最后，服务向客户端公开接口的方式，就是实现Service并重写 onBind() 以返回Stub类，去定义服务的RPC接口。 RPC是同步调用的，需自行处理多线程工作和保障线程安全（或客户端从单独的线程中调用服务），否则可能会导致客户端出现“Application is Not Responding”的提示，同时异常是不会进行传递。 客户端实现ServiceConnection，在onServiceConnected()的回调中会接收服务的 onBind() 方法返回的 mBinder 实例，此时需调用IXxAidlInterface.Stub.asInterface(service)以将返回的参数转换成自己的ServiceInterface类型（service即是IBinder），后面就可以使用它来调用服务的接口方法进行通信了。 客户端触发IPC，调用Context.bindService()，传入我们的ServiceConnection实现（作为连接的回调对象）。 如果需要在接口中传递对象，则类必须实现Parcelable接口，同时服务和客户端两侧都要有此类可供引用。 示例： 定义AIDL的接口 package com.xx.yy interface IXxAidlInterface &#123; void doSomething(String data); &#125; 定义服务，实现绑定相关方法 public class MyAidlService extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; // ··· return new MyBinder(); //也可以在此直接返回IXxAidlInterface.Stub的匿名内部类的实例，省去定义Binder的类 &#125; @Override public boolean onUnbind(Intent intent) &#123; // ··· return super.onUnbind(intent); &#125; 服务端定义Binder，实现AIDL中的接口方法 public class MyBinder extends IXxAidlInterface.Stub &#123; @Override public void doSomething(String data) throws RemoteException &#123; ··· &#125; &#125; 服务端AndroidManifest中声明Service &lt;service android:name="com.xx.yy.service.MyAidlService" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="com.xx.yy.service.MyAidlService"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;/intent-filter&gt; &lt;/service&gt; 客户端实现ServiceConnection public class MyServiceConnection implements ServiceConnection &#123; private IXxAidlInterface mService; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mService = IXxAidlInterface.Stub.asInterface(service); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; mService = null; &#125; //可以通过返回mService，外面新建类使用其与业务逻辑进行封装 public void doSomething(String data) &#123; mService.doSomething(data); &#125; &#125; 客户端触发IPC Intent service = new Intent("com.xx.yy.service.IXxAidlInterface");//sevice的路径 service.setPackage("com.xx.yy"); service.putExtra("key","value"); List&lt;ResolveInfo&gt; list = context.getPackageManager().queryIntentServices(service, PackageManager.MATCH_DEFAULT_ONLY); if (list == null || list.isEmpty() || list.size() == 0)&#123; return;//服务(App)不存在 &#125; MyServiceConnection connection = new MyServiceConnection(); if(connection != null) &#123; try &#123; context.bindService(service, connection, Context.BIND_AUTO_CREATE); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 多线程AsyncTaskAsyncTask是用来实现工作线程与主线程（UI线程）之间通信 使用步骤 创建AsyncTask子类并根据需求实现核心方法 创建AsyncTask子类的实例对象 手动调用实例对象的execute()从而执行异步线程任务 private class MyTask extends AsyncTask&lt;Params, Progress, Result&gt; &#123; .... //执行异步线程前的回调，处理UI的初始化，是在主线程中回调的 @Override protected void onPreExecute() &#123; ... &#125; //执行异步线程任务 @Override protected String doInBackground(String... params) &#123; ...// 自定义的线程任务 // 可调用publishProgress()显示进度，之后将回调onProgressUpdate() publishProgress(count); &#125; //进度回调，在主线程中回调的 @Override protected void onProgressUpdate(Integer... progresses) &#123; ... &#125; //返回异步线程任务的执行结果，在主线程中回调 @Override protected void onPostExecute(String result) &#123; ...// UI操作 &#125; //将异步线程任务状态置为取消后，需自行在doInBackground判断任务的状态进行实质性的阻止中断，即回调此函数 @Override protected void onCancelled() &#123; ... &#125; &#125; //实例必须在UI线程中创建 MyTask mTask = new MyTask(); //a. 必须在UI线程中调用 //b. 同一个AsyncTask实例对象只能执行1次，若执行第2次将会抛出异常 //c. 执行任务中，系统会自动调用AsyncTask的一系列方法：onPreExecute() 、doInBackground()、onProgressUpdate() 、onPostExecute() //d. 不能手动调用上述方法 mTask.execute()； //执行异步线程的任务 Thread + Handler创建线程有两种方法 继承Thread类，重写Thread的run()方法（Thread也实现了Runnable接口） 实现Runnable接口，重写Runnable的run()方法，并将其作为参数实例化Thread，这样能避免Thread单继承的局限和多Thread之间可以共享Runnable中的资源。 public class MyThread extends Thread &#123; @Overide public void run() &#123; ...//异步线程任务 &#125; &#125; MyThread t = new MyThread();//创建已内含任务的线程 t.start(); public class MyRunnable implements Runnable &#123; public void run() &#123; ...//任务 &#125; &#125; MyRunnable runnable = new MyRunnable(); Thread r = new Thread(runnable, &quot;threadName&quot;);//创建线程并指定任务 r.start(); 若要进行线程之间的切换通信，而多线程又选用了Thread实现，那么就需要搭配Handler使用了，因为Handler的最大作用就是线程的切换。 子线程与主线程通信的示例： //在主线程实例化Handler Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; //msg是从子线程发来的消息 switch (msg.what) &#123; case 1: Log.i(&quot;&quot;, msg.obj); break; &#125; &#125; &#125;; //开启子线程 new Thread(new Runnable() &#123; @Override public void run() &#123; //在子线程发送一个消息。 Message msg = new Message(); //正常应使用Message.obtain();，这样可利用到系统的Message缓存池，优化内存 msg.obj = &quot;自定义传递的数据对象&quot;; msg.what = 0; //what相当于msg的ID handler.sendMessage(msg);//同一个消息不要发送两次，否则报错，因为消息队列中不允许存在重复的消息 //可使用post代替sendMessage，post内部会将Runnable封装成Message再发出去，且此Runnable的run方法比Handler中的handleMessage更高优先级 handler.post(new Runnable() &#123; @Override public void run() &#123; //这里是消息处理的方法，运行在主线程。 &#125; &#125; &#125; &#125;).start(); 在主线程实例化Handler的话，其handleMessage是在主线程执行，因为Handler默认采用了主线程的Looper进行绑定，即是Handler在默认情况下，哪个线程创建它，就获取那个线程的Looper进行绑定，消息的处理也就在Looper所在的线程进行，除非在实例方法中额外指定Looper给Handler。（Thread拥有Looper，Looper拥有Handler和MessageQueue） 若要在子线程创建Handler，则需要自行创建Looper并开启其循环，才能使Handler正常工作，因为其它线程利用绑定该子线程Looper的Handler向往此子线程发消息时，会将Message塞入子线程的MessageQueue去，没有Looper的话就子线程就不会去它的MessageQueue上取消息出来分发给Handler处理（可能连消息的发送阶段就已不能成功？）。 //在主线程创建并开启子线程异步任务 Handler handler; new Thread(new Runnable() &#123; @Override public void run() &#123; //创建当前线程的Looper，因一个线程只能有一个Looper所以不能调用两次 Looper.prepare(); //在子线程创建Handler对象 handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; //这里是消息处理，运行在子线程 &#125; &#125;; //开启Looper的消息轮询 Looper.loop(); &#125; //如果Handler不再需要发送和处理消息，那么就需要退出子线程的消息轮询 //Looper.myLooper().quit(); //Looper.myLooper().quitSafely(); &#125;).start(); //在主线程发送一个消息到子线程 Message msg = new Message(); handler.sendMessage(msg); 还有其它一些扩展的方法 //延时发送消息 public final boolean sendMessageDelayed(Message msg, long delayMillis) public final boolean postDelayed(Runnable r, long delayMillis); //定时发送消息（类比iOS的NSTimer） public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; public final boolean postAtTime(Runnable r, long uptimeMillis); public final boolean postAtTime(Runnable r, Object token, long uptimeMillis); Activity类的runOnUiThread()、View类的post()、HandlerThread类，这些其实都是内部实现了或方便实现Handler的机制，封装起了一系列的方法，方便我们使用，例如runOnUiThread内部就是调用Activity在主线程创建的Handler去执行post(runnable)，再例如HandlerThread本质就是个Thread，与普通Thread的差别在于其内部实现了Looper的创建，方便地让Handler可以直接指定使用这个线程的Looper。 话说回iOS，实现这种跨线程的通信，GCD相对方便一点，从发起异步任务，到与其它线程通信，这两部分逻辑的代码可以整合在一起实现，非常清晰，不过这是系统封装后的得益而已。NSThread也一样，系统通过封装好各种performSelector的方法，由我们自由选择执行的指定方法所在的线程（比Handler只能在Runnable Callback或者handleMessage这两个地方回调更有灵活性），实现线程间的通信，只要持有目标通信的NSThread，就好比持有着Handler，需要通信时就用其来发消息（performSelector），performSelector内部其实也是通过消息队列机制来触发任务线程去处理任务（借助NSTimer），也是需要一个循环体NSRunLoop才能起作用。 打包Apk操作路径：Build-&gt;Build Bundle(s) / APK(s)-&gt;Build APK(s)产出路径：[project]/[module]/build/outputs/apk/debug 选择Build Bundle(s)的话，产出的是aab(Android Application Bundle)，aab是一种新型的上传包格式，它能包裹应用所编译的代码和资源，但只能用于Google Play。 若要使APK带签名的，则选择Generate Signed Bundle / APK，这项是需要指定keystore文件和其密码及别名的。 jar使用Android Studio对工程进行编译后，就会自动生成jar，所在路径为 /build/intermediates/bundles/debug(release)/classes.jar /build/intermediates/packaged-classes/release/classes.jar但若想删除jar中一些无用的内容，可以在要打jar的Module中的build.gradle里自定义一个打jar的Task，如下为制作一个指定输出路径、输出文件名、删除BuildConfig.class文件的jar task makeJar(type: Jar, dependsOn: [&apos;assembleRelease&apos;]) &#123; destinationDir = file(&apos;build/outputs/libs&apos;) baseName = &quot;jar_name&quot; // SDK名称 version = &quot;1.0.0&quot; // 版本号 from(zipTree(&apos;build/intermediates/packaged-classes/release/classes.jar&apos;)) // jar的实际来源 exclude(&apos;com/xx/yy/BuildConfig.class&apos;) &#125; 由上面build.gradle中可以看出，我们单独去调用Gradle的assembleRelease这个Task，也是可以进行编译生成jar的。 arr对比jar，aar是更适合作为SDK的格式，因为它可以同时把class和res文件一起打包。 打包方式也很简单，只要在一个Project下，新建一个用于打包的Module（Android libraries），SDK的源码和资源都在这个Module下添加，那么只要此Module一被编译，aar就能被生成，生成路径为 /build/outputs/aar/libraryname.aar开发时在Project下新建另一个Module，作为Demo App，其依赖上述的aar Module，就可以实现模拟接入和调试。 设计模式MVP在MVC的基础上增加了Presenter层后，Activity应该要改为视作View层，其原本控制器的职能已转移到了Presenter层上，进一步减少View和Model的耦合。 做法： 抽象View层的更新界面接口，由View（Activity）实现此接口，接口提供传入Value Object的方法去刷新View上的数据值 抽象出Presenter绑定（泛型的）抽象View的接口类，具体业务Presenter实现此接口并持有（绑定）View和（创建）Model（即每一个Activity都有一个相应的Presenter来处理数据） 具体业务Presenter需同时作为Model获取数据后的回调对象，即Model也持有Presenter，Presenter给Model提供回传出Value Object的获取数据接口 具体业务Presenter控制Model去获取数据和刷新View，以及响应View修改Model的数据 MVVM将Presenter改名为ViewModel，基本上与MVP模式完全一致。唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在ViewModel，反之亦然，即是Presenter不但要作为Modle的回调对象，还要作为View的回调对象，拿MVP上的做法为例，若View在实现时也持有了（创建）Presenter和会调用Presenter的更新数据接口，那么这个Presenter就可以理解为ViewModel了，这时候Model层也应该得抽象出一套业务逻辑接口。 总结在Android Studio上选择一个模板创建起一个应用（Google提供了挺多流行的界面框架选择），从MainActivity上开始一步步运用上面所写的各项知识点，例如使用MVP设计App的框架、读取资源显示到UI上、布局自己的界面、根据需求安插各式各样的控件、用列表展示出设计好的模型数据等等，再结合自己的业务Idea，搭建出属于你的Android App吧。 但还有以下一些我未用到、上面也没详细介绍的功能，日后有机会再补充补充 ContentProvider BroadcastReceiver JNI NDK（映射等） 参考AndroidManifest.xml详解 View与ViewGroup的概念 Adapter基础讲解 Android Adapter:ArrayAdapter篇 浅析 MVP 中 model 层设计 Android MVP 实例 谈谈我理解的Android应用架构 Android 多线程：手把手教你使用AsyncTask Handler的使用方式和注意事项 Handler机制的实现与工作原理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MVP</tag>
        <tag>Adapter</tag>
        <tag>Activity</tag>
        <tag>Fragment</tag>
        <tag>Layout</tag>
        <tag>Res</tag>
        <tag>Realm</tag>
        <tag>AIDL</tag>
        <tag>AsyncTask</tag>
        <tag>Thread</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android技巧入门]]></title>
    <url>%2Funcategorized%2FAndroid%E6%8A%80%E5%B7%A7%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[常用的adb指令查看连接的设备： adb devices无线连接设备： adb tcpip [port] adb connect [ip]:[port] adb disconnect [ip]:[port] # 当连接失效时，可尝试重启adb服务，或重定向端口（通过指定同一端口号重新激活） adb kill-server adb start-server adb forward tcp:[port] tcp:[port]安装包： adb install yourapk.apk # install可带参数： # -l：forward lock application # -r：replace existing application # -t：allow test packages # -s：install application on sdcard # -d：allow version code downgrade # -p：partial application install # 放置obb adb push main.BundleVersionCode.packagename.obb /mnt/sdcard/Android/obb/packagename/main.BundleVersionCode.packagename.obb # 放置证书 adb push charles-ssl-proxying-certificate.pem sdcard/charles.pem详细参考地址-ADB Shell 反编译Apk/Jar方法一：apktool使用apktool还可以对得到的反编译文件进行编译，重新生成apk # 解码（d: decode） apktool d xxx.apk # 带设定环境变量，控制系统分配资源的解码 java -server -Xms512M -Xmx512M -XX:ReservedCodeCacheSize=512m -jar /Path/to/apktool_2.4.0.jar d -f xxx.apk -o xxx_decode/ # 构建（b：build） apktool b files # 带设定环境变量，控制系统分配资源的解码 cd xxx_decode java -server -Xms512M -Xmx512M -XX:ReservedCodeCacheSize=512m -jar /Path/to/apktool_2.4.0.jar b . # 重签 jarsigner [options] jar-file alias # 常用方式（直接替换原文件） #-digestalg：SHA256（默认值）、SHA1 #-sigalg：MD5withRSA、SHA1withDSA、SHA256withRSA、SHA256withECDSA。默认值取决于private key的类型。 jarsigner -verbose -digestalg [SHA1] -keystore [/Path/to/app.keystore] -storepass [storepass] -keypass [keypass] [/Path/to/dist/resigned.apk/jar] [alias name] # 指定输出方式 jarsigner -digestalg [SHA1] -sigalg [MD5withRSA] -tsa -verbose -keystore [/Path/to/app.keystore] -signedjar [/Path/to/resigned.apk] [/Path/to/original.apk] [alias name] #生成签名(非必须) keytool -genkey -keystore [/Path/to/app.keystore] -keyalg RSA -validity 10000 -alias [alias name]详细参考地址-APKTOOL参考地址-jarsigner ps：如若重签后上传包时，谷歌提示apk没有经过Zipalign，则需要对apk做如下处理（zipalgn工具的路径在Android SDK路径下-可通过AS的SDK Manager查看） zipalign -v 4 from.apk to.apk方法二：jadxjadx是一个将Dex、Apk转Java代码的反编译工具。 有命令行和GUI两种使用方式。GUI上的使用比较简单，这里不做过多使用介绍。 参考地址-jadx 在MacOS下，使用原始办法打开jadx的GUI比较麻烦，有两种方式可以加强便捷性： 在Alfred的workflow中添加执行jadx-gui的脚本 在Automator上使用Applescript添加Service(下面截图介绍一下) 具体Applescript的代码： tell application &quot;Finder&quot; try set filename to POSIX path of (selection as text) set fileType to (do shell script &quot;sh /Users/milknero/Works/Tools/jadx-1.0.0/bin/jadx-gui &quot; &amp; filename) end try end tellAndroid Studio 快捷键 功能 快捷键 (操作类)删除光标所在行（选中行） Cmd + Y / Cmd + X (操作类)复制光标所在的行（选中行） Cmd + D (操作类)所在行换行 Cmd + Alt + Enter (操作类)格式化代码（java、xml） Cmd + Alt + L (操作类)上下移动选中的行 Cmd + Shift + Up / Down (操作类)大写/小写切换 Cmd + Shift + U (创建类)快速创建局部变量 Cmd + Alt + V (创建类)局部变量变为成员变量 Cmd + Alt + F (创建类)代码助手，自动补全 Ctrl [+ Alt] + 空格：属性名、类名或接口名提示 (创建类)方法提示 Ctrl + Shift + 空格 (创建类)导入包 Alt+回车:导入当前包 (创建类)导入重载方法 Cmd + O 输入方法名上下方向键选择后回车 (创建类)删除没用到的包 Ctrl + Alt + O (创建类)快速修复 Alt + Enter (创建类)复制类的全局路径（包名加类名） Cmd + Shift + Alt + C (右击–&gt; Copy Reference) (查看类)回到上一次编辑的位置 Cmd + Shift + Backspace (查看类)快速定位到任意的文件 按两次shift (查看类)快速定位到类或方法的定义 Cmd+B (查看类)快速定位方法在哪里被调用 Ctrl + Alt + H (查看类)搜索或替换 Cmd + F / Cmd + R (全局+Shift) (查看类)快速查看类继承结构 Ctrl + H (查看类)光标所在上一次或下一次的位置 Cmd + Alt + Left / Right (查看类)视窗的显示与隐藏 Alt + 视窗的数字标识 win下（mac下待确认） 功能 快捷键 快速定位到某一个类或文件 Cmd + N 查找文件 Cmd + Shift + N： 方法参数提示 Cmd + P 重命名 Shift + F6 快速定位到类中的方法或属性 Cmd + F12 打印输出 sout 快速定位到当前类报错或警告的地方 fn + F2 或 fn+Shift+F2 生成 get/set方法、构造方法、toString() alt + insert 设置自动导包 勾选：Add unambiguous imports on the fly 选中变量快速跳转到下一个 Alt + F3, F3 显示JavaDoc（注释文档） Ctrl + Q 更新 2019.9.23 使用apksigner.jar代替jarsigner更方便易用，免去了指定alias和摘要算法类型的参数，同时支持v1、v2两种签名方式。]]></content>
      <tags>
        <tag>AndroidStudio</tag>
        <tag>adb</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android原理入门]]></title>
    <url>%2FAndroid%2FAndroid%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JavaJava是一门基于JVM（Java Virtual Machine）编译的强类型语言，主要应用到Android和服务端的开发。 静态内部类和非静态内部类的区别在Java中我们可以有静态实例变量、静态方法、静态块。类也可以是静态的。Java允许我们在一个类里面定义静态类。比如内部类（nested class）。把nested class封闭起来的类叫外部类。在Java中，我们不能用static修饰顶级类（top level class），只有内部类可以为static。 内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。 非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。 一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。 final protected private修饰方法的区别 final是任何人都不能修改方法，包括子类的重写，但可以使用； protected是只有自己和子类可以使用，子类可重写，而外部其它类不知道该方法的存在； private是只有自己可以使用，子类以及外部其它类都不知道该方法的存在。 匿名内部类使用匿名内部类进行初始化：在new一个对象的时候，小括号前就是要实现的接口或要继承的父类，小括号后边跟一个大括号，大括号内就是该内部类的实现。 Person person = new Person(&quot;张三&quot;) &#123; @Override public String getName() &#123; return super.getName()+&quot;123&quot;; &#125; &#125;; class Person&#123; String name; public Person(String name)&#123; this.name = name; &#125; public String getName()&#123; return name; &#125; &#125; tv1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); public interface OnClickListener &#123; void onClick(View v); &#125; 接口是不可以实例化的，上面的OnClickListener可以new，是因为得益于匿名内部类。new OnClickListener(){}其实并没有真正地实例化该接口，而是new了一个实现该接口的匿名内部类。当然匿名内部类还可以选择继承父类而不是实现接口，那new该内部类时从外观上看也同样不要以为是在new父类的实例了。 AndroidAsyncTaskAsyncTask是一个系统轻量级的异步任务机制工具。 在Android中实现异步任务机制有两种方式，Handler和AsyncTask。 Handler模式需要为每一个任务创建一个新的线程，任务完成后通过Handler实例向UI线程发送消息，完成界面的更新，这种方式对于整个过程的控制比较精细，但也是有缺点的，例如代码相对臃肿，在多个任务同时执行时，不易对线程进行精确的控制。 为了简化操作，Android1.5提供了工具类android.os.AsyncTask，它使创建异步任务变得更加简单，不再需要编写任务线程和Handler实例即可完成相同的任务。AsyncTask中的三种泛型类型分别代表“启动任务执行的输入参数”、“后台任务执行的进度”、“后台计算结果的类型”。在特定场合下，并不是所有类型都被使用，如果没有被使用，可以用java.lang.Void类型代替。 执行步骤： execute(Params… params)，执行一个异步任务，需要我们在代码中调用此方法，触发异步任务的执行。 onPreExecute()，在execute(Params… params)被调用后立即执行，一般用来在执行后台任务前对UI做一些标记。 doInBackground(Params… params)，在onPreExecute()完成后立即执行，用于执行较为费时的操作，此方法将接收输入参数和返回计算结果。在执行过程中可以调用publishProgress(Progress… values)来更新进度信息。 onProgressUpdate(Progress… values)，在调用publishProgress(Progress… values)时，此方法被执行，直接将进度信息更新到UI组件上。 onPostExecute(Result result)，当后台操作结束时，此方法将会被调用，计算结果将做为参数传递到此方法中，直接将结果显示到UI组件上。 注意点：有几点需要格外注意： 异步任务的实例必须在UI线程中创建。 execute(Params… params)方法必须在UI线程中调用。 不要手动调用onPreExecute()，doInBackground(Params… params)，onProgressUpdate(Progress… values)，onPostExecute(Result result)这几个方法。 不能在doInBackground(Params… params)中更改UI组件的信息。 一个任务实例只能执行一次，如果执行第二次将会抛出异常。 概括来说，当我们调用execute(Params… params)方法后，execute方法会调用onPreExecute()方法，然后由ThreadPoolExecutor实例sExecutor执行一个FutureTask任务，这个过程中doInBackground(Params… params)将被调用，如果被开发者覆写的doInBackground(Params… params)方法中调用了publishProgress(Progress… values)方法，则通过InternalHandler实例sHandler发送一条MESSAGE_POST_PROGRESS消息，更新进度，sHandler处理消息时onProgressUpdate(Progress… values)方法将被调用；如果遇到异常，则发送一条MESSAGE_POST_CANCEL的消息，取消任务，sHandler处理消息时onCancelled()方法将被调用；如果执行成功，则发送一条MESSAGE_POST_RESULT的消息，显示结果，sHandler处理消息时onPostExecute(Result result)方法被调用。 延伸：理论上通过execute启动AsyncTask任务这种方式可以创建无数个task，并且所有的task是串行执行的。 AsyncTask.THREAD_POOL_EXECUTOR是AsyncTask默认帮我们配置的Executor，它的配置是核心线程数为CPU核个数+1，最大线程数是2倍的CPU核个数+1，任务排队队列大小为128，假设手机CPU核的个数为8，在核心线程数为9，最大线程数为17，则最大的任务数为128+17，超过这个数量就会抛出RejectedExecutionException。在排队队列未满之前，最多有9个线程在运行，当排队队列满了之后，最多有17个线程在运行。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链接、装载、库]]></title>
    <url>%2F%E7%B3%BB%E7%BB%9F%2F%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E3%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[介绍此文和中心包括两部分：第一是占篇幅最多的编译、链接、加载等，这些相对底层的系统机制和运行原理；第二是穿插于第一点内容之中，对应于各步骤的操作或分析命令，以及最后的汇编语言入门讲解。 通过了解这些系统底层的原理及知识，能让我们更好更快地排查程序构建或运行时的问题，又或者帮助我们进行程序逆向或代码安全防护的分析研究。 一点点耐心地积累，不要过早就忌怕自己无法驾驭枯燥的知识，打退堂鼓。 计算机硬件框架北桥（PCI bridge）：负责协调CPU、内存和高速的图形设备高速地交换数据；南桥（ISA bridge）：负责连接低速设备，如磁盘、USB、键盘、鼠标等I/O，使其与北桥连接分离；系统总线（System BUS）：由于CPU与内存、I/O的频率相差太大，需要一个隔离它们的通信连接；（像PCI总线和ISA总线，其实都是为了分离不同速率的设备，并适配它们间的通信） 【图】计算机硬件结构框架图 系统软件可分为两类 平台性的，如操作系统内核、驱动程序、运行库、系统工具； 程序开发的，如编译器、汇编器、链接器等开发工具和开发库； 【图】软件体系结构图 CPU 分时系统（Time-Sharing System）：每个程序运行一段时间后都主动让出CPU给其它程序，使得一段时间内每个程序都有机会运行一小段时间。缺点是如果一个程序霸占着CPU不放（例如while(1) ），其它程序也就只能等着，系统也没法处理。 多任务系统（Multi-tasking System）：CPU由操作系统统一进行分配，每个进程根据进程优先级的高低都有机会得到CPU，但如果运行时间超出一定时间，操作系统会暂停该进程，将CPU资源分配给其它等待运行的进程（此为抢占式分配-Preemptive）。因为CPU在进程间的切换非常快速，所以人们感觉很多进程都是在同时运行的假象。 进程（Process）：所有应用程序都以进程方式运行在比操作系统权限更低的级别，每个进程都有自己独立的地址空间，使得进程之间的地址空间相互隔离。 硬件 硬盘：存储单位为扇区（Sector），一个扇区有512字节，一磁道有1024个扇区，一盘面有65536个磁道，一个盘片有2个盘面，一个硬盘有n个盘片。总容量为n * 2 * 65536 * 1024 * 512。扇区一般不按硬件细节描述编号，而采用逻辑扇区号（LBA Logic Block Address）从0开始编排，由电子设备在内部为我们转为盘面、磁道这些实际的位置。 I/O端口：x86上有65536个硬件端口寄存器，CPU提供了指令in和out实现对硬件端口的读和写。对硬盘的IDE接口，有IDE0和IDE1两个通道，每个通道可连接2个设备（Master和Slave），IDE通道的端口地址为端口寄存器中间的4个字节，最前1个字节为读取的扇区数，最后1个字节为操作命令码。 内存： 程序给出的地址都是一种虚拟地址（Virtual Address），通过映射的方法将虚拟地址转换为实际的物理地址。 地址空间，可以这样解释它的作用，想象成一个巨大的数组，每个元素为一个字节，而这个数组的大小就是由地址空间的地址长度决定的，比如32位（即CPU有32条地址线）的地址空间下，这个数组大小为2的32次方个（字节），即4294967296字节=4GB，16进制表示为0x00000000~0xFFFFFFFF。 分段（Segmentation）：将程序需要的内存空间大小的虚拟空间映射到某个地址空间，这样可达到地址隔离（由系统映射函数中判断是否越过程序内存区的访问）和地址是确定而无需在每次运行时都重定位，但单单这样内存的使用效率还是过低（在内存供给不足时数据换入换出的情况下）。 分页（Paging）：将地址空间等分成固定大小的页，每一页的大小由硬件或系统决定。每一页就是内存中的存储单位（有点类似硬盘的扇区概念）。系统会把常用的数据和代码页装载到内存，不常用的代码和数据保存到磁盘里，需要用到的时候，硬件会捕获页错误（Page Fault）消息，由操作系统接管进程，负责将磁盘的数据页（磁盘页，DP）从磁盘中读出来并装入内存变为物理页（PP），然后让其与虚拟页（VP）建立映射关系。 页映射：虚拟存储依靠硬件支持，硬件采用MMU（Memory Management Unit，一般集成在CPU）部件进行映射，将CPU需访问的虚拟地址（即我们在程序中看到的地址）转换为内存的实际物理地址。 线程： 组成：独立的 线程ID、当前指令指针（PC）、寄存器集合、堆栈。（多核CPU下）多个线程组成一个进程。 共享：程序的内存空间，包括代码段、数据段、堆等。 私有：局部变量、函数参数、线程局部存储（Thread Local Storage，TLS）数据。 执行：线程数少于等于处理器数时是真并发，否则操作系统会让运行多个线程的处理器轮流执行这些线程，这时就需要线程调度（Thread Schedule）进行线程切换，一般采用采用轮转法（Round Robin），那线程就会拥有三个状态：运行（Running）、就绪（Ready）、等待（Waiting）： 当时间片用尽时，线程将进入就绪状态，如果时间片用尽前线程就开始等待某事件则进入等待状态； 当线程离开运行状态（无论就绪还是等待），调度系统会选择一个其它就绪的线程执行； 等待状态的线程所等待的事件发生后，该线程就进入就绪状态 优先级（Priority）：线程都拥有各自的线程优先级，具有高优先级的线程会更早地执行，而低优先级的线程常要等待到系统中已经没有高优先级的可执行的线程存在时才能执行。I/O密集型线程（I/O Bound Thread）比CPU密集型线程（CPU Bound Thread）更容易得到优先级的提升（因其频繁进入等待而释放CPU）。改变优先级： 用户指定； 根据进入等待状态的频繁程度提升或降低优先级； 长时间得不到执行而被提升优先级，避免因存在高优先级的CPU密集型线程导致的饿死（Starvation）。 安全：程序代码编译为汇编代码之后，原本一行的代码指令可能由不止一条汇编指令组成，因此在执行了一半被调度系统打断去执行别的代码后，从而使结果可能出现意想不到的结果。所以需要一些措施避免这种被打断导致的出错： 原子性（Atomic）：意为单指令完成的操作； 同步锁（Synchrominzation Lock）：同步指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问；锁则是同步的一种方法，非强制使用，当每一个线程在访问数据或资源前先试图获取锁，并在访问结束后释放锁，在锁已经被占用的时候试图获取锁时线程会等待（进入等待状态），直到锁重新可用（进入运行状态）。类型有： 二元信号量（Binary Semaphore） 多元信号量（Semaphore）：获取信号量时信号量减1，信号量少于0则进入等待状态，释放信号量时信号量加1，信号量少于1则唤醒一个等待中的线程。 互斥量（Mutex）：和Semaphore相似，但只能哪个线程获取的就哪个线程负责释放； 临界区（Critical Section）：和Mutex相似，但更进一步严格，作用范围局限到本进程内； 读写锁 条件变量 防止过度优化：由于编译器可能会为提高访问速度、执行效率，对寄存器、指令等的操作进行干预，使用关键字volatile可以试图阻止过度优化，解决： 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回； 阻止编译器调整操作volatile变量的指令顺序；（但CPU动态调度换序还可能存在，可再通过CPU提供的barrier指令，如lwsync，来做一个阻止指令被调度交换的分水岭） 用户态：内核中的一个线程，有可能对应一个或多个用户态的线程。 在1对1模型下线程之间是真正的并发，一个线程阻塞时其它线程不受影响。但用户的线程数量会受到限制（最多只能等同于CPU数）。 多对1模型下，显而易见的是一个线程阻塞会导致该内核中的其它用户态线程阻塞。但它具有高效的上下文切换和无限制的线程数。 多对多模型 静态链接编译和链接GCC编译过程 = 预处理（Prepressing） + 编译（Compilation） + 汇编（Assembly） + 链接（Linking） 【图】GCC编译过程分解图 编译器就是将高级语言翻译成机器语言的一个工具 【图】编译过程图 预编译主要处理源代码文件中以“#”开始的预编译指令，比如#include、#define、#if、#ifdef等。 处理的文件包括.c 和 .h文件。（如果是其它基于C扩展的语言 的编译器，可能还会处理.m .mm等文件），生成.i文件。 #-E表示只进行预编译 $gcc -E hello.c -o hello.i 处理步骤： 删除#define，并展开宏定义 处理条件预编译指令 处理导入预编译指令，将被包含的文件递归插入到该预编译指令的位置 删除注释 添加行号和文件名标识，比如 #2 “hello.c” 2（便于调试） 保留编译器需要的#pragma编译指令 编译进行一系列词法分析、语法分析、语义分析、优化后产生相应的汇编代码文件。 $gcc -S hello.i -o hello.s 词法分析：源代码被输入到扫描器（Scanner），用有限状态机（Finite State Machine）将源代码的字符分割成一系列记号（Token），如关键字（系统定义）、标识符（变量名）、字面量（数字、字符串）、特殊符号（加号、等号、括号）。标识符放入到符号表，数字字符串放入到文字表。lex工具程序可以帮助完成此项工作。 语法分析：由语法分析器（Grammar Parser），采用上下文无关语法（Context-free Grammar）的分析手段，对记号进行分析从而产生语法树（Syntax Tree）。语法树就是以表达式为节点的树。yacc工具程序可以帮助完成此项工作。 语义分析：由语义分析器（Semantic Analyzer）完成对表达式的语法层面分析，分为静态语义和动态语义： 静态语义包括声明和类型的匹配、类型的转换（一般是隐含性的） 动态语义指运行时期出现的语义相关问题（比如0作为除数） 最后整个语法树的表达式都被标识了类型（如需做隐式转换，语义分析程序会在语法树种插入相应的转换节点） 中间语言生成： 中间代码（Intermediate Code）：源码级优化器（Source Code Optimizer）对在编译期可被确定值的表达式等的情况进行优化，将整个语法树转换成中间代码，其实就是语法树经优化后的顺序表示。 内容：跟目标机器和运行时环境无关，像不包含数据的尺寸、变量地址、寄存器名等。而代码的形式类型一般常见的有三址码、P代码。 意义：使得编译器可以被分为前端和后端，前端负责产生机器无关的中间代码，后端负责将中间码转换为目标机器码。（有开发者通过修改编译器或增加插件实现了对IR层代码的混淆，比混淆源码或机器码来得简单方便） 汇编将汇编代码转变成机器可执行的指令，每一个汇编语句几乎都对应一条机器指令，生成目标文件（Object File）.o 或 .obj。 $as hello.s -o hello.o $gcc -c hello.s -o hello.o $gcc -c hello.c -o hello.o 代码生成器（Code Generator）和目标代码优化器（Target Code Optimizer）依据不同的字长、寄存器、整数数据类型、浮点数数据类型等工作，将中间码生成用汇编语言表示的目标指令代码，然后进行机器代码级别的优化，最后生成目标文件。 链接处理.o文件和库.a（库是加了索引的一组目标文件的包），最终生成.out文件 $ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend.o crtn.o 重定位（Relocation）：重新计算各个目标地址的过程 汇编语言的符号（Symbol）：使用符号和标记，如jmp代表一条8位（1字节）指令的高四位的含义，如divide代表一个程序的起始位置。 模块： 为方便开发、编译、测试、重用、阅读、理解，每个类是一个基本的模块，若干个类模块组成一个包，若干个包组成一个程序。模块间以符号引用来通信。 每个模块都是单独编译的，它会暂时把不知道地址的函数或变量的目标地址搁置（置0），等到最后链接时由链接器去修正这些指令的目标地址。每个要被修正的地方叫一个重定位入口（Relocation Entry）。 链接：负责将模块拼接起来，把各个模块之间的相互引用的部分都处理好，能正确地衔接（其实就是把一些指令对其它符号地址的引用加以修正），产生可执行的程序。 地址和空间分配（Address and Storage Allocation） 符号决议（Symbol Resolution），又叫符号绑定、名称绑定。 重定位 目标文件的格式目标文件：源代码编译后但未进行链接的中间文件（是编译后的可执行文件格式，只是还没经过链接过程，可能有些富豪或地址还没被调整）。 基于COFF（Common file format）的可执行文件格式： Windows：PE（Portable Executable） 目标文件：.obj 动态链接库(DLL,Dynamic Linking Library)：.dll 静态链接库(Static Linking Library)：.lib Linux：ELF（Executable Linkable Format） 目标文件：.o 动态链接库：.so 静态链接库：.a 静态链接库是把很多目标文件加上索引后捆绑在一起形成的一个文件包。 文件归类： 可重定位文件：包含代码和数据，可被用来链接成可执行文件或共享目标文件（如.o .a .obj .lib） 可执行文件：包可直接执行的程序，没有扩展名（如bin/bash .exe） 共享目标文件（.so .dll）： 连接器将其与其他可重定位文件和共享目标文件链接，产生新的目标文件 动态链接器将n个共享目标文件与可执行文件结合，作为进程映像的一部分来运行 核心转储文件（core dump） 查看文件格式的指令 $ file foobar.o 目标文件的结构分段分段的好处： 数据与指令分别映射到两个虚存区域，防止指令地址被改写； 分离数据缓存和指令缓存，提高CPU缓存命中率； 运行多个程序副本时，共享指令（数据区域则是进程私有） 文件头：描述整个文件的属性，比如是否可执行、是否静态链接还动态链接、入口地址、目标硬件、目标操作系统、段表等。段表：描述文件中各个段的数组。 存储单位：段/节（Section），系统保留的段采用“.”作为前缀，因为可以拥有同名段，所以自定义的段不能使用“.”作为前缀，避免与系统段冲突。 代码段：存放程序源代码编译后的机器指令（常用段名为.code .text） 数据段：存放已经初始化过的全局变量和局部静态变量数据（常用段名为.data） .bss段：存放未初始化的全局变量和局部静态变量，提供预留位置 .rodata段：存放只读数据（const和字符串常量，有时名为.rodata1） .debug段：调试信息 .line段：调试时段行号表 .note段：额外的编译器信息 .comment段：编译器版本信息 .dynamic段：动态链接信息 .hash段：符号哈希表 .strtab段：字符串表，存储ELF文件中用到的各种字符串 .symtab段：符号表 .shstrtab段：段名表 .plt .got：动态链接的跳转表和全局入口表 .init .fini：程序初始化与终结代码段 自定义段：示例 __attribute((section(&quot;FOO&quot;))) int global = 42; __attribute((section(&quot;BAR&quot;))) void foo() &#123;&#125; 地址顺序：文件头开始于0x00000000，往上叠加，每段的起始地址为自身偏移（File offset，段偏移为累计已叠加段的长度总和+文件头长度），通过以下指令查看文件结构信息： $ gcc -c xx.c #编译文件，-c只编译不链接 $ objdump -h xx.o #查看object文件内容，-h打印各段基本信息，-x可打印更多信息 $ objdump -s -d xx.o #-s以十六制形式打印，-d将指令段反汇编 $ size xx.o #查看ELF文件各段长度 还可以将媒体文件作为一个段 $objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o $objdump -ht image.o 文件头文件头信息对应文件头结构Elf32_Ehdr关系： ELF魔数（Magic）：属e_ident字段 文件机器字节长度(Class)：属e_ident字段，但从Magic中获取 数据存储方式(Data)：属e_ident字段，但从Magic中获取 版本(Version)：属e_ident字段，但从Magic中获取 运行平台(OS/ABI)：属e_ident字段，但从Magic中获取 ABI版本(ABI Version)：属e_ident字段，但从Magic中获取 ELF重定位类型(Type)：属e_type，ELF文件类型（1-ET_REL可重定位文件.o,2-ET_EXEC可执行文件,3-ET_DYN共享目标文件.so） 硬件平台(Machine)：属e_machine，CPU的平台属性 硬件平台版本(Version)：属e_version，一般为常数1 入口地址(Entry point address)：属e_entry，规定ELF程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令（可重定位文件一般没有入口地址，则此值为0） 程序头入口和长度(Start of program headers)：属e_phoff 段表的位置和长度(Start of section headers)：属e_shoff，段表在文件中的偏移 段数量：属e_shnum (FLAGS)：e_word，ELF标志位，标识一些EFL文件平台相关的属性 ：e_ehsize，文件头本身大小 ：e_phentsize，程序头描述符大学 ：e_phnum，程序头描述符数量 ：e_shentsize，段表描述符大小 ：e_shstrndex，段表字符串表所在的段在段表中的下标 查看头文件信息指令为 $ readelf -h SimpleSection.o #-h表示只显示 段表（Section Header Table）用于保存ELF文件中各种段的基本属性，比如每个段的段名、段的长度、在文件中的偏移、读写权限、等等其他属性。是以Elf32_Shdr结构体（称为段描述符，Section Descriptor）为元素的数组，结构体成员如下： sh_name：段名，位于”.shstrtab“的字符串表中，sh_name是段名字符串在”.shstrtab“中的偏移； sh_type：段类型，常量以SHT_开头，包括程序段、字符串表、符号表、重定位表、哈希表、动态链接信息、提示性信息、没内容、重定位信息、保留、动态链接符号表、无效； sh_flags：段标志位，表示段在进程虚拟地址空间中的属性，比如可写、须分配空间、可执行； sh_addr：段虚拟地址，如果段可被加载时，sh_addr为该段被加载后在进程地址空间中的虚拟地址，否则为0； sh_offset：段偏移，如果段存在于文静中，则表示该段在文件中的偏移，否则无意义； sh_size：段长度； sh_link：段链接信息，取决于sh_type SHT_DYNAMIC：该段所使用的字符串表在段表中的下标 SHT_HASH：该段所使用的符号表在段表中的下标 SHT_REL：该段所使用的相应符号表在段表中的下标 SHT_RELA：同上 SHT_SYMTAB：操作系统相关 SHT_DYNSYM：同上 other：SHN_UNDEF sh_info：同上； sh_addralign：段地址对齐，表示地址对齐数量中的指数，使sh_addr%(2**sh_addralign)=0，若为1或0则段没有对齐要求； sh_entsize：项的长度，当段包含固定大小的项时，其表示每个项的大小； 查看完整的ELF文件的段的指令为 readelf -S SimpleSection.o 重定位表 对于每个须要重定位的代码段或数据段，即是当段中有绝对地址引用时，就都会有一个相应的重定位表，比如.rel.text就是针对.text的重定位表。 一个重定位表就是独立一个段，它的sh_link就表示符号表的下标，sh_info表示它作用于哪个段 字符串表 段名、变量名等，把字符串集中起来存放到一个表，然后用字符串在表中的偏移来引用字符串，使用偏移时实质也是引用字符串表中的下标。 字符串表以段形式保存，一般为.strtab字符串表（普通字符串）或者.shstrtab段表字符串表（段表中的字符串，如段名）。 Elf32_Ehdr最后一个成员e_shstrndx代表段表字符串.shstrtab在段表中的下标。 符号表链接过程的本质就是把多个不同的目标文件之间互相”粘“到一起，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量地址的引用，而在链接中，我们将函数和变量统称为符号（Symbol），函数名和变量名就是符号名，符号值就是他们的地址。 一般是名为“.symtab”的段，每个元素是一个Elf32_Sym结构体: st_name：符号名，这个成员包含了该符号名在字符串表中的下标 st_value：符号值，非COMMON块符号是在通过st_shndx确定符号所在段后，将在该段中的偏移地址设置为符号值，而COMMON块符号是将符号的对齐属性设置为符号值，可执行文件下符号值则直接是符号的虚拟地址。 st_size：符号大小 st_info：符号类型及绑定信息，低4位表示类型，高4位表示符号绑定信息 STB_LOCAL：绑定信息-局部符号，目标文件外不可见 STB_GLOBAL：绑定信息-全局符号，外部可见 STB_WEAK：绑定信息-弱引用 STT_NOTYPE：表示未知类型 STT_OBJECT：表示数据对象，如变量、数组等 STT_FUNC：表示函数或其他可执行代码 STT_SECTION：表示一个段 STT_FILE：文件名，一般是该目标文件所对应的源文件名，所以一定是和STB_LOCAL搭配，st_shndx一定是SHN_ABS st_other：预留 st_shndx：符号所在的段，如果该符号定义在目标文件内，那么就表示符号所在段在段表的下标，否则有3种类型表示： SHN_ABS：符号包含了一绝对值 SHN_COMMON：符号是一个COMMON块，例如未初始化的全局变量符号 SHN_UNDEF：0，符号未定义，在本目标文件中引用到，但定义在其他目标文件中 特殊符号 __executable_start：程序起始地址（不是入口地址） __etext：代码段结束、末尾的地址 _edata：数据段结束地址 _end：程序结束地址 引用示例：extern char executable_start[];print(“%X”,executable_start); 符号修饰和函数签名为了防止符号名冲突： 添加前后缀 UNIX下的C语言，全局变量和函数在经过编译后，符号名前加下划线“_”，例如函数_foo（Linux下的GCC已不采用）； Fortran语言，编译后所有符号名前加“_”，后面也加“_”，例如函数_foo_； 增加命名空间（Namespace） 符号修饰（Name Decoration） 函数签名（Function Signature），包含函数名、参数类型、所在类、命名空间等其它信息。 名称修饰法，在编译成目标文件时，函数名和变量名会被修饰而形成符号： GCC的C++名称修饰方法： 所有符号都以“_Z”开头 后面紧跟“N” 然后是各命名空间和类的名字字符串长度和该名字，如1N2AB 最后以“E”结尾 再加参数列表，如int即是i 示例（GCC）： 函数 int N::C::func(int) 修饰后为 _ZN1N1C4funcEi； foo中的全局变量bar修饰后为_ZN3foo3barE； func函数中的静态变量skr修饰后为_ZZ4funcE3skr，若多个函数内有相同的静态变量名，则在“E”前多加字符区分，比如多加一个“v”成_ZZ4mainvE3skr； 可使用binutils中的c++filt工具对被修饰过的名称进行解析。 Visual的C++名称修饰发 “?”开头 函数名，“@”结尾 类名，“@”结尾 命名空间，“@”结尾 调用类型，A表示__cdecl 参数类型及返回值 示例：函数 int N::C::func(int) 修饰后为 ?func@C@N@@AAEHH@Z； extern “C”： C++编译器会将在extern “C”的大括号内部或其同行后声明的代码当做C语言代码处理，这样C++的名称修饰机制就不会起作用。 通过这个方法，可以手动获取到修饰名字后的变量。 C++编译器中提供了一个宏“__cplusplus”来避免C编译器不支持extern “C”的情况。 强符号和弱符号 强符号（Strong Symbol），对于函数和初始化了的全局变量，编译器默认为强符号，当定义的两个强符号，例如两个全局变量都初始化了值，且名字一样的时候，编译就会报错。 弱符号（Weak Symbol），未初始化的全局变量为弱符号，可以通过__attribute__((weak))来定义任何一个强符号为弱符号。外部变量的引用是非强也非弱，例如 extern int ext。 规则 不允许强符号被多次定义； 若一个符号在某目标文件中是强符号，在其他文件是弱符号，那么选择强符号； 若一个符号在所有目标文件都是弱符号，那么选择其中占用空间最大的一个； 强引用和弱引用 强引用，若没找到符号的定义，编译器因无法决议符号的引用而会报错； 弱引用，若符号有定义，则编译器将该符号的引用决议，否则编译器对于该引用也不报错，例如__attribute__ ((weakref)) void foo(); 主要都是用于库链接的过程。库中定义的弱符号可以被用户的强符号所覆盖，从而使得程序可以使用自定义版本的库函数。可以声明一个弱引用函数，利用其判断该函数是否存在可使用而不会编译报错，就可以插拔含此函数的库或更换库版本。 调试信息GCC编译时加上“-g”参数，可在目标文件中加上调试信息，会发现目标文件中多了很多debug相关的段。 ELF文件采用DWARF（Debug With Arbitrary Record Format）的调试信息标准格式，而Windows上采用CodeView标准。 调试信息在目标文件和可执行文件上占很大空间，比代码和数据会大几倍，所以产品发布时都须要把调试信息去掉，节省空间，就是我们常说的release版本。 去掉ELF文件中的调试信息命令 $strip foo空间与地址分配对于链接器，整个链接过程中，就是将几个输入目标文件加工后合并成一个输出文件。 因为每个段都须要有一定的地址和空间对齐要求，如果按序叠加段，就会造成内存空间大量的内部碎片。 所以一般采取相似段合并，使用两步链接（Two-pass Linking）的方法： 空间与地址分配：收录起各段信息（更新段表的信息）和符号（放入全局符号表） 符号解析与重定位：利用上面的信息进行符号解析和重定位。 也就是说，链接器为目标文件分配地址和空间就包含两个意思： 输出的可执行文件中的空间（合并段后确定）； 装载后的虚拟地址中的虚拟地址空间（重链接后确定）； 链接的指令： #-e main表示将main函数作为程序入口，因为ld链接器默认以_start为入口 #-o ab表示链接输出文件名为ab，默认为a.out $ld a.o b.o -e main -o ab 【图】可执行文件与进程空间 因为合并目标文件后，各个符号在段内的相对位置固定了，所以链接器就可以开始计算各个符号真正的虚拟地址，给每个符号加上一个偏移量。 而虚拟空间从0开始分配，是因为操作系统的进程虚拟地址空间的分配规则，每个进程的ELF可执行文件默认都从地址0x8048000开始分配，由系统内核管理着每个进程虚拟内存和机器的物理RAM它们之间的映射，所以每个进程的起始物理地址是不同的。 符号解析与重定位重定位$objdump -d a.o #-d查看代码的反汇编结果 在没链接之前，不知道变量或函数的地址时，目标文件会以两种形式临时设定一些临时地址： 绝对寻址，例如对于一条传输指令的源为一个立即数时，该被传输的变量则采用绝对寻址，寻址修正后的地址为该符号的实际地址； 相对寻址，对于不同的指令（jmp、call、mov等等），寻址的方式都千差万别，例如近址相对位移调用指令，即是一行指令中，除去指令码外，最后面的4字节32位就是被调用函数的相对于调用指令的下一条指令的偏移量，一般以（小端）补码形式表示函数的地址，寻址修正后的地址为符号举例被修正位置的地址差。 链接后，会从定义变量的地方重定位出此前未定位变量在代码中的虚拟地址，也会从调用未定位函数的指令相邻的下一条指令的虚拟地址，加上偏移量反推出该函数的虚拟地址。 $objdump -r a.o #-r查看重定位表 比如.text一般对应.rel.text重定位表。每个要被重定位的地方叫重定位入口（Relocation Entry），重定位表结构如下： r_offset，重定位入口的偏移 可重定位文件中，是（该重定位入口要修正的位置的第一个字节）相对段起始的偏移； 可执行文件或共享对象文件，是（该重定位入口要修正的位置的第一个字节的）虚拟地址； r_info，高24位表示重定位入口的符号在符号表中的下标，低8位表示重定位入口的类型 符号解析每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。 每个重定位的入口都是对一个符号的引用。 连接器对某个符号的引用进行重定位时，就会去查找由所有输入目标文件的符号表组成的全局符号表，确定符号的地址。 COMMON块事先声明需要的临时使用空间的大小。 在链接时，当不同的目标文件需要的COMMON块空间大小不一致时，以最大的那块为准，而且只针对弱符号，因为如果有其中一个是强符号，那么最终输出结果中的符号所占用空间就与强符号相同了。 弱符号大于强符号时就会链接报错。 以下方式允许我们把所有未初始化的全局变量不以COMMON块的形式处理，即是当一个未初始化的全局变量不是以COMMON块的形式存在，那就相当于一个强符号： $gcc -fno-common ini global __attribute__((nocommon)); ABI（Application Binary Interface）符号修饰标准、变量内存布局、函数调用方式等跟可执行代码二进制兼容性相关的内容。 静态库链接静态库可简单看成一组目标文件的集合。 根据是否支持多线程和调试的功能，C运行库可区分为多个版本。 以下指令可查看静态库包含了哪些目标文件： $ar -t libc.a 查找函数所在的目标文件： $objdump -t libc.a 关闭内置函数优化选项（避免GCC为提高运行速度替换函数）： $gcc -c -fno-builtin hello.c 解压目标文件到当前目录： $ar -x libc.a 与静态库链接，ld链接器会自动寻找所有需要的符号及它们所在的目标文件，将这些目标文件从静态库中解压出来，然后链接在一起成为一个可执行文件。 编译链接过程详情： $gcc -static --verbose -fno-builtin hello.c ... /usr/lib/gcc/i486-linux-gnu/4.1.3/cc1 -quiet -v hello.o -quiet -dumpbase hello.c -mtune=generic -auxbase hello -version -fno-builtin -fstack-protector -fstack-protector -o /tmp/ccUhtGSB.s ... as --traditional-format -V -Qy -o /tmp/ccQZRPL5.o /tmp/ccUhtGSB.s ... /usr/lib/gcc/i486-linux-gnu/4.1.3/collect2 -m elf_i386 --hash-style=both -static crt1.o crti.o crtbeginT.o -L/lib /tmp/ccQZRPL5.o --start-group -lgcc -lgcc_eh -lc --end-group crtend.o crtn.o cc1是GCC的C编译器，编译出临时的汇编文件.s； as是GNU的汇编器，将临时汇编文件汇编成目标文件.o； collect2是ld连接器的一个包装，其先调用ld完成目标文件的链接，然后对链接结果做收集所有与程序初始化有关的信息并构造初始化的结构的处理 将函数尽量独立开存放到不同的目标文件，可以尽量减少空间的浪费，这样没有被用到目标文件（函数）就不要链接到最终输出文件。 链接过程控制链接过程需要确认的内容： 使用哪些目标文件 使用哪些库文件 是否在最终可执行文件中保留调试信息 输出文件格式，是可执行文件还是动态链接库 是否要导出符号供调试使用 控制链接有3种方式：链接器在命令行的参数、链接指令内置于目标文件、链接脚本。 查看ld默认的链接脚本（路径：/usr/lib/ldscripts）： $ld -verbose 自定义链接脚本： $ld -T link.script 内嵌汇编： asm(&quot;movl $42, %ebx \n\t&quot; &quot;movl $1, %eax \n\t&quot; &quot;int $0x80 \n\t&quot; ); int是中断指令，通过0x80实现系统调用，根据eax中的系统调用号选择中断类型。 在main()函数结束后控制权会返回给系统库，由系统库负责调用EXIT，EXIT是一种系统调用，其调用号为1。 控制链接的过程无非就是控制输入段（输入文件中的段）如何变成输出段（输出文件中的段），比如哪些输入段要合并一个输出段，哪些输入段要丢弃。指定输出段的名字、装载地址、属性等。 链接脚本示例： ENTRY(nomain) SECTIONS &#123; .=0x0804800 + SIZEOF_HEADERS; tinytext : &#123; *(.text) *(.data) *(.rodata) &#125; /DISCARD/: &#123; *(.comment) &#125; &#125; ENTRY(symbol)指定程序入口函数，对应ld指令的-e选项，使用优先级：-e&gt;entry&gt;_start&gt;.text第一个字节&gt;0 SECTIONS {}的是指定各输入段到输出段的变换指令 大括号内的则是变换规则 .=表示当前虚拟地址的赋值，下一个规则处中的段则以此地址起始； xx : { *(.xx) *(.yy)}大括号中的段依次合并到输出文件tinytext(xx)中，*表示通配输入文件，可采用正则； /DISCARD/ : { *(.zz) }丢弃段 其它 STARTUP(filename)指定文件filename为第一个输入文件； SEARCH_DIR(path)指定路径path加入到链接器的库查找目录，对应-Lpath命令； INPUT(file,file,...)指定输入文件 INCLUDE filename包含指定文件进链接脚本 PROVIDE(symbol)在链接脚本定义某个符号 ld可通过-s参数禁止链接器产生符号表，或使用strip命令去除。对可执行文件来说，符号表和字符串表示可选的，但段名字符串表则是必须的。 BFD库因为硬软件平台种类繁多，固产生了BFD库（Binary File Description library）来统一处理不同的目标文件格式，它是binutils的一个子项目。 BFD把目标文件抽象成一个统一的模型。 GCC、GNU、ld、GDB、binutils都通过BFD库来处理目标文件，而非直接处理。 装载与动态链接进程虚拟地址空间每个程序被运行后，都将拥有自己独立的虚拟地址空间（Virtual Address Space），其大小由计算机的硬件平台决定（CPU的位数决定）。 32位的硬件平台，虚拟空间的地址为0-2^32-1，即0x00000000~0xFFFFFFFF，4GB大小，4字节长度（位数，每两位16进制为1字节长度）； 64位寻址能力的平台则有达2^64字节，即17179869184GB的大小。 C语言指针大小的位数与虚拟空间的位数相同，32位平台的指针为32位，即4字节；64位平台的指针为64位，即8字节。 进程只能使用操作系统分配给进程的地址，如果访问未经允许的空间，那么操作系统就会捕获到这些访问，将进程的这种访问当作非法操作，强制结束进程。 【图】进程虚拟空间分布 所有代码、数据包括通过C语言malloc()等方法申请的虚拟空间之和是不能超过3GB，而且还有一部分其实是预留给其它用途，并不能全占用该3GB。 在扩展的36位地址线下，Intel修改了页映射方式，使得新的映射方式可以访问到更多的物理内存，此方式叫PAE（Physical Address Extension）。操作系统提供一个窗口映射的方法，把这些额外的内存映射到进程地址空间中来。Linux系统下采用mmap()系统调用来实现。 【图】PAE/AWE 装载的方式动态装入的原理，来源于很多时候（多个运行的）程序所需要的内存数量会大于物理内存的数量，但程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，将不太常用的数据存放在磁盘里面。 两种典型的动态装载方法： 覆盖装入（Overlay） 几乎已被淘汰，但在内存受限的嵌入式，如DSP还可能有用； 程序员需手工将模块按照它们之间的调用依赖关系组织成树状结构，这样同层级或不同分支上的节点就意味着是独立不会互相调用的，需要用到时就可以覆盖装入到同层其它节点原先所占用的内存空间。 典型用时间换取空间，因为当节点模块没在内存中，则需从磁盘或其它存储器读取，覆盖装入的速度比较慢。 页映射（Paging） 将内存和所有磁盘中的数据和指令按照“页（Page）”为单位划分成若干个页，以后所有的装载和操作的单位就是页。 将程序当前用到的可执行文件页，按先进先出的内存分配规则（FIFO），或找出比较少访问的已装载的物理页分配规则（LUR），找出可用于重新装载的物理内存。 如此装载的管理器就是现代的操作系统，更准确来说是操作系统的存储管理器。 装载过程 创建一个进程：创建一个独立的虚拟地址空间； 建立虚拟空间到物理内存的映射关系； 实质只是分配一个页目录的数据结构，并未发生装载进内存的操作。 装载相应的可执行文件：读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系； 当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这就是传统意义上的装载过程； 由于可执行文件装载时实际上是被映射的虚拟空间，所以也被称为映像文件（Image） 映射的关系只是保存在操作系统内部的一个数据结构； 虚拟内存区域（VMA，Virtual Memory Area），代表进程虚拟空间中的一个段，在系统创建进程后在进程相应的数据结构中设置有一个对应段的VMA，当发生段错误时，就会被查找来定位错误页在可执行文件中的位置。 执行：将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。 页错误（Page Fault）发生过程： CPU开始执行一个地址的指令时，发现该页是个空页时，则认为是一个页错误； 操作系统通过专门的页错误处理例程处理； 查询虚拟空间和可执行文件的映射关系数据结构，找到空页的VMA； 计算相应页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系； 把控制权交还给进程，继续执行。 【图】页错误 虚拟空间就相当于一个缓冲桥梁一样的存在，将物理页和可执行文件的分页在需要(用到)的时候才关联起来。 进程虚存的空间分布ELF文件视图ELF文件被映射时，是以系统的页长度作为单位的，那么每个段在映射时的长度应该都是系统页长度的整数倍；如果不是，那么多余的部分也将占用一个页。 因此，对于相同权限的段（比如可读可写、可读可执行），把它们合并到一起当作一个段进行映射，就减少了内存的浪费。 ELF中的Segment（节）就是这种经过合并的包含一个或多个属性类似的Section（段）的概念。合并成Segment（节）后，VMA也会对应减少（一个Segment对应一个），从而减少页面内部的碎片，节省内存空间。 Section存储的是从链接的角度出发，称为ELF文件的链接视图（Linking View）； Segment划分的是从装载的角度出发，称为ELF文件的执行视图（Execution View）。 查看Segment的指令： $gcc -static SectionMapping.c -o SectionMapping.elf $readelf -S SectionMapping.elf $readelf -l SectionMapping.elf 描述Segment的结构叫程序头（Program Header），描述了ELF文件该如何被操作系统映射到进程的虚拟空间，在ELF可执行文件中会有一个专门的数据结构程序头表（Program Header Table）用来保存Segment信息，表元素是结构体Elf32_Phdr： p_type：Segment的类型，包括LOAD、DYNAMIC、INTERP； p_offset：Segment在文件中的偏移； p_vaddr：Segment第一个字节在进程虚拟地址空间的起始位置，LOAD类型的元素均按此从小到大排列； p_paddr：Segment的物理装载地址，LMA，一般和p_vaddr一样； p_filesz：Segment的ELF文件所占用长度，可能为0，因可能这个Segment是在ELF文件中不存在的内存； p_memse：Segment的进程虚拟地址空间占用长度，可能为0。对于LOAD类型的Segment，p_memse不能少于p_filesz，多余的部分全填充0，代表构造ELF文件时不需要额外设立BSS的Segment； p_flags：Segment的权限属性，包括R可读、W可写、X可执行； p_align：Segment的对齐属性，实际对齐字节是等于2的p_align次方； 堆栈VMA除了被用来映射可执行文件中的各个Segment外，还被使用来对进程的地址空间进行管理。堆（Heap）、栈（Stack）在进程的虚拟空间中的表现就是以VMA的形式存在。 查看进程的虚拟空间分布： $./SectionMapping.elf &amp; # 查询可执行文件的进程号 $cat /proc/21963/maps 每个线程都有属于自己的堆栈，单线程的程序中VMA堆栈是全部归它使用。也有个特殊的VMA叫“vdso”，其地址位于内核空间，事实上它是一个内核模块，进程可以通过访问这个VMA来跟内核进行一些通信。 操作系统通过给进程空间划分出一个个VMA来管理虚拟空间，基本原则为将相同权限属性的、有映像文件的映射成一个VMA，进程中分如下几种VMA区域： 代码VMA，权限只读、可执行，有映像文件； 数据VMA，权限可读写、可执行，有映像文件； 堆VMA，权限可读写、可执行，无映像文件，匿名，可向上扩展（地址比栈低，低位的起始地址靠近内存底端）； 栈VMA，权限可读写、不可执行，无映像文件，匿名，可向下扩展（地址比堆高，高位的起始地址靠近系统内核内存区域）； 堆最大的申请数量会受到系统版本、程序大小、用到的动态库/共享库数量、大小、程序栈数量、大小、随机地址空间分布技术（为防止程序被恶意攻击）等因素影响，下面是测试malloc最大内存申请数量的代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; unsigned maximum = 0; int main(int argc, char *argv[]) &#123; unsigned blocksize[] = &#123; 1024 * 1024 , 1024, 1 &#125;; int i, count; for (i=0; i&lt;3; i++) &#123; for (count=1; ; count++) &#123; void *block = malloc( maximum + blocksize[i] * count); if (block) &#123; maximum = maximum + blocksize[i] * count; free(block); else &#123; break; &#125; &#125; &#125; printf(&quot;maximum malloc size = %u bytes\n&quot;, maximum); &#125; 由于有着长度和起始地址的限制，对于可执行文件来说，它应该尽量地优化自己的空间和地址的安排，以节省空间。 ELF可执行文件的起始虚拟地址一般为0x08048000，按上述的合并过程所得的Segment，在其对齐地址（按页单位大小划分）后内部仍可能存在很多碎片（不足一页的多余部分），所以UNIX系统将各个段接壤部分（文件头也被视作一个段会与其它段合并）共享一个物理页面，然后将物理页面分别映射两次到虚拟地址空间，使虚拟地址空间看起来和ELF的文件分段一致，实质在物理内存中是共享页来充分利用空间，从而使一个物理页面可能同时包含两个或以上的段数据（只要段数据的大小总和少于物理页单位大小）。所以一个可装载的Segment，它的p_vaddr除以对齐属性的余数等于p_offset除以对齐属性的余数。 【图】ELF文件段合并 装载ELF过程 在用户层面，bash进程调用fork()系统调用创建一个新进程； 新进程调用execve()系统调用执行指定的ELF文件； 原bash进程继续返回等待刚才启动的新进程结束； 然后继续等待用户输入命令。 execve()有很多不同形式包装的exec系列API，其在内核中做了如下事情： 调用入口sys_execve()进行一些参数的检查复制； 调用do_execve()，查找被执行的文件，找到则读取文件的前128字节，来判断文件格式，头4个字节甚至称为魔数，例如ELF可执行文件是 0x7F e l f，Java可执行文件是 c a f e，Shell等脚本是 #!(根据魔数确定是脚本后再解析后面的解释程序的路径，像 #!/bin/sh、#!/usr/bin/python)； 然后调用search_binary_handle()去搜索和匹配合适的可执行文件装载处理过程，例如load_elf_binary()、load_aout_binary()、load_script()等，以ELF加载为例： 检查文件格式的有效性； 寻找动态链接的”.interp”段，设置动态链接器路径； 根据程序头表，对文件进行映射； 初始化ELF进程环境； 将系统调用的返回地址修改成ELF可执行文件的入口点，对于静态链接的ELF文件该入口点就是ELF文件的文件头中e_entry所指的地址，对于动态链接的ELF可执行文件则入口点是动态链接器； 当sys_execve()系统调用从内核态返回到用户态时，EIP寄存器直接跳转到ELF程序的入口地址，开始执行程序，ELF可执行文件装载完成。 动态链接静态链接的缺点： 浪费内存和磁盘空间，比如一个目标文件静态链接到N个不同的可执行文件，那么磁盘被占用的空间就比复用一个目标文件时多出了N倍，若这些文件同时被加载运行的话，内存空间也同样是N倍的增长； 模块更新困难，一旦使用的目标文件模块更新，所有用到的程序就得重新获取新版本、重新链接、再发布新程序。 动态链接（Dynamic Linking）优点： 把程序的模块相互分割开来，形成独立的文件，不对那些组成程序的目标文件进行链接，等到程序运行时才链接；（解决占用磁盘空间问题） 若有程序已加载并动态链接了所需的目标文件，下一个复用该目标文件的程序加载时，就无需重复加载此目标文件，只要链接就行了；（解决占用内存空间问题） 还减少了物理页的换入换出，增加了CPU的缓存命中率，也解决了模式升级难的问题； 运行时可动态加载各种程序模块，后来被用来制作各种插件（Plug-in），产品公司按规则制定好程序的接口，其它公司或开发者按这种接口编写符合要求的动态链接文件； 加强程序的兼容性，动态链接库相当于在程序和操作系统之间增加了一个中间层。 而动态链接的缺点是，当程序所依赖的某个模块更新后，由于新的模块与旧的模块之间接口不兼容，导致程序无法运行，所以非大版本更新时就需一直做向后兼容。 ELF动态链接文件称为动态共享对象（DSO，Dynamic Shared Objects），即共享对象，一般是.so格式文件，Windows下是动态链接库（Dynamic Linking Library），一般是.dll格式文件。 程序被装载时都要进行重新链接，所以，动态链接会导致程序在性能的一些损失（5%左右，对比重复地浪费内存和磁盘空间是值得的），但有些优化方法可减小：比如延迟绑定（Lazy Binding）。从而换取程序的空间节省和构建、升级时的灵活性。 例子编译成共享对象： $gcc -fPIC -shared -o Lib.so Lib.c编译链接： $gcc -o Program Program.c ./Lib.soLib.so也参与链接是因为，链接器需要把定义在动态共享对象中的函数符号的引用标记为一个动态链接的符号，但不会对它进行地址重定位，把这个过程留到装载的时再进行。要不链接静态库重定位出外部引用的函数地址，要不链接动态库标记为动态链接符号，要不就编译报错了。 【图】动态链接过程 查看虚拟地址空间分布（可查看到对动态共享对象的引用）： $./Program &amp; [1] xxxxx printing from Lib.so 1 $cat /proc/xxxxx/maps $kill xxxxx一般会包括动态链接器ld.so、C语言运行库libc.so 查看动态共享对象的装载属性： $readelf -l Lib.so动态链接模块的装载地址是从0x00000000开始的，它是一个无效地址，共享对象的最终装载地址在编译时是不确定的。 地址无关代码上一点提到，共享对象的装载起始地址不是一开始就固定的（与可执行文件不同），为管理共享模块的地址分配，要手工分配的称为静态共享库，会有以下问题： 地址冲突； 静态共享库的升级后，会产生全局函数和变量地址变化； 所以共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。 一个程序在编译时假设被装载的目标地址为0x1000，但在装载时操作系统发现0x1000这个地址已经被别的程序使用了，从0x4000开始有一块足够大的空间可以容纳该程序，那么该程序就可以被装载至0x4000，程序指令或数据中的所有绝对引用只要都加上0x3000的偏移，这就是装载时重定位（Load Time Relocation），解决了动态模块中有绝对地址引用的问题，但指令部分无法在多个进程之间共享（因为进程之间相互不知道指令在其它进程装载重定位的地址，所以只能和数据一样，每个进程中按上述规则产生了副本）。 $gcc -fPIC -shared -o Lib.so Lib.c上面这个指令中，-fPIC代表使用地址无关代码技术，否则使用装载时重定位。 地址无关代码（PIC，Position-independent Code），是要使程序模块中共享的指令部分在装载时不需要因为装载地址改变而改变，把指令中的那些需要被修改的部分分离出来，和数据部分放一起，数据部分在每个进程中都会有一个副本，这样指令部分就可保持不变了。 有4种寻址模式： 模块内部调用或跳转，利用相对偏移调用指令实现； 模块内部数据访问，利用当前指令地址（PC）加偏移量实现；（获取PC通过调用__i686.get_pc_thunk.cx函数，把返回地址，即把call的下一条指令的地址放到ecx寄存器，那就是当前PC了） 模块间数据访问，其它模块的全局变量的地址是跟模块的装载地址有关，因为ELF的数据段里面建立了一个指向这些变量的指针数组，即全局偏移表（Global Offset Table，GOT），当代码需要引用这些全局变量时，通过GOT中相应的项间接引用，每个变量都对应一个4个字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项。由于GOT放在数据段，所以可在装载时再被修改，并每个进程都可以有独立的副本互不影响； 模块间调用或跳转，目标函数的地址保存在GOT中，调用时通过GOT中的项进行间接跳转（先得到当前指令地址PC，然后加上偏移值得到函数所在GOT中的偏移。这样所引用的外部模块函数就也是地址无关的，相对地根据偏移找到GOT中在动态链接后加载的其它模块的目标函数所在地址）。 大写的-fPIC是没有硬件平台的限制的，小写的-fpic则存在某些平台上有限制，例如全局符号的数量或者代码的长度。 区分是否PIC的指令： readelf -d foo.so | grep TEXTRELPIC是不包含代码重定位表的。 ELF共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量，也就是说当作前面的“模块间调用或跳转”，通过GOT来实现变量的访问，当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把GOT中的相应地址指向该副本，这样此变量在运行时实际上最终就只有一个实例。 多了GOT中间一层的寻址，速度会比装载时重定位的共享对象运行速度慢，但GCC默认会使用PIC方式来动态链接可执行文件的代码部分，以便不同的进程能共享代码段，节省内存（存在.got这样的段）。 延迟绑定（PLT）要解决动态链接、（全局和静态数据、模块间调用的）GOT定位慢、间接寻址等的速度问题，ELF采用了一种叫延迟绑定（Lazy Binding）的思路，当函数第一次被调用到时才进行绑定（符号查找、重定位等），实现方法是PLT（Procedure Linkage Table）： 链接器初始化阶段，没有填入函数的地址，不需查找符号，只是将符号引用在重定位表“.rel.plt”的下标和模块ID压入堆栈，然后调用_dl_runtime_resolve()来完成符号解析和重定位。 .got保存全局变量引用的地址，.got.plt保存函数引用的地址 .got.plt保存的前三项（延迟绑定所需的一些信息），为系统所用，包括 .dynamic段的地址 本模块的ID（动态装载时被初始化） _dl_runtime_resolve()的地址（动态装载时被初始化）。 plt段本身也是地址无关的代码，所以可跟代码等一起合并成同一个可读可执行的“Segment”被装载入内存。 动态链接相关结构动态链接器（Dynamic Linker）实际上是一个共享对象。 .interp段，解释器，保存需要的动态链接器的路径。查看指令objdump -s a.out .dynamic段，保存动态链接器所需要的基本信息，可以看作是动态链接下ELF文件的文件头，指示依赖哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等，结构为Elf32_Dyn，d_tag对应的含义： DT_SYMTAB，动态链接符号表地址 DT_STRTAB，动态链接字符串表地址 DT_STRSZ，动态链接字符串表大小 DT_HASH，动态链接哈希表地址 DT_SONAME，本共享对象的“SO-NAME” DT_RPATH，动态链接共享对象搜索路径 DT_INIT，初始化代码地址 DT_FINIT，结束代码地址 DT_NEED，依赖的共享对象文件(名) DT_REL DT_RELA，动态链接重定位表地址 DT_RELENT DT_RELAENT，动态重定位表入口数量 查看.dynamic段的内容： $readelf -d Lib.so查看主模块或共享库依赖于哪些共享库： $ldd Program1查看动态符号表及其哈希表(用于更快地查找符号)： $readelf -sD Lib.soPIC模式的共享对象也需要重定位，虽然代码段不需要重定位，但数据段包含了绝对地址的引用（代码段中的绝对地址相关部分被分离成GOT，而GOT实际上时数据段的一部分）。像.rel.dyn实际上是对.got和数据段的数据引用的修正，.rel.plt是对函数引用的修正，位于.got.plt。 查看动态链接文件的重定位表： $readelf -r Lib.so $readelf -S Lib.soGLOB_DAT和JUMP_SLOT此两种重定位入口类型表示，当动态链接器需要重定位时（可能被延迟），先找到函数符号在全局符号表中的地址，然后直接将其填入.got.plt中对应偏移的位置上（即被修正的位置）。而RELATIVE则必须在装载时进行重定位，即基址重置Rebasing，因为其包含绝对地址的引用，一般是数据段的部分。 PIC模式编译的ELF文件，调用了一个外部函数，则函数会出现在.rel.plt中，而如果不是PIC模式编译则出现在.rel.dyn中。 最后，在动态链接时，进程堆栈会保存动态链接器所需的一些辅助信息数组（Auxiliary Vector），它位于环境变量指针的后面（更高位的内存地址上） 动态链接的步骤和实现 动态链接器本身不可以依赖于其他任何共享对象； 动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成，即自举（Bootstrap）。当操作系统将进程控制权交给动态链接器时开始执行，调用这些变量甚至函数前要先等自举完成，包括自举内部也不能调用。 先找出自己的GOT 再找出.dynamic段 通过重定位表和符号表，得到本身的重定位入口，进行重定位。 自举后，可执行文件和链接器本身的符号表就合并到全局符号表（Global Symbol Table）。然后根据.dynamic中的DT_NEEDED入口类型找出依赖的共享对象，放入到一个装载集合中，之后通过一般的广度优先算法进行遍历集合中依赖的共享对象，读取相应的ELF文件头和.dynamic段进行代码段和数据段的空间映射。 指定寻址共享对象的路径： $gcc main.c b1.so b2.so -o main -Xlinker -rpath ./当遇到依赖的共享对象中，存在重名符号的情况时，会出现共享对象里面的全局符号被另一个共享对象的同名全局符号覆盖，此称为全局符号介入（Global Symbol Interpose），它遵循的规则是，当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后面加入的符号被忽略。 然后，链接器开始重新遍历可执行文件和共享对象的重定位表，将他们GOT/PLT中每个需要重定位的位置进行修正。 完成重定位后，如果共享对象有.init段则链接器执行之实现初始化，如有.finit段则在程序退出时执行。可执行文件的.init和.finit则由程序来执行。 最后进程的控制权转交给程序的入口并且开始执行。 链接器既是一个共享对象，也是一个ELF可执行程序。对于动态链接的可执行文件，内核（execve()）会分析它的动态链接器地址（在.interp段），将动态链接器映射至进程地址空间，把控制权交给它，去装载依赖的共享库。(入口地址在没有.interp就是ELF的e_entry，有则是动态链接器的e_entry) 动态链接器入口（执行顺序）： _start() _dl_start()重定位/自举 _dl_start_final()收集基本的运行数值 _dl_sysdep_start进行平台相关的处理 _dl_main()对程序依赖的共享对象进行装载。 显式运行时链接显示运行时链接（Explicit Run-time Linking），也叫运行时加载，就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块时将其卸载。能被这样操作的共享对象叫做动态装载库（Dynamic Loading Library）。 当程序需要用到某个插件或者驱动的时候，才将相应的模块装载进来，而不需要从一开始就将他们全部装载进来，从而减少了程序启动时间和内存使用。并且程序可以在运行的时候重新加载某个模块，这样使得程序本身不必重新启动而实现模块的增加、删除、更新等。 动态库的装载通过一系列动态链接器提供的API完成： dlopen，打开动态库，当第一个参数filename设置为0时，函数返回全局符号表的句柄；第二个参数flag表示函数符号的解析方式，包括RTLD_LAZY延迟绑定，RTLD_NOW模块被加载时即完成函数绑定；返回值是被加载的模块的句柄，需要手工先加载其它嵌套的依赖库。 dlsym，查找需要的符号，第一个参数为dlopen返回的句柄；第二个参数是要查找的符号；返回值，若找的符号是函数，则返回函数的地址，如果是变量，则返回变量的地址，如果是常量，则返回常量值。 dlerror，如果dlsym找到符号，则返回NULL，否则返回对应的错误信息。 dlclose，卸载已加载的模块，其与dlopen一起共同通过加载计数器管理模块装载状态，卸载过程是先执行.finit段代码，然后将相应符号从符号表中去除，取消进程空间跟模块的映射关系，最后关闭模块文件。 可以通过以下指令参考符号表： $objdump -t 共享库的组织共享库版本共享库的更新分两类： 兼容更新 不兼容更新 共享库的ABI（Application Binary Interface），对于不同语言，主要包括一些诸如函数调用的堆栈结构、符号命名、参数规则、数据结构的内存分布等方面的规则。改变（C语言）共享库ABI的行为包括： 导出函数的行为发生改变，不再满足旧版本规则的函数行为准则； 导出函数被删除； 导出数据的结构发生变化； 导出函数的接口发生变化。 例如不同版本的编译器、操作系统和硬件平台，都很容易使得产生的程序文件的API兼容困难。 版本命名一般采用规则：libname.so.x.y.z，每个共享库都有一个SO-NAME，这个SO-NAME即共享库的文件名去掉次版本号和发布版本号，保留主版本号。系统会为每个共享库在它所在的目录创建一个跟SO-NAME相同的并且指向它的软链接（Symbol Link），这个软链接会指向目录中主版本号相同、次版本号和发布版本号最新的共享库，.dynamic中的DT_NEED类型的字段值就是使用SO-NAME，这样使能依赖最新的兼容的共享库，但又无需每次都更改依赖的库的版本号。而当主版本号升级后，系统就会存在多个SO-NAME，也不会影响已有的程序，除非进行卸载删除。 工具ldconfig，在安装或更新一个共享库时，运行它会遍历所有的默认共享库目录，更新或创建所有的软链接，使指向最新版本的共享库。 在编译器命令行里，可以指定-lXXX，表示链接一个libXXX.so.2.6.1的共享库。 符号版本为解决次版本号交会问题（Minor-revision Rendezvous Problem），即较低次版本不向前兼容所产生的符号缺少问题，采用了符号版本机制。 在共享库次版本升级时，除了SO-NAME更新，还为新添加的全局符号打上标记。可以在链接共享库时编写一种符号版本脚本的文件，指定这些符号与集合之间及集合与集合之间的继承依赖关系。可以使用版本机制（Versioning）和范围机制（Scoping）两种方式指定。 程序里面记录的不是构建时共享库中版本最新的符号集合，而是程序所依赖的集合中版本号最小的那个。 指定脚本文件： $gcc -shared -fPIC lib.c -Xlinker --version-script lib.ver -o lib.so # 相当于ld --version-script lib.ver共享库系统路径大部分开源的操作系统都遵守一个叫FHS（File Hierarchy Standard）的标准，其规定了一个系统中的系统文件应该如何存放。 /lib，存放系统最关键和基础的共享库，如动态链接器、C语言运行库、数据库等； /usr/lib，存放非系统运行时所需的关键性共享库，主要是开发时用的库； /usr/local/lib，放置更操作系统本身并不十分相关的库，主要是第三方的应用程序的库。 共享库查找过程动态链接的模块所依赖的模块路径保存在.dynamic段里面，由DT_NEED类型的项表示。对模块的查找规则： 如果DT_NEED里面保存的绝对路径，则动态链接器就按此路径查找； 如果DT_NEED里面保存的相对路径，则动态链接器会在/lib、/usr/lib和/etc/ld.so.conf配置文件指定的目录中查找共享库。（为保可移植性和兼容性，一般是相对的） ldconfig还会缓存起SO-NAME到/etc/ld.so.cache，方便快捷查找（共享库目录下添加、删除、更新任何一个共享库或更改/etc/ld.so.conf的配置，都应该运行ldconfig）。 环境变量 LD_LIBRARY_PATH（优先查找该指定的目录下的共享库），对应指令参数-library-path； LD_PRELOAD，指定预先装载的一些共享库或目标文件。利用它来覆盖后面加载的同名全局符号（全局符号介入机制），从而改写标准C库中的某个或某几个函数而不影响其他函数，方便调试测试； LD_DEBUG，打开动态链接器的调试功能，运行时打印出各种有用的信息。 共享库的创建和安装创建： $gcc -shared -Wl,-soname,my_soname -o library_name source_files library_files-Wl 传递-soname my_soname给链接器。默认情况下，链接器在产生可执行文件时，只会将那些链接时被其他共享模块引用到的符号放到动态符号表，这样可以减少动态符号表的大小。ld链接器提供了-export-dynamic参数将全局符号导出到动态符号表。 清除符号信息（或通过ld的-s和-S参数使生成的输出文件不产生符号信息，s是所有符号信息，S是调试符号信息）： $strip libfoo.so共享库构造和析构函数attribute((constructor))此属性加在声明的函数上，即指定该函数为共享库构造函数，拥有这种属性的函数会在共享库加载时被执行，即在程序的main函数之前执行，又或者在dlopen返回之前被执行。 内存程序的内存布局 栈：通常在用户空间的最高地址处分配（接近内核空间处）； 堆：当程序使用malloc或new分配内存时，在栈的下方（低地址方向）分配，堆一般比栈大得多，也没固定统一的存储区域； 可执行文件映像：由装载器在装载时将可执行文件的内存读取或映射到这里； 保留区：对内存中受到保护而禁止访问的内存区域总称，不是一个单一的区域； 动态链接库映射区域：如果可执行文件依赖其他共享库，就在栈和堆之间分配一个区域装载共享库进空间。 栈向低地址增长，堆向高地址增长。指针初始化为NULL或栈上的指针初始化被随机分配地址都直接使用个，都可能出现“段错误（segment fault）”，由非法指针解引造成。 栈栈顶由称为esp的寄存器进行定位，压栈的操作使栈顶的地址减少，弹出的操作使栈顶地址增大。栈保存了一个函数调用所需要的维护信息，被称为堆栈帧（Stack Frame）或活动记录（Activate Record），包括： 函数返回地址和参数； 临时变量，包括函数的非静态局部变量、编译器自动生成的其它临时变量； 保存的上下文，包括函数调用前后需要保持不变的寄存器。 函数的活动记录用ebp（指向函数活动记录的一个固定位置，称为帧指针 Frame Pointer）和esp两个寄存器划定范围。 在参数之后的数据即是当前函数的活动记录，ebp所直接指向的数据是调用该函数前ebp的值，这样在函数返回的时候，ebp可以通过读取这个值恢复到调用前的值 【图】活动记录 函数调用过程： 把所有或一部分参数压入栈中，若其它参数没有入栈，那么使用某些特定的寄存器传递； 把当前指令的下一条指令的地址压入栈中，并跳转到函数体执行，这两步由call指令完成； push ebp，把ebp压入栈中，称为old ebp； mov ebp,esp，ebp=esp 【可选】sub esp, XXX，在栈上分配XXX字节的临时空间； 【可选】push XXX，如有必要，保存名为XXX寄存器； GCC编译器有一个参数-fomit-frame-pointer可以取消帧指针，空出ebp寄存器供使用，但帧上的寻址速度会变慢，无法准确定位函数的调用轨迹。 eax一般会在函数的最后被赋值，作为返回值传出，函数返回之后，调用方可以通过读取eax寄存器来获取返回值。 但像函数被声明为static、函数在编译单元仅被直接调用，没有显示或隐式去地址的情况下，编译器生成函数的进入和退出指令序列时并不按标准方式进行。 调用惯例函数的调用方和被调用方对于函数如何调用须要有一个明确的约定，即调用惯例（Calling Convention）。 函数参数的传递顺序和方式，调用方将参数压入栈，函数自己再从栈中将参数取出，压栈顺序从左至右，还是从右至左，还是使用寄存器传递以提高性能； 栈的维护方式，弹出全部被压入栈的参数的工作，由函数的调用方还是函数本身来完成； 名字修饰的策略，为了链接时对调用惯例进行区分。 默认的调用惯例是cdecl，如 int _cdecl foo(int n, float m)，代表从右至左的顺序压参数入栈、函数调用方出栈、直接在函数名称前加1个下划线。其它还有如stdcall、fastcall、pascal。 程序返回时，先使用pop恢复保存在栈里的寄存器，然后从栈里取得返回地址，返回到调用方，调用方再调整ESP将堆栈恢复。 一般的调用惯例，都采用eax和edx联合返回的方式进行，eax存储返回值要低4字节，edx存储返回值要高1-4字节；超过8字节的采用隐含参数传入（通过复合指令rep movs，相当于memcpy），将eax指向的内容拷贝给调用方，即仍然是eax传出函数返回的结构体，只不过存储的是结构体的指针。 堆与内存管理如果内核提供一个系统调用，可以让程序使用这个系统调用申请内存，但效率较差，每次程序申请或者释放堆空间都要进行系统调用。所以，程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间，管理着堆空间分配的往往是程序的运行库。 运行库拥有一个算法进行管理堆空间。 brk()系统调用，实际上就是设置进程的数据段结束地址。 mmap()系统调用，向操作系统申请一段虚拟地址空间，当它不将地址空间映射到某个文件时，我们称这块空间为匿名（Anonymous）空间，就拿来作为堆空间。 malloc函数： 对于小玉128KB的请求，会在现有的堆空间里面按堆分配算法分配一块空间并返回； 对于大于128KB的请求，会使用mmap()函数为它分配一块匿名空间，然后再匿名空间中为用户分配空间。 malloc申请的空间起始地址和大小都必须是系统页的大小的整数倍。 堆分配算法 空闲链表，一旦链表被破坏，整个堆就无法正常工作，容易被越界读写所接触到； 位图（Bitmap），将整个堆划分为大量的块，每个块的大小相同，总是分配整数个块给用户，使用一个整数数组记录块的使用情况，用两位表示一个块的头/主体/空闲三种状态。 多级位图； 对象池。 运行库入口函数和程序的初始化入口函数或入口点（Entry Point）准备好main函数执行所需要的环境，并负责调用main函数，会记录main函数的返回值，调用atexit注册的函数，结束进程。 操作系统在创建进程后，吧控制权交给程序的入口，此入口往往是运行库中的某个入口函数； 入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造等； 入口函数完成初始化后，调用main函数，开始执行程序主体部分； main函数执行完毕后，返回到入口函数，入口函数进行清理工作，包括全局变量的析构、堆销毁、关闭I/O等，然后进行系统调用结束进程。 _start() __libc_start_main() exit() _exit() 运行库与I/O文件是一个广义的概念，各种具有输入输出概念的实体，如设备、磁盘文件、命令行等。在操作系统层面上，文件操作也是有类似于FILE的一个概念，这叫文件描述符（File Descriptor）或句柄（Handle），打开文件得到的fd，表示打开文件表的下标，由于表处于内核，并且用户无法访问，因此用户即使拥有fd，也无法得到打开文件对象的地址，只能通过系统提供的函数来操作。 I/O的职责是，初始化函数需要在用户空间中建立stdin、stdout、stderr及其对应的FILE结构，使得程序进入main之后可以直接使用printf、scanf等函数。 C语言运行库C运行库（CRT） 主要功能包括： 启动与退出 标准函数 I/O 堆 语言实现 调试 标准库：ANSI C89 ，到ANSI C99，主要文件（模块）包括： 标准输入输出 stdio.h 文件操作 stdio.h 字符操作 ctype.h 字符串操作 string.h 数学函数 math.h 资源管理 stdlib.h 格式转换 stdlib.h 时间/日期 time.h 断言 assert.h 各种类型上的常数 limits.h &amp; float.h 变长参数 stdarg.h 非局部跳转 setjmp.h 运行库的代表性特殊函数： 变长参数（得益于cdecl调用惯例） va_list ap;，让ap以后依次指向各个可变参数 va_start(ap, lastarg);，初始化ap type next = va_arg(ap, type);，获得下一个不定参数 va_end(ap); 在GCC编译器下，变长参数泓可以使用“##”宏字符串链接操作实现，在MSVC下使用VA_ARGS。 非局部跳转。 辅助程序运行的运行库： /usr/lib/crtl.o，包含程序的入口函数_start，由它负责调用__libc_start_main初始化libc并且调用main函数进入真正的程序主体； /usr/lib/crti.o，帮助.init和.finit它们启动，比如计算GOT等； /usr/lib/crtn.o，同上。其实crti.o和crtn.o分别是_init()和_finit()函数的开始和结尾部分，它们和其它目标文件按顺序链接后刚好形成完整的_init()和_finit()函数，因此链接时，crti.o必须在用户目标文件和系统库之前，crtn.o必须在用户目标文件和系统库之后。 $objdump -dr /usr/lib/crti.o$objdump -dr /usr/lib/crtn.o 希望使用自己的libc和crt1.o等启动文件代替系统默认的，使用参数GCC的参数”-nostartfile“和”-nostdlib“ 运行库与多线程线程在实际运用中也拥有自己的私有存储空间： 栈，只要知道其他线程的堆栈地址还是可以在线程间访问 线程局部存储（Thread Local Storage，TLS） 寄存器（包括PC寄存器），寄存器存放的数据是执行流的基本数据。 线程相关的部分不属于标准库的内容，多线程相关主要指： 提供多线程操作的接口，比如创建线程、退出线程、设置线程优先级等函数接口； 运行库能在多线程环境下正确运行。 自然具有线程安全属性的函数包括： 字符处理（同时还是可重入） 字符串处理 数学函数（同时还是可重入） 字符串转整形/浮点数 获取环境变量（同时还是可重入） 变长数组辅助函数 非局部跳转函数 线程局部存储（TLS）的实现，定义一个全局变量为TLS类型，则只需加上以下关键字（隐式TLS）： __thread int number;这样，每个线程都会拥有这个变量的一个副本。 显式TLS，程序员须要手工申请TLS变量，并在每次访问该变量时都要调用相应的函数得到变量的地址，并在访问完成之后须要释放该变量。pthread库中提供了 pthread_key_create()、pthread_getspecific()、pthread_setspecific()、pthread_key_delete()。 fread实现fread有4个参数，从文件流stream里读取count个大小为elementSize字节的数据，存储在buffer里。 由于系统调用开销大，要进行上下文切换、内核参数检查、复制，频繁进行会严重影响程序和系统性能，所以I/O系统中引入缓冲（Buffer）的概念。比如讲对控制台的多次写入放入一个数组里，等到数组被填满之后再一次性完成系统调用写入。读文件则先看缓冲中是否有数据，有则直接从缓冲中读取，若为空则通过系统调用一次性读取一大块文件内容填充到缓冲区。 fwrite向文件写入一段数据时，此时这些数据不一定被真正地写入到文件中，而是可能还存在于文件的写缓冲里面，如果此时系统崩溃或意外退出程序，就可能丢失数据。因此标准库提供了相关的函数弥补缓冲带来的问题： fflush，将缓冲的数据全部写入实际的文件，并情况缓冲。 setvbuf，设置指定文件的缓冲，_IONBF（无缓冲模式）：该文件不使用任何缓冲，_IOLBF（行缓冲模式）：仅支持文本模式打开的文件，每收到一换行符，就将缓冲flush，_IOFBF（全缓冲模式）：仅当缓冲满时才flush。 setbuf，同上。 fread-&gt;fread_s (缓冲溢出保护、加锁线程安全)-&gt;_fread_nolock_s（循环读取、缓冲）-&gt;_read（换行符转换）-&gt;系统API 系统调用与API系统调用（System Call），是应用程序与操作系统内核之间的接口。这些接口往往通过中断来实现，比如0x80号中断作为系统调用的入口，各个通用寄存器用于传递参数，EAX寄存器用于表示系统调用的接口号，比如： EAX=1表示退出进程（exit）； EAX=2表示创建进程（fork）； EAX=3表示读取文件IO（read）； EAX=4表示写文件或IOS（write）； EAX=5表示打开文件（open）； EAX=6表示关闭文件（close）； EAX=7表示等待进程退出（waitpid）； EAX=8表示创建文件（create）… 每个系统调用都对应于内核源码中的一个函数，都以sys_开头，比如exit对应sys_exit函数，当系统调用返回时，EAX又作为调用结果的返回值，参数通过EBX、ECX、EDX、ESI、EDI和EBP传入。类型包括有权限管理、定时器、信号、网络等相关的。 可以使用man命令查看每个系统调用的详细说明。因为系统调用使用不便、操作系统间不兼容，所以运行库的存在的一部分原因也是为解决这部分问题。 系统调用是运行在内核状态的，而应用程序基本都是运行在用户态的，操作系统通过中断（Interrupt）来从用户态切换到内核态。 中断有两种类型： 硬中断，来自硬件的异常或事件发生； 软中断，通常是一条指令（int），带一个参数记录中断号，触发某个中断并执行其中断处理程序。 在内核中有一个数组称为中断向量表（Interrupt Vector Table），第n项即包含了指向第n号中断的中断处理程序的指针。触发系统调用的指令（中断号放置在固定的寄存器中，像eax来传入）： int 0x80系统调用使用返回值传递错误码，若为负数表明调用失败，而C语言里大多函数都以返回-1表示调用失败，而将出错信息存储在一个名为errno的全局变量。 CPU执行到int $0x80时，保存现场以便恢复；（int对应的是iret指令，会对压栈的寄存器在切回到用户态时出栈） 然后将特权状态切换到内核态；（用户态和内核态使用的是不同的栈，寄存器SS还应该指向当前栈所在的页，在内核栈中压入用户态的寄存器） 然后CPU查找中断向量表中的第0x80号元素 关于汇编汇编语言（ assembly language，缩写为 asm）是二进制指令的文本形式，与指令是一一对应的关系。二进制的指令又称为操作码（opcode）。 把文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler，它处理的文本，自然就叫做 aseembly code。 寄存器CPU 本身只负责运算，不负责储存数据。CPU 的运算速度远高于内存的读写速度，所以为了避免被拖慢，CPU 都自带一级缓存和二级缓存，而不从内存读写。但CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。寄存器不依靠地址区分数据，而依靠名称。 32 位 CPU 的寄存器大小就是4个字节，早期的 x86 CPU 只有8个寄存器： EAX EBX ECX EDX EDI ESI EBP ESP 寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。 寄存器的具体种类： 数据寄存器 AX：累积暂存器 BX：基底暂存器 CX：计数暂存器 DX：资料暂存器 索引暂存器（变址&amp;指针寄存器） SI：来源索引暂存器 DI：目的索引暂存器 指针寄存器 SP：堆叠指标暂存器 BP：基底指标暂存器 通用寄存器（变量） EAX 是”累加器”(accumulator)，它是很多加法乘法指令的缺省寄存器，默认保存所有API函数的返回值。 EBX 是”基地址”(base)寄存器, 在内存寻址时存放基地址，即作为存储器指针来使用。 ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器，即在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数。loop指令的用法为，CPU执行loop指令的时候，一先进行(CX)=(CX)-1，二判断cx中的值，不为0则转至标号处执行程序，如果为0则向下执行。 EDX 总是被用来放整数除法产生的余数，在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址。 ESI/EDI分别叫做”源/目标索引寄存器”(source/destination index)，因为在很多字符串操作指令中，DS:ESI指向源串，而ES:EDI指向目标串。也可以叫他们做变址寄存器(Index Register），主要是可用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。 EBP 基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部 ESP 栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。SS:SP，SS中存放的是栈顶的段地址，偏移地址存放在SP中，任意时刻有：SS:SP指向栈顶元素。 段寄存器（物理地址=段地址*16+偏移地址） CS CPU将CS:IP指向的内存单元中的内容看作指令（CS:代码段寄存器。IP：指令指针寄存器） DS ES SS EAX是32位寄存器，AX是16位寄存器,AL(AH)是八位寄存器。EAX可以存储的数字是DWORD（双字），AX存储的是WORD（字），AL(AH)存储的是BYTE（字节）。EAX、ECX、EDX、EBX：是AX、CX、DX、BX的延伸，各为32位位。ESI、EDI、ESP、EBP：是SI、DI、SP、BP的延伸，各为32位位 内存模型关于堆，对于动态的内存占用请求，系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址+一段静态数据后的地址开始划分，此为Heap（堆）。 关于栈，其他的内存占用就叫做 Stack（栈），是由于函数运行而临时占用的内存区域。在栈中，系统会为每个调用的函数新建一个帧，用来储存它的内部变量，一般来说，调用栈有多少层，就有多少帧。栈是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。 程序从函数的标签开始执行，这时会在 Stack 上为函数建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。 汇编指令X86指令 push n：用于将运算子放入 Stack，push指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去（即向低位发展）n所占用的字节数，然后将新地址写入 ESP 寄存器。 push %ebx：表示将 EBX 寄存器里面的值，写入某函数的帧。有些编译器（像微软的）描述的寄存器位置则没有前缀符号%。 call function：程序会去找function该函数标签，并为该函数建立一个新的帧。 mov %eax, [%esp+8] ：这是Intel的mov格式，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据，再将数据写入 EAX 寄存器。 movl %edx, 4(%edi)：这个AT&amp;T的格式，由于GNU汇编器不允许值与寄存器相加，必须将值放在括号外（先取地址再运算），这条指令就是把EDX寄存器的值存放在EDI寄存器指向的位置之后4个字节的内存位置中，4也是设置为-4来让方向取反。若对立即数操作，则立即数前面必须放一个$，用其表示取value的内存地址。 add %eax, %ebx：将两个运算子相加，并将结果写入第一个运算子。即将 EAX 寄存器的值加上 EBX 寄存器的值，结果写入第一个运算子 EAX 寄存器。 pop %ebx：取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置（寄存器）。注意，pop指令还会将 ESP 寄存器里面的地址加4进行回收。 ret：终止当前函数的执行，将运行权交还给上层函数，也就是当前函数的帧将被回收。 add %esp, 8：由于esp寄存器存的值就是栈顶地址，该指令表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。 movl %ebx, (%edi)：当edi没括号时，则只是把EBX寄存器的值加载到EDI寄存器中，但若EDI带有括号时，则指令表示把EBX寄存器中的值传送给EDI寄存器中包含的内存位置。 lea eax,[ebx+8]：就是将ebx+8这个值直接赋给eax（ebx其所存地址指向的值+8），而不是把ebx+8处的内存地址里的数据赋给eax。 LEA（load dffective address）关于LEA，可能比较难理解，下面做详细的介绍 LEA指令的功能是取偏移地址（优化寻址时的算术运算，可四则混合运算），MOV指令的功能是传送数据 LEA AX,[1000H]，作用是将内存单元[1000H]的偏移地址1000H送至AX；MOV AX,[1000H]，作用是将内存单元[1000H]的内容1234H送给AX LEA AX,[SI]，作用是将寄存器SI的内容4567H当做数据传送给AX；MOV AX,[SI]，作用是将寄存器SI的内容4567H当做地址看待，将地址为4567H处的内容传送给AX； LEA AX,SI，作用是将寄存器SI的偏移地址1001H传送给AX；MOV AX,SI，作用是将寄存器SI的内容传送给AX； 几种形式：LEA BX ，BUFFERLEA AX，[BX]DILEA DX，DATA [BX]SI 几种等价：1.LEA BX,TABLE 等价于 MOV BX,OFFSET TABLE2.LEA AX,[SI] 等价于 MOV AX,SI 但有时不能直接使用MOV代替，比如：LEA AX,[SI+6] 不能直接替换成：MOV AX,SI+6；但可替换为拆分两步：MOV AX,SI 和 ADD AX,6 LEA指令是一个计算机指令，可以将有效地址传送到指定的的寄存器。LEA OPRD1,OPRD2，OPRD1 为目的操作数，OPRD2 为源操作数，可为变量名、标号或地址表达式。从第二个操作数（源操作数）计算有效地址，并将结果存入第一个操作数（目的操作数）。源操作数是指定了一种访存操作的内存地址，目的操作数为一个通用寄存器。 源操作数为变量或者立即数时，与为寄存器时不同。 对于lea指令来说，有没有[]对于变量是无所谓的，其结果都是取变量的地址，相当于获取其指针，Lea的偏移量还可以是立即数，lea ebx,num; = lea eax,[num]; 对于mov指令来说，有没有[]对于变量是无所谓的，其结果都是取值，立即数时则是直接赋值 另外一则例子： lea eax,[ebx+8]：表示将ebx+8这个值直接赋给eax（ebx其所存地址指向的值+8），而不是把ebx+8处的内存地址里的数据赋给eax。 mov eax,[ebx+8]：而mov指令则恰恰相反，是把内存地址为ebx+8处的数据赋给eax。 lea ebx ,[eax+edx]：这样可以满足要计算两个寄存器的和，而又不破坏原来的值。这条指令执行的是 ebx = eax + edx 这条加法运算（两项地址所指向的值相加），如果用add指令，则不可能一条指令内完成。 ARM指令与X86汇编比较： x86汇编的寄存器少，用途易记，指令最多只有2个操作数，常用的指令基本都支持各种寻址模式，x86对于汇编器以及反汇编器开发者就特别麻烦，1是opcode规则特别特别复杂，2是太多可有可无的前缀。 ARM则恰好相反，寄存器多的像海一样难记，还有立即数的使用限制（32位指令处理32位立即数通过伪指令（寄存器）来处理），3元操作数指令提供了不少灵异变化和优化空间。 保护模式分页分别存在于ARM和x86，是需要掌握的基础。 ARM的指令格式： &lt;opcode&gt;{&lt;cond&gt;}{S}{. W|.N} &lt;Rd&gt;,&lt;Rn&gt;{,&lt;operand2&gt;} {}为可选参数，&lt;&gt;为变量 opcode：指令助记符，如MOV、ADD、SUB等； cond：指令条件码： EQ：相等，标志位Z=1 NE：不相等，标志位Z=0 CS/HS：无符号数大于或等于，标志位C=1 CC/LO：无符号数小于，标志位C=0 MI：负数，标志位N=1 PL：正数或零，标志位N=0 VS：溢出，标志位V=1 VC：没有溢出，标志位V=0 HI：无符号数大于，标志位C=1 Z=0 LS：无符号数小于或等于，标志位C=0 Z=1 GE：有符号数大于或等于，标志位N=V LT：有符号数小于，标志位N!=V GT：有符号数大于，标志位Z=0 N=V LE：有符号数小于或等于，标志位Z=1 N!=V AL：无条件执行（默认条件），任何标志位 {S}：是否影响CPSR的值 {.W .N}：指令宽度说明符 Rd：目的寄存器 Rn：第一个操作数寄存器 operand2：第二个操作数，可以是寄存器、立即数、寄存器移位操作。 跳转指令 B指令：B{cond} lable，比如BNE就是not equal z=0时，跳转到lable。 BL指令：BL{cond} lable，如果条件cond满足，会将当前指令的下一条指令的地址copy到R14（LR）寄存器中，然后跳转到lable指定的地址继续执行，这条指令通常作用于子程序，在子程序的尾部 执行MOV PC,LR 就可以返回到主程序中，继续执行下一条指令。 BX指令：BX{cond} Rm，跳转时判断是用arm代还是Thumb代码执行。 存储器访问指令 LDR指令：LDR{type}{cond} Rd,lable，从存储器中加载数据到寄存器，Rd是要加载的寄存器，lable是要读取的内存地址， type指明操作数的大小： B：无符号字节； SB：有符号字节； H：无符号半字； SH：有符号半字； lable读取内存的表示方式： LDR R8, [R9, #04] 或 LDR R8, [R9], #04，表示直接偏移或寄存器偏移，即在寄存器保存的地址上加上偏移量得出要取值的地址，然后取得值就是label； LDR R8, #04，表示取值地址是相对于PC偏移，label就是PC偏移地址所存的值； STR指令：STR{type}{cond} Rd, label，与LDR相反，存储内容到指定的内存中，Rd表示要存的内容，label表示存储单元，type中SB与SH无效。STR R0,[R2,#04] 将R0寄存器的数据，存储到R2+4所指向的存储单元中去。 LDM指令：LDM{addr_mode}{cond} Rn{!} reglist，从指定的存储单元加载多个数据到一个寄存器列表： Rn为基地址寄存器，用于存储初始地址； ! 表示最终地址将写回到Rn寄存器 reglist，在多个连续的寄存器时使用“-”连接，如{R0-R3}，否则{R0,R3,R7} addr_mode: IA，基址寄存器在执行指令之后增加（默认） IB，执行前增加 DA，执行前减少 DB，执行后减少 FB，满递减堆栈 FA，满递增堆栈 ED，空递减堆栈 EA，空递增堆栈 STM指令：STM{addr_mode}{cond} Rn{!} reglist，与LDM相反 PUSH指令：PUSH{cond} reglist，将寄存器推入满递减堆栈中 POP指令：POP{cond} reglist，与PUSH相反 SWP指令：SWP {B}{cond} Rd, Rm, [Rn]，交换寄存器与存储器之间的数据， B为可选字节，有B则交换字节，否则交换32位的字 Rd为要从存储器中加载数据的寄存器 存储器-&gt;寄存器 Rm为要从寄存器加载数据到存储器的寄存器 寄存器-&gt;存储器 Rn:为需要进行数据交换的存储器地址。 数据处理指令 MOV指令：MOV{cond}{S} Rd, operand2，将8位立即数或者寄存器的内容传送到目标寄存器，如MOV,RO,#8或MOV,RO,R1 MVN指令：MVN{cond}{S} Rd, operand2，将8位的立即数或寄存器按位取反后，传送到目标寄存器，此为数据非传送指令 算数运算指令 ADD指令：为加法指令，例如ADD R0,R1,LSL #3即R0 = R1 * 8，ADDS R0,R1,R2即R0 = R1+R2，ADD R0,R1,#2即R0 = R1+@ ADC指令：ADC{cond}{S} Rd, Rn, operand2，带进位的加法指令，将Rn,operand2的值相加，然后再加上CPSR寄存器的C条件标志位的值，最后将结果保存到Rd寄存器. SUB指令：为减法指令，例如SUB RO,R1,#4即R0 = R1-4 RSB指令：逆向减法指令，就是说用operand2 - Rn，然后赋值给Rd 逻辑运算 AND指令：逻辑与，例如AND RO,R0,#1，用来测试R0的最低位 ORR指令：逻辑或，例如ORR R0,R0,#0X0F，指令执行后保留R0的低四位，其余位清0 EOR指令：逻辑异或，例如EOR R0,R0,R0，执行后R0为0（两个同位值不相同，则异或结果为1，相同时为0） ORN指令：ORN{cond}{S} Rd,Rn,operand2，逻辑或非，先将操作数取反，再与目标寄存器进行或操作 BIC指令：BIC{cond}{S} Rd,Rn,operand2，位清除指令，将operand2的值取反，然后将结果与Rn寄存器的值相 “与” 并保存到Rd寄存器中 比较指令： CMP指令：CMP{cond} Rn,operand2，使用Rn寄存器减去operand2的值，但CMP指令不保存计算结果，仅仅根据比较重置标志位（cpsr）： CF : 进位标志 PF : 奇偶标志 AF : 辅助进位标识 ZF : 0标识 SF : 符号标识 OF : 溢出标识 CMN指令：CMN{cond} Rn,operand2，将operand2的值加到Rn寄存器上，这与ADDS的指令功能相同，不过CMN指令不保存计算结果 TST指令：TST{cond} Rn,operand2，测试指令，进行 “与” 运算，但不保存计算结果，仅仅根据计算结果设置标志位（cpsr） TEQ指令：进行 “异或” 运算，但不保存计算结果，仅仅根据计算结果设置标志位 移位指令 LSL：逻辑左移，将整个操作数向左移动两位，右边补0,最终操作也就是 * 2^n(移位)，例如LSL R1,R0,#2，将R0向左移动两位，结果保存到R1中. 也就是 R0 * 2^2 LSR：逻辑右移，整体向右移，左边补0，最终操作也就是 / 2 ^ n(移位)，例如LSR R1,R0,#2，将R0向右移动两位，结果保存到R1中. 也就是 R0 / 2^2 Intel格式与AT&amp;T格式的区别在Intel格式的时候，[]表示地址，()表示数据；在AT&amp;T格式的时候，()表示为地址（编译时可添加编译条件 –masm=intel，或者–masm=att 指定格式）： AT&amp;T: -4(%ebp) //相当于 Intel: [ebp - 4] AT&amp;T: foo(,%eax,4) //相当于 Intel: [foo + eax*4] AT&amp;T: foo(,1) //相当于 Intel：[foo] AT&amp;T: %gs:foo //相当于 Intel：gs:foo AT&amp;T: movl -4(%ebp), %eax //相当于 Intel: mov eax, [ebp - 4] AT&amp;T: movl array(, %eax, 4), %eax //相当于 Intel: mov eax, [eax*4 + array] AT&amp;T: movw array(%ebx, %eax, 4), %cx //相当于 Intel: mov cx, [ebx + 4*eax + array] AT&amp;T: movb $4, %fs:(%eax) //相当于 Intel: mov fs:eax, 4 函数中的指令套路push ebp ; //调用函数前，先保存当前EBP，为栈增加一个元素，BASE用于防止栈空后继续弹栈 mov ebp,esp ; //然后将EBP设为当前堆栈指针 sub esp, xxx ; //预留xxx字节给函数临时变量，栈顶提升(地址变小) ... mov esp,ebp ; //函数执行完，将EBP（调用函数前的栈顶）赋回给ESP，栈顶下降(地址变大) pop ebp ; //从栈中取出EBP，恢复调用函数前的EBP ret ; //返回 iOS上的实践 cmp指令中，一般查看标志位N和Z，N=1表示运算结果为负数，N=0表示结果为正数，Z=1表示运算结果为零，Z=0表示结果为非零。 cpsr，例如当cpsr为0x20000000时，N为对应于32位，Z位对应于31位，如果分别都为00，也就是说非负数非0。 加了条件的b指令一般跟在cmp指令后调用，例如cmp x1,x2和bgt testCode，bgt的判断条件取决于cpsr，即要跳转到testCode执行需要x1大于x2。 执行函数采用bl指令，调用后能返回（b指令不具备返回），bl首先会将下一条的执行命令的地址放到lr（x30）中，然后执行跳转指令，等到跳转函数执行完成，执行跳转函数的ret的时候就会回到需要执行下一条的命令。 64位下，一个寄存器有8个字节的容量，ldr赋值多少取决于接收数据的寄存器是多少字节。 ldur与ldr指令意思一样，只是用于操作负数，例如ldur x1, [x0,#-0x4] ldp，表示从内存中读取数据放到一对内存中，例如ldp w1, w2 [x1, #0x4]，即将x1中所存的地址加上#0x4得到新指向地址，从这个地址指向的数据开始赋值给w1, w2，其中w1和w2分别占用4个字节那么就是其中的4个字节赋值给w1，其中的4个字节赋值给w2。 ldp、ldr 、ldur 都是从内存中读取数据进行赋值。 零寄存器，里面存储的值都是0，比如32位的wzr，64位的xzr。 pc寄存器，存储的是当前执行到的代码的地址。 fp、lr、sp、pc在顺序上，分别应该是x29、x30、x31、x32 将C代码转为汇编的一种方式： xcrun -sdk iphoneos clang -arch arm64 -S Ctest.c -o Ctest.s 在lldb上可以用以下几条指令查看信息： # 读取所有寄存器现存的内容 (lldb) register read # 读取具体某寄存器现存的内容 (lldb) register read x0 # 查询内存地址所指向的内存的值 (lldb) x 0x000000016fd1fa4c (lldb) x x0 （x0所存的内容为内存地址） macOS上的实践ld 需要添加-lSystem标识去防止抛出warning: No version-min specified on command line错误，然后使用 -macosx_version_min 移除错误： ld hello.o -o hello -macosx_version_min 10.13 -lSystem ld hello.o world.o -o hello -macosx_version_min 10.13 -lSystem高级语言对照汇编语言解释： #include&lt;stdio.h&gt; int main(int argc, char const *argv[]) &#123; int i, j, k; printf(&quot;\n&quot;); for(i=1;i&lt;5;i++) &#123; for(j=1;j&lt;5;j++) &#123; for(k=1;k&lt;5;k++) &#123; if(i!=k&amp;&amp;i!=j&amp;&amp;j!=k) &#123; printf(&quot;%d,%d,%d\n&quot;,i,j,k); &#125; &#125; &#125; &#125; return 0; &#125; （movx，x为3种情况的字符：1，l用于32位的长字值；2，w用于16位的字值；3，b用于8位的字节值。） macOS中编译出的文件并不是linux的ELF，而是Mach-O格式，相应的指令如下： file：查看Mach-O文件的类型 lipo：对架构的相关操作 -info：查看架构 -thin：拆除某种架构，lipo &lt;Mach-O&gt; -thin &lt;架构名&gt; -output &lt;输出文件路径&gt; -create：合并多种架构，lipo -create &lt;Mach-O1&gt; &lt;Mach-O2&gt; -output &lt;输出文件路径&gt; otool：查看Mach-O文件结构 -L：查看动态链接库 -h：查看文件头信息 在终端里直接输入otool即可得到各种参数的说明 也可使用免费开源的工具MachOView，查看Mach-O文件（支持胖二进制文件，但汇编代码中没有符号标识，偏移量不是从0开始，所以比较适合用其看局部的详细信息和其它结构中的内容）MachOView Mach-O主要分为三个部分： Header：包含字节顺序、架构类型、加载指令的数量等，使得系统可以快速确认一些信息，比如当前文件用于32位还是64位，对应的处理器是什么、文件类型是什么。 Load commands：指示加载器如何加载二进制文件，它是一张包含很多内容的表，内容包括区域的位置、符号表、动态符号表等。每个加载指令都包含一个元信息，比如指令类型、名称、在二进制文件中的位置等等。 Data：通常是对象文件中最大的部分。主要包含代码、数据，例如符号表，动态符号表等等。Data 中包含若干个 segment (段)，每个 segment 下又有若干个 section(节)： 文本段 __TEXT：类似PE的.text段 数据段 __DATA：类似PE的.data段 动态库加载信息 Dynamic Loader Info 入口函数 Function Starts 符号表 Symbol Table 动态库符号表 Dynamic Symbol Table 字符串表 String Table C通常用GCC编译，OC通常用Clang编译。而二者也其实是可以通用的，即用Clang来编译C代码，GCC来编译OC代码。 名词释义工具 GCC：GNU编译器套装（GNU Compiler Collection），是一套语言编译器，跨平台，后来被Clang+LLVM追赶。 binutils是用来处理许多格式的目标文件，是一整套的编程语言工具程序，跨平台。例如汇编器as、链接器ld、获取信息和反汇编objdump、ELF文件的解释器readelf（只支持Linux）、列出总体和section大小size等。 编码 ASCII：针对英文数字和个别通用符号的编码 Unicode：基于ASCII，增加针对不同国家的语言和符号的编码 UTF-8：动态编码，针对Unicode中可用ASCII编码的情况，节省空间 CPU 32/64位：一般指CPU的通用寄存器(GPRs，General-Purpose Registers)位宽（亦即数据总线的位宽），其代表着在寄存器上的寻址能力，CPU有多少根地址线决定着能寻址到多大的内存地址，32位CPU可以定位2^32个内存单元，即内存空间可以去到4GB。 数据总线：负责计算机中数据在各组成部分之间的传送，数据总线宽度是指在芯片内部数据传送的宽度，而数据总线宽度则决定了CPU与二级缓存、内存以及输入/输出设备之间一次数据传输的信息量。例如，8根数据总线一次可以传输一个字节，16根数据总线一次可以传输两个字节。数据总线是为各部件之间提供数据传送的通路，只有在控制总线和地址总线的作用下，数据总线才有意义。 控制总线：CPU对外部器件的控制是通过控制总线来进行的。控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。 内存 字节序：假设对于0x1234567，内存地址从低到高的话，在计算机内部处理是采用小端字节序来提升效率（即67 45 23 01），其它情况才采用大端字节序来方便阅读（即01 23 45 67）。所以objdump打印的16进制数据都是按小端字节序显示。 堆栈 堆栈段底部：这种底部说法一般指高位地址的顶点，比如一个堆栈段的地址空间是0xBF801FBC~0xBF802000，那么其底部就是0xBF802000。 文件 Mach-O：即Mach Object文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核转储的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性，并提升了符号表中信息的访问速度。 【图】进程初始堆栈 glibc 即GNU C Library，GNU旗下的C标准库，其头文件位于/usr/include，二进制文件的动态标准库在/lib/libc.so.6，静态标准库在/usr/lib/libc.a。 命令集查询 $file foobar.o # 查文件格式 $objdump -h xx.o # 查看object文件内容，-h打印各段基本信息，-x可打印更多信息 $objdump -s -d xx.o # -s以十六制形式打印，-d将指令段反汇编 $objdump -d a.o # -d查看代码的反汇编结果 $objdump -r a.o # -r查看重定位表 $objdump -t libc.a # 查找函数所在的目标文件 $objdump -t # 参考符号表 $size xx.o # 查看ELF文件各段长度 $readelf -h SimpleSection.o # -h表示只显示 $readelf -S SimpleSection.o # 显示节头信息 $readelf -l Lib.so # 查看动态共享对象的装载属性（查看segment） $readelf -d Lib.so # 查看.dynamic段的内容 $readelf -sD Lib.so # 查看动态符号表及其哈希表 $ldd Program1 # 查看主模块或共享库依赖的共享库 $readelf -r Lib.so # 查看动态链接文件的重定位表 $readelf -d foo.so | grep TEXTREL # 区分是否PIC的指令 $ar -t libc.a # 查看静态库包含的架构 $ar -x libc.a # 解压目标文件到当前目录 $./SectionMapping.elf &amp; # 1 查询可执行文件的进程号 $cat /proc/xxxxx/maps # 2 查看进程的虚拟空间分布 $kill xxxxx # 3 编译 $gcc -E hello.c -o hello.i # 预编译 $gcc -S hello.i -o hello.s # 汇编，翻译成汇编语言 $as hello.s -o hello.o # 生成目标文件 $gcc -c hello.s -o hello.o # 编译、汇编原文件 $gcc -c hello.c -o hello.o $gcc -c xx.c # 只编译不链接 $objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o # 媒体文件作段 $gcc -static SectionMapping.c -o SectionMapping.elf # 静态库编译 $gcc -fno-common ... # 所有未初始化的全局变量不以COMMON块的形式处理 $gcc -c -fno-builtin hello.c # 关闭内置函数优化选项 $gcc -fPIC -shared -o Lib.so Lib.c # 编译成共享对象，-fPIC代表使用地址无关代码技术 $gcc -o Program Program.c ./Lib.so # 编译链接 $gcc main.c b1.so b2.so -o main -Xlinker -rpath ./ # 指定寻址共享对象的路径 $gcc -shared -fPIC lib.c -Xlinker --version-script lib.ver -o lib.so # 指定脚本文件 $ld --version-script lib.verz # 指定脚本文件 $gcc -shared -Wl,-soname,my_soname -o library_name source_files library_files # 创建共享库 链接 $ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend.o crtn.o $ld a.o b.o -e main -o ab #-e main表示将main函数作为程序入口，因为ld链接器默认以_start为入口，-o ab表示链接输出文件名为ab，默认为a.out $ld -T link.script #自定义链接脚本 去掉调试信息 $strip foo 内嵌汇编 asm(&quot;movl $42, %ebx \n\t&quot; &quot;movl $1, %eax \n\t&quot; &quot;int $0x80 \n\t&quot; ); 参考汇编语言入门教程 汇编语言中LEA与MOV指令小结 《程序员的自我修养 – 链接、装载与库》 Linux 汇编语言开发指南]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>dynamic</tag>
        <tag>link</tag>
        <tag>register</tag>
        <tag>assembly</tag>
        <tag>library</tag>
        <tag>static</tag>
        <tag>memory</tag>
        <tag>runtime</tag>
        <tag>interrupt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建服务器]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2F%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本地开发完Web App后，只在本地能跑起来是远远未能符合工程应用的需要，我们还需要在服务器上进行账号设置、环境搭建、安装和启动必要的服务、部署自动化、服务进程管理、Web服务设置等的工作，这样才能使我们服务器上的Web在被正常访问的基础上，更高效、稳定地部署和发布。 下面使用阿里云ECS服务器演示（略过购买ECS、购买弹性公网IP、ECS绑定IP的过程）。 修改密码无论是Linux还是Ubuntu，第一次登录时可能会出现提示Login Incorrect，解决办法是 云服务器ECS-&gt;实例-&gt;选择操作的实例； 点击“远程连接”旁边的更多； 重置一次密码（可能需要手机短信验证），注意这里的密码修改的不是6位数字那个远程连接的密码，而是root账户的密码； 密码修改成功后，必须手动重启一次实例； 等待重启成功后，再次连接到远程，输入 root 和 刚刚修改过的密码（密码不明文显示），就可以正常登录了。 远程连接有两种方式连接，一是通过阿里云上提供的网页版命令行连接，而是本地命令行上ssh连接。 网页版连接时需要注意与本地的输入方式差异，一般通过下图右上角的”复制命令输入“完成，因为页面使用部分字母作为快捷方式，故无法直接输入这些字母。 本地命令方式下，可以使用客户端ssh的id公钥代替输入密码来登录远程主机，步骤如下 $ ssh-keygen -t rsa //创建公钥及秘钥对，默认路径为~/.ssh/id_rsa $ ssh-copy-id -i ~/.ssh/id_rsa.pub root@xx.xx.xx.xx //把公钥复制到远程主机 &amp; ssh root@xx.xx.xx.xx //登录 软件更新apt-get的应用 apt-get主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。 sudo apt-get update //更新本机中的软件包的数据库缓存 sudo apt-cache search &lt;name&gt; //查找包含部分关键字的软件包 sudo apt-get install &lt;package_name&gt; //安装指定的软件(自动安装依赖)，-d 只下载包，不解压安装 apt-get install package=version //安装指定版本 apt-get source &lt;source_code_name&gt; //下载软件包源代码 apt-get remove packagename //卸载软件，同时会卸载依赖，但保留配置，--purge 删除配置 apt-get clean //清理所有的缓存文件 dpkg -l //查找安装在机器上面的软件包 参考链接 python3的安装 sudo apt-get install python3 //安装python3.6，可指定3.7，系统默认有python2 python3 -V //查看python3的版本号 sudo apt-get install pip3 //安装对应3.6的版本，3.7可使用sudo python3.7 get-pip.py 虚拟py环境搭建 pip3 install virtualenv mkdir awesome-python3-webapp virtualenv venv -p python3 source venv/bin/activate (venv)# pip install aiohttp (venv)# pip install jinja2 cd awesome-python3-webapp ... git init git add . git commit -m &quot;Initial commit&quot; git remote add origin &lt;remote_url&gt; git push -u origin master 同步文件从本地同步到远程 rsync -avz -e ssh /Path/to/uploadFile root@xx.xx.xx.xx:/Path/to/file //使用默认端口 rsync -avz -e &apos;ssh -p 61124&apos; /Path/to/uploadFile/ root@xx.xx.xx.xx:/Path/to/file //指定端口 从远程同步到本地 rsync -avzP -e ssh root@xx.xx.xx.xx:/Path/to/downloadFile /Path/to/file rsync -avzP -e &apos;ssh -p 61124&apos; root@xx.xx.xx.xx:/Path/to/downloadFile /Path/to/file 开放端口“实例”-&gt;”更多”-&gt;”网络和安全组”-&gt;”安全组配置”-&gt;”(安全组列表)配置规则”-&gt;”添加安全组规则” 一般只需设置入规则方向、TCP协议、端口范围、默认权对象(0.0.0.0/0) 检测在远程主机上使用以下指令检测是否能访问 curl &lt;ip&gt;:&lt;port&gt; //或者使用 wget &lt;ip&gt;:&lt;port&gt; 若出现Connection refused的错误 netstat -tnl 配置数据库mysql： 官网下载 下载完注意保存默认提供的密码。 修改密码mysqladmin -u root password [password] 设置环境变量 $ cd ~ $ vim ./.bash_profile &gt; export PATH=$PATH:/usr/local/mysql/bin $ source ~/.bash_profile $ echo $PATH在系统设置-&gt;MySQL-&gt;打开服务 登入 $ mysql -u root -p重置密码 &gt; SET PASSWORD FOR [&apos;username&apos;]@[&apos;host&apos;]=PASSWORD(&apos;[newPassword]&apos;);创建账号 &gt; CREATE USER &apos;[username]&apos;@&apos;[host]&apos; IDENTIFIED BY &apos;[password]&apos;;删除账号 &gt; DROP USER &apos;[username]&apos;@&apos;[host]&apos;;授权 &gt; GRANT [ALL] ON [databasename].[tablename] TO &apos;[username]&apos;@&apos;[host]&apos;取消授权 &gt; REVOKE [ALL] ON [databasename].[tablename] FROM &apos;[username]&apos;@&apos;[host]&apos;查询及创建库/表 #显示数据库列表: &gt;show databases; #选择使用某个数据库: &gt;use [databaseName]; #创建数据库: &gt;create database [databaseName]; #显示库中的数据表: &gt;show tables; #显示数据表的结构: &gt;describe [tableName]; #建表: create table 表名 (字段设定列表)； #删库和删表: drop database 库名; drop table 表名； #将表中记录清空: delete from 表名; #显示表中的记录: select * from 表名;卸载 $ sudo rm /usr/local/mysql $ sudo rm -rf /usr/local/var/mysql $ sudo rm -rf /usr/local/mysql* $ sudo rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist $ sudo rm -rf /Library/StartupItems/MySQLCOM $ sudo rm -rf /Library/PreferencePanes/My* $ subl /etc/hostconfig` # Remove the line MYSQLCOM=-YES- $ rm -rf ~/Library/PreferencePanes/My* $ sudo rm -rf /Library/Receipts/mysql* $ sudo rm -rf /Library/Receipts/MySQL* $ sudo rm -rf /private/var/db/receipts/*mysql* linux下开启、关闭、重启mysql服务命令若启动应用时，报链接不到mysql的错误(Can’t connect to MySQL server on ‘x.x.x.x’)，可检查以下几点： 输入”service mysqld status”查看mysql服务是否已启动； 查账号是否存在，且是否已授权给对应表 use mysql; select host,user from user;； 账号密码是否正确 mysql -u username -p passwd 允许任何主机登陆MySQL，设置/etc/mysql/mysql.conf.d/mysqld.cnf bind-address=0.0.0.0 和 port=3360； 关闭防火墙 systemctl stop firewalld systemctl status firewalld 云服务器的安全组开放对应端口3360. 控制mysql服务的操作： 1）启动 使用 service 启动：service mysql start 使用 mysqld 脚本启动：/etc/inint.d/mysql start 使用 safe_mysqld 启动：safe_mysql&amp;2）停止 使用 service 启动：service mysql stop 使用 mysqld 脚本启动：/etc/inint.d/mysql stop mysqladmin shutdown3）重启 使用 service 启动：service mysql restart 使用 mysqld 脚本启动：/etc/inint.d/mysql restart 四、查看mysql状态 mysql 用户管理创建用户 sudo adduser xx xx为用户名 会自动创建用户主目录 会自动指定系统Shell版本 /bin/bash 需用户指定密码 自动调用 /etc/adduser.conf 自定义参数 –home 指定主目录 –quiet 只打印警告和错误信息，忽略其它信息 –conf 指定configuration文件 –force-badname 用户名合法性弱检查 方法2 sudo useradd xx 什么都不指定 自定义参数 -d 指定主目录 -m 如果存在不再创建，但是此目录并不属于新创建用户；如果主目录不存在，则强制创建； -m和-d一块使用 -s 指定用户登录时的shell版本 -M 不创建主目录 修改密码 sudo passwd xx删除用户 sudo userdel xx # 连同主目录一并删除 sudo userdel -r xx /etc/passwd 使用者账号资讯，可以查看用户信息 /etc/shadow 使用者账号资讯加密 /etc/group 群组资讯 /etc/default/useradd 定义资讯 /etc/login.defs 系统广义设定 /etc/skel 定义档的目录 进程管理Supervisor是用Python开发的监控服务进程工具，可以监听、启动、停止、重启一个或多个进程。当一个进程意外被杀死，利用Supervisor监听到进程死后，会自动将它重启，自动恢复，不再需要自己写shell脚本来控制。 1.安装Supervisor： yum install supervisor easy_install supervisor supervisord -v2.修改配置：安装好后，/etc/supervisor会生成一个supervisord.conf文件及一个conf.d文件目录。supervisord.conf是默认的配置；conf.d中是放指定进程的自定义配置。 conf文件中，使用[xx]分隔开配置中的模块，其中[include]是导入其它自定义的进程配置文件，默认配置是制定.ini的格式，亦可是*.conf。 添加自定义配置，新建一个对应应用名为xx的xx.conf到 /etc/supervisor/conf.d/xx.conf，写入如下内容 [program:xx] command = /srv/xx/www/app.py directory = /srv/xx/www user = userName startsecs = 3 redirect_stderr = true stdout_logfile_maxbytes = 50MB stdout_logfile_backups = 10 stdout_logfile = /srv/xx/log/app.log因为supervisor不能监控后台进程，所以配置中的command 不能为后台运行命令。如果.py文件中不指定执行环境，例如#!/usr/bin/env python3或#!/srv/xx/venv/bin python3，那command就需要设置完整的指令 /path/python3 /path/xx.py 执行start之前先指定配置的路径（直接使用supervisorctl可能会报错 unix:///var/run/supervisor/supervisor.sock no such file。执行-c 后也免去了start） sudo supervisord -c /etc/supervisord.conf sudo supervisorctl -c /etc/supervisord.conf supervisord 是启动 supervisor 守护进程（类似于 systemd 或 init.d 这种用于托管进程的服务）。supervisorctl 是 supervisord 的命令行控制台，它的其它操作指令还包括 supervisorctl status #查看所有进程的状态 supervisorctl stop es #停止es supervisorctl start es #启动es supervisorctl restart es #重启es supervisorctl update #配置文件修改后可以使用该命令加载新的配置 supervisorctl reload #重新启动配置中的所有程序 ... #es可换成all，管理配置中的所有进程最后开始监听某进程（当然需要在xx进程已开启的状态下进行） $ sudo supervisorctl reload $ sudo supervisorctl start xx $ sudo supervisorctl status xx RUNNING pid 1401, uptime 5:01:343.遇到的问题 1) 如果执行 start 指令时提示spawn error，可以查询日志 tail -20 /var/log/supervisor/supervisord.logExit code 127 一般意味着找不到指令，对command中的指令添加绝对路径。也可能是配置没重加载成功，可尝试重启supervisord进程（可参考下一点问题解决办法） 2) 如果执行 supervisord -c 时，提示以下错误：Error: Another program is already listening on a port that one of our HTTP servers is configured to use. Shut this program down first before starting supervisord. 一般是进程已经打开过，杀掉进程重试即可 ps -ef | grep supervisord kill -s SIGTERM pid3) 如果执行 start 指令时提示 file is not executable，则可能是权限问题，修改启动文件的权限 chmod chmod a+x app.py 即可。 配置Nginx把配置文件xx放到/etc/nginx/sites-available/目录下（一般是在copy default文件的基础上修改。如果和default监听一样的端口等设置，则需要将default删除，保持一个应用一个配置，其中监听的端口等设置必须各不一样） server &#123; listen 80; #监听80端口 root /srv/xx/www; access_log /srv/xx/log/access_log; error_log /srv/xx/log/error_log; # server_name x.xx.com; # 配置域名 # 处理静态文件 /favicon.ico; location /favicon.ico &#123; root /srv/xx/www &#125; # 处理静态资源 location ~ ^\/static\/.*$ &#123; root /srv/xx/www &#125; # 动态请求转发到9000端口 location / &#123; proxy_pass http://127.0.0.1:9000; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for &#125; &#125; 然后在/etc/nginx/sites-enabled/目录下创建软链接 sudo ln -s /etc/nginx/sites-available/xx让Nginx重新加载配置文件，webapp应该就能正常运行 sudo /etc/init.d/nginx reload sudo service nginx restart # 或通过service重启nginx既可做正向代理，也可做反向代理（反向代理简单来说，就是像客户端访问80端口，帮你定位到9000端口，这样的转发功能），以上例子中相关的参数如下 X-Forwarded-For，是用于记录代理信息的，每经过一级代理(匿名代理除外)，代理服务器都会把这次请求的来源IP追加在X-Forwarded-For中 X-Real-IP，只记录真实发出请求的客户端IP 参考使用 supervisor 管理进程Nginx 配置详解部署Web App]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>服务器</tag>
        <tag>Web App</tag>
        <tag>nginx</tag>
        <tag>supervisor</tag>
        <tag>fabric</tag>
        <tag>python</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客图床]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[做了自己图床后，写博客真的变得倍爽。过程说复杂称不上，但也耗费了一定的时间，为避免日后遗忘了而又需要重新搭建时能省点心，还是记录一下吧。 准备工具 ICP的域名 七牛云存储器 MWeb 配置步骤申请域名的ICP在阿里云购买域名后，还需购买云服务器ECS(至少买3个月)和外网IP的服务后，因为ICP需要这3样内容，但域名无需有实质性的绑定（当时我的域名绑在github page上，而ECS则需要和IP先关联了）。 在他们家进行ICP的申请很方便，可以到他们官方的帮助中心查看具体申请流程。 阿里云方面初审时因为站名、备注不符合要求被拒过一次，重新提交后几天工作日就过审了。 有效期听说是没有限制，暂时还不知域名、ECS和IP过期不续约的话ICP是否会失效。 插个题外话，如果是用作Hexo的博客，可以直接在footer.swig文件（有的扩展名是.ejs，位于Path/to/blog/themes/hexo/layout/_partial）上的&lt;/span&gt;跟&lt;/div&gt;之间加上个简单的&lt;a href=&quot;http://www.miitbeian.gov.cn/&quot;&gt;粤ICP备xxx号&lt;/a&gt;。 配置七牛云服务器在七牛创建个人的对象存储服务器后，对其配置融合CDN加速域名，将你个人的ICP域名映射到七牛的二级域名上（同时需在阿里云的域名管理上配置其CNAME）。 然后获取你七牛服务器的AK和SK备用。 注意，七牛上免费的存储空间 10GB，每月下载流量 10GB，每月 PUT/DELETE 10 万次请求，每月 GET 100 万次请求。 配置MWeb七牛上传文件的API地址，根据你存储服务器配置的地区选择正确的API地址。 然后在MWeb的偏好设置里的发布服务上如下配置 最后你只要将本地图片拖入你编辑状态下的md文档里就能自动生成好md的图片格式和外链(你所配置的域名+文件名路径)。 如果没生成外链，而是放入一个叫Midea的路径下，则可以通过菜单栏-发布-将本地图片上传到图床一键将所有文中的所有图片上传，但地址还是要逐个替换..原来从根本上有一个很隐蔽的配置可解决这个问题，如下图红框所示，勾上即可解决没生成外链的问题 更详细的配置说明可参考这篇文章 MWeb还有iOS版，一样非常好用，花60RMB内购解锁icloud/dropbox的同步和发布服务两项便捷功能，如果对这方面需求不大，平时可以通过airdrop分享就能将文档同步到Mac。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android工程入门]]></title>
    <url>%2FAndroid%2FAndroid%E5%B7%A5%E7%A8%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[深入了解很多Android工程上的内容时，产生了很多疑惑，由于时间实在分不开来，本身没有先系统地学习，都是针对不懂的查查问问，所以这里算是来一个Android工程入门的杂谈吧（其实叫杂烩比较合乎），记录一些收集到的原理和方法、一些自己的观点和遇到的问题。 工程结构Project与Module的区别Project相当于Eclipse里面的工作区间，Module相当于Eclipse里面的project。AS里面的项目结构也可以像Eclipse一样，一个Project新建多个Module。 一般的组件化管理下，都会在Project中建多个板块功能Module，App也作为其中一个Module来管理。Project中的build.gradle具有全局性，若Module的build.gradle与Project的有重复且冲突项，则以Project的为准。 第三方库引用 project structure-&gt;app-&gt;Dependencies-&gt;”+”-&gt;Library dependency-&gt;Search-&gt;OK(自动build) 切换为Project树结构-&gt;app/libs-&gt;放入jar包-&gt;Build project structure-&gt;app-&gt;Dependencies-&gt;”+”-&gt;Module dependency-&gt;选择Module-&gt;OK(自动build) build.gradle(Module:app)-&gt;dependencies-&gt;compile/implementation ‘package:name:ver’ 复制各架构的so到app/libs-&gt;build.gradle(Module:app)添加sourceSets {main {jniLibs.srcDirs =[‘libs’]}}-&gt;Build 直接复制各架构的so到app/src/main/jniLibs Gradle语法上是基于Groovy语言（基于JVM的敏捷开发语言，可以简单的理解为强类型语言Java的弱类型版本），在项目管理上是基于Ant(Java编译器)和Maven概念的项目自动化建构工具。 Android多Moudule（也就是gradle中的多Project Multi-Projects Build）的基本项目结构： ├── app #Android App目录 │ ├── app.iml │ ├── build #构建输出目录 │ ├── build.gradle #构建脚本 │ ├── libs #so相关库 │ ├── proguard-rules.pro #proguard混淆配置 │ └── src #源代码，资源等 ├── module #Android 另外一个module目录 │ ├── module.iml │ ├── build #构建输出目录 │ ├── build.gradle #构建脚本 │ ├── libs #so相关库 │ ├── proguard-rules.pro #proguard混淆配置 │ └── src #源代码，资源等 ├── build │ └── intermediates ├── build.gradle #工程构建文件 ├── gradle │ └── wrapper ├── gradle.properties #gradle的配置 ├── gradlew #gradle wrapper linux shell脚本 ├── gradlew.bat ├── LibSqlite.iml ├── local.properties #配置Androod SDK位置文件 └── settings.gradle #工程配置 Gradle多个Project的例子： ├── app │ ├── build.gradle #构建脚本 ├── module │ ├── build.gradle #构建脚本 ├── build.gradle #工程构建文件 ├── gradle │ └── wrapper #先不去管它 ├── gradle.properties #gradle的配置 ├── gradlew #gradle wrapper linux shell脚本 ├── gradlew.bat └── settings.gradle #工程配置 build.gradle是Gradle默认的构建脚本文件，执行Gradle命令的时候，会默认加载当前目录下的build.gradle脚本文件。 每次构建至少由一个project构成，一个project由一到多个task构成。项目结构中的每个build.gradle文件代表一个project，在这编译脚本文件中可以定义一系列的task；task 本质上又是由一组被顺序执行的Action对象构成，Action其实是一段代码块，类似于Java中的方法。 执行流程 和Maven一样，Gradle只是提供了构建项目的一个框架，真正起作用的是Plugin。 Gradle在默认情况下为我们提供了许多常用的Plugin，其中包括有构建Java项目的Plugin，还有Android等。 与Maven不同的是，Gradle不提供内建的项目生命周期管理，只是java Plugin向Project中添加了许多Task，这些Task依次执行，为我们营造了一种如同Maven般项目构建周期。 Gradle是一种声明式的构建工具。在执行时，Gradle并不会一开始便顺序执行build.gradle文件中的内容，而是分为两个阶段，第一个阶段是配置阶段，然后才是实际的执行阶段。 配置阶段，Gradle将读取所有build.gradle文件的所有内容来配置Project和Task等，比如设置Project和Task的Property，处理Task之间的依赖关系等。 Gradle为每个build.gradle都会创建一个相应的Project领域对象，在编写Gradle脚本时，我们实际上是在操作诸如Project这样的Gradle领域对象。在多Project的项目中，我们会操作多个Project领域对象。Gradle提供了强大的多Project构建支持。 要创建多Project的Gradle项目，我们首先需要在根（Root）Project中加入名为settings.gradle的配置文件，该文件应该包含各个子Project的名称。Gradle中的Project可以简单的映射为AndroidStudio中的Module。 在最外层的build.gradle。一般干得活是：配置其他子Project的。比如为子Project添加一些属性。 每次构建的执行本质上是执行一系列的task，并且某些task还需要依赖其他task，这些task的依赖关系都是在构建阶段确定的。每次构建分为3个阶段： Initialization: 初始化阶段 这是创建Project阶段，构建工具根据每个build.gradle文件创建出一个Project实例。初始化阶段会执行项目根目录下的settings.gradle文件，来分析哪些项目参与构建。 Configuration:配置阶段 这个阶段，通过执行构建脚本来为每个project创建并配置Task。配置阶段会去加载所有参与构建的项目的build.gradle文件，会将每个build.gradle文件实例化为一个Gradle的project对象。然后分析project之间的依赖关系，下载依赖文件，分析project下的task之间的依赖关系。 Execution:执行阶段 这是Task真正被执行的阶段，Gradle会根据依赖关系决定哪些Task需要被执行，以及执行的先后顺序。task是Gradle中的最小执行单元，我们所有的构建，编译，打包，debug，test等都是执行了某一个task，一个project可以有多个task，task之间可以互相依赖。例如我有两个task，taskA和taskB，指定taskA依赖taskB，然后执行taskA，这时会先去执行taskB，taskB执行完毕后在执行taskA。在AS右侧的Gradle按钮中可以看到这一些列的task build.gradle文件分析apply plugin: &apos;com.android.application&apos; android &#123; compileSdkVersion 25 buildToolsVersion &quot;25.0.0&quot; defaultConfig &#123; applicationId &quot;me.febsky.demo&quot; minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125; &#125; dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:25.1.0&apos; &#125; 方法调用，圆括号可以省略 如果方法参数是个Map，方括号可以省略 闭包作为函数的最后一个参数，可以在括号内或括号外，没括号时不用关注 Groovy动态的为每一个字段都会自动生成getter和setter，并且我们可以通过像访问字段本身一样调用getter和setter。 所以上面的apply plugin: &#39;com.android.application&#39;，可以看成是apply([plugin: &#39;com.android.application&#39;]) Gradle的Project之间的依赖关系是基于Task的，而不是整个Project的。 Project:是Gradle最重要的一个领域对象，我们写的build.gradle脚本的全部作用，其实就是配置一个Project实例。在build.gradle脚本里，我们可以隐式的操纵Project实例，比如，apply插件、声明依赖、定义Task等，如上面build.gradle所示。apply、dependencies、task等实际上是Project的方法，参数是一个代码块。如果需要，也可以显示的操纵Project实例，比如：project.ext.myProp = ‘myValue’ Task:Gradle中的Task要么是由不同的Plugin引入的，要么是我们自己在build.gradle文件中直接创建的。Gradle保证Task按照依赖顺序执行，并且每个Task最多只被执行一次。 dependencies:在Project的gradle dependencies 中使用classpath一般是指添加buildscript本身需要运行的东西。buildScript是用来加载gradle脚本自身需要使用的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等。 在App的gradle dependencies 中添加应用程序所需要的依赖包，也就是项目运行所需要的东西。 项目根目录的 build.gradle 文件：用来配置针对所有模块的一些属性。它默认包含2个代码块：buildscript{…}和allprojects{…}。前者用于配置构建脚本所用到的代码库和依赖关系，后者用于定义所有模块需要用到的一些公共属性 settings.gradle 文件：会在构建的 initialization 阶段被执行，它用于告诉构建系统哪些模块需要包含到构建过程中。对于单模块项目， settings.gradle 文件不是必需的。对于多模块项目，如果没有该文件，构建系统就不能知道该用到哪些模块。 模块级配置文件 build.gradle ：针对每个moudle 的配置，如果这里的定义的选项和顶层 build.gradle定义的相同。它有3个重要的代码块：plugin，android 和 dependencies。 Task示例task myTask &#123; doFirst &#123; println &apos;hello&apos; &#125; doLast &#123; println &apos;world&apos; &#125; &#125; 这段代码的含义是给Project添加一个名为“myTask”的任务。用一个闭包来配置这个任务，Task提供了doFirst和doLast方法来给自己添加Action。 其实build.gradle脚本的真正作用，就是配置一个Project实例。在执行build脚本之前，Gradle会为我们准备好一个Project实例，执行完脚本之后，Gradle会按照DAG依次执行任务。 如果task声明在根Project的build.gradle中的allprojects()方法中，那么这个Task会应用于所有的Project。 如果是Muliti-Project的模式，依赖关系要带着所属的Project，如taskA.dependsOn ‘:other-project:taskC’ 其中taskC位于和taskA不同的Project中，相对于AndroidStudio来说，就是位于不同的Module下的build.gradle中，而other-project为Module名字。 其它实现 自定义Plugin：每一个自定义的Plugin都需要实现Plugin接口，除了给Project编写Plugin之外，我们还可以为其他Gradle类编写Plugin。该接口定义了一个apply()方法，在该方法中，我们可以操作Project，比如向其中加入Task，定义额外的Property等。 Gradle Wrapper：顾名思义，其实就是对Gradle的一层包装，便于在团队开发过程中统一Gradle构建的版本，然后提交到git上，然后别人可以下载下来，这样大家都可以使用统一的Gradle版本进行构建，避免因为Gradle版本不统一带来的不必要的问题。（所以要明白这个东西可以没有，有了只是为了统一管理，更加方便） 子Module的依赖展开：这样做的目的是为给其它子Module或者给父Project也能引用存在于当前子Module中的依赖libs。在根工程（即父Project）下的build.gradle中添加如下代码，核心部分是repositories中的flatDir allprojects &#123; repositories &#123; jcenter() flatDir &#123; dirs project(&apos;:sub_module&apos;).file(&apos;libs&apos;) &#125; &#125; &#125; 相关函数Gradle plugin 3.0依赖方式增加了 implementation 和 api ，用以取代 compile。有工程 A、B、C.让 A 依赖 B (implementation、api 都可以)。若B implementation C，则A 不能调用 C 的方法。若 B api C，则A 可以调用 C 的方法(同 compile)。 Maven抽取公共Gradle的实现 在组件化的环境上应用Maven时，应将各个Module共有的关于Maven的配置和gradle脚本实现抽取。 上图是将公共的Maven配置和脚本进行入库，每个Module需要应用Maven时就从git上clone它下来作为当前Module的子模块。 maven_user.properties是存放通用的Maven配置（像Maven仓库的地址、帐密等），而maven_pom.properties是存放Module的Maven配置（可在工程中直接新建一个File，自定义后缀为.properties即可创建，包括像Module名称、描述、Maven组ID、打包方式、版本号等） 工程导入这些gradle脚本后，像图中右侧的gradle栏中就会出现相关Task，包括默认的和自定义的（upload-uploadArchives就是maven_push.gradle中定义和实现的） ProGuard是AS SDK里自带的工具，主要作用是混淆代码，但包括以下4个功能： 压缩(Shrink)：检测并移除代码中无用的类、字段、方法和特性（Attribute）。 优化(Optimize)：对字节码进行优化，移除无用的指令。 混淆(Obfuscate)：使用a，b，c，d这样简短而无意义的名称，对类、字段和方法进行重命名。 预检(Preveirfy)：在Java平台上对处理后的代码进行预检，确保加载的class文件是可执行的。 压缩环节会检测以及移除没有用到的类、字段、方法以及属性。优化环节会分析以及优化方法的字节码。混淆环节会用无意义的短变量去重命名类、变量、方法。这些步骤让代码更精简，更高效，也更难被逆向（破解）。 工作原理ProGuar由shrink、optimize、obfuscate和preveirfy四个步骤组成，每个步骤都是可选的，我们可以通过配置脚本来决定执行其中的哪几个步骤。 混淆就是移除没有用到的代码，然后对代码里面的类、变量、方法重命名为人可读性很差的简短名字。那么有一个问题，ProGuard怎么知道这个代码没有被用到呢？这里引入一个Entry Point（入口点）概念，Entry Point是在ProGuard过程中不会被处理的类或方法。在压缩的步骤中，ProGuard会从上述的Entry Point开始递归遍历，搜索哪些类和类的成员在使用，对于没有被使用的类和类的成员，就会在压缩段丢弃，在接下来的优化过程中，那些非Entry Point的类、方法都会被设置为private、static或final，不使用的参数会被移除，此外，有些方法会被标记为内联的，在混淆的步骤中，ProGuard会对非Entry Point的类和方法进行重命名。那么这个入口点怎么来呢？就是从ProGuard的配置文件来，只要这个配置了，那么就不会被移除。 编写ProGuard文件的步骤： 基本混淆 针对APP的量身定制 针对第三方jar包的解决方案 基本混淆混淆文件的基本配置信息，任何APP都要使用，可以作为模板使用1.基本指令 # 代码混淆压缩比，在0和7之间，默认为5，一般不需要改 -optimizationpasses 5 # 混淆时不使用大小写混合，混淆后的类名为小写 -dontusemixedcaseclassnames # 指定不去忽略非公共的库的类 -dontskipnonpubliclibraryclasses # 指定不去忽略非公共的库的类的成员 -dontskipnonpubliclibraryclassmembers # 不做预校验，preverify是proguard的4个步骤之一 # Android不需要preverify，去掉这一步可加快混淆速度 -dontpreverify # 有了verbose这句话，混淆后就会生成映射文件 # 包含有类名-&gt;混淆后类名的映射关系 # 然后使用printmapping指定映射文件的名称 -verbose -printmapping proguardMapping.txt # 指定混淆时采用的算法，后面的参数是一个过滤器 # 这个过滤器是谷歌推荐的算法，一般不改变 -optimizations !code/simplification/arithmetic,!field/*,!class/merging/* # 保护代码中的Annotation不被混淆，这在JSON实体映射时非常重要，比如fastJson -keepattributes *Annotation* # 避免混淆泛型，这在JSON实体映射时非常重要，比如fastJson -keepattributes Signature //抛出异常时保留代码行号，在异常分析中可以方便定位 -keepattributes SourceFile,LineNumberTable -dontskipnonpubliclibraryclasses用于告诉ProGuard，不要跳过对非公开类的处理。默认情况下是跳过的，因为程序中不会引用它们，有些情况下人们编写的代码与类库中的类在同一个包下，并且对包中内容加以引用，此时需要加入此条声明。 -dontusemixedcaseclassnames，这个是给Microsoft Windows用户的，因为ProGuard假定使用的操作系统是能区分两个只是大小写不同的文件名，但是Microsoft Windows不是这样的操作系统，所以必须为ProGuard指定-dontusemixedcaseclassnames选项 2.保留 # 保留所有的本地native方法不被混淆 -keepclasseswithmembernames class * &#123; native &lt;methods&gt;; &#125; # 保留了继承自Activity、Application这些类的子类 # 因为这些子类，都有可能被外部调用 # 比如说，第一行就保证了所有Activity的子类不要被混淆 -keep public class * extends android.app.Activity -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference -keep public class * extends android.view.View -keep public class com.android.vending.licensing.ILicensingService # 如果有引用android-support-v4.jar包，可以添加下面这行 -keep public class com.xxxx.app.ui.fragment.** &#123;*;&#125; # 保留在Activity中的方法参数是view的方法， # 从而我们在layout里面编写onClick就不会被影响 -keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View); &#125; # 枚举类不能被混淆 -keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String); &#125; # 保留自定义控件（继承自View）不被混淆 -keep public class * extends android.view.View &#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); &#125; # 保留Parcelable序列化的类不被混淆 -keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *; &#125; # 保留Serializable序列化的类不被混淆 -keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); &#125; # 对于R（资源）下的所有类及其方法，都不能被混淆 -keep class **.R$* &#123; *; &#125; # 对于带有回调函数onXXEvent的，不能被混淆 -keepclassmembers class * &#123; void *(**On*Event); &#125; 3.定制 # 保留实体类和成员不被混淆(对于实体，保留它们的set和get方法，对于boolean型get方法，有人喜欢命名isXXX的方式) -keep public class com.xxxx.entity.** &#123; public void set*(***); public *** get*(); public *** is*(); &#125; # 保留内嵌类不被混淆(内嵌类经常会被混淆，结果在调用的时候为空就崩溃了，最好的解决方法就是把这个内嵌类拿出来，单独成为一个类。如果一定要内置，那么这个类就必须在混淆的时候保留，$符号用来分割内嵌类与其母体的标志。) -keep class com.example.xxx.MainActivity$* &#123; *; &#125; # 对WebView的处理 -keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String) &#125; -keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, java.lang.String) &#125; # 保留JS方法不被混淆（JSInterface是MainActivity的子类） -keepclassmembers class com.example.xxx.MainActivity$JSInterface1 &#123; &lt;methods&gt;; &#125; 4.处理反射在程序中使用SomeClass.class.method这样的静态方法，在ProGuard中是在压缩过程中被保留的，那么对于Class.forName(“SomeClass”)呢，SomeClass不会被压缩过程中移除，它会检查程序中使用的Class.forName方法，对参数SomeClass法外开恩，不会被移除。但是在混淆过程中，无论是Class.forName(“SomeClass”)，还是SomeClass.class，都不能蒙混过关，SomeClass这个类名称会被混淆，因此，我们要在ProGuard.cfg文件中保留这个类名称。在混淆的时候，要在项目中搜索一下上述方法，将相应的类或者方法的名称进行保留而不被混淆。 Class.forName(&quot;SomeClass&quot;) SomeClass.class SomeClass.class.getField(&quot;someField&quot;) SomeClass.class.getDeclaredField(&quot;someField&quot;) SomeClass.class.getMethod(&quot;someMethod&quot;, new Class[] &#123;&#125;) SomeClass.class.getMethod(&quot;someMethod&quot;, new Class[] &#123; A.class &#125;) SomeClass.class.getMethod(&quot;someMethod&quot;, new Class[] &#123; A.class, B.class &#125;) SomeClass.class.getDeclaredMethod(&quot;someMethod&quot;, new Class[] &#123;&#125;) SomeClass.class.getDeclaredMethod(&quot;someMethod&quot;, new Class[] &#123; A.class &#125;) SomeClass.class.getDeclaredMethod(&quot;someMethod&quot;, new Class[] &#123; A.class, B.class &#125;) AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, &quot;someField&quot;) AtomicLongFieldUpdater.newUpdater(SomeClass.class, &quot;someField&quot;) AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, &quot;someField&quot;) 5.自定义View但凡在Layout目录下的XML布局文件配置的自定义View，都不能进行混淆。为此要遍历Layout下的所有的XML布局文件，找到那些自定义View，然后确认其是否在ProGuard文件中保留。有一种思路是，在我们使用自定义View时，前面都必须加上我们的包名，比如com.a.b.customeview，我们可以遍历所有Layout下的XML布局文件，查找所有匹配com.a.b的标签即可。 第三方jar包我们在Android项目中不可避免要使用很多第三方提供的SDK，一般而言，这些SDK是经过ProGuard混淆的，而我们所需要做的就是避免这些SDK的类和方法在我们APP被混淆。1.针对android-support-v4.jar的解决方案 # 针对android-support-v4.jar的解决方案 -libraryjars libs/android-support-v4.jar -dontwarn android.support.v4.** -keep class android.support.v4.** &#123; *; &#125; -keep interface android.support.v4.app.** &#123; *; &#125; -keep public class * extends android.support.v4.** -keep public class * extends android.app.Fragment 2.其他的第三方jar包的解决方案取决于第三方包的混淆策略，一般都有在各自的SDK中有关于混淆的说明文字，比如支付宝，值得注意的是，不是每个第三方SDK都需要-dontwarn 指令，这取决于混淆时第三方SDK是否出现警告，需要的时候再加上。 # 对alipay的混淆处理 -libraryjars libs/alipaysdk.jar -dontwarn com.alipay.android.app.** -keep public class com.alipay.** &#123; *; &#125; 注意事项1.如何确保混淆不会对项目产生影响测试工作要基于混淆包进行，才能尽早发现问题每天开发团队的冒烟测试，也要基于混淆包发版前，重点的功能和模块要额外的测试，包括推送，分享，打赏 2.打包时忽略警告当导出包的时候，发现很多could not reference class之类的warning信息，如果确认App在运行中和那些引用没有什么关系，可以添加-dontwarn 标签，就不会提示这些警告信息了 3.对于自定义类库的混淆处理比如我们引用了一个叫做AndroidLib的类库，我们需要对Lib也进行混淆，然后在主项目的混淆文件中保留AndroidLib中的类和类的成员。 4.使用annotation避免混淆另一种类或者属性被混淆的方式是，使用annotation @keep @keepPublicGetterSetters public class Bean&#123; public boolean booleanProperty; public int intProperty; public String stringProperty; &#125; 5.在项目中指定混淆文件到最后，发现没有介绍如何在项目中指定混淆文件。在项目中有一个project.properties文件，在其中写这么一句话，就可以确保每次手动打包生成的apk是混淆过的。proguard.config=proguard.cfg其中，proguard.cfg是混淆文件的名称。 NativeJNI 定义：Java Native Interface，即 Java本地接口 作用：使得Java与本地其他类型语言（如C、C++）交互，即在Java代码里调用C、C++等语言的代码或C、C++代码调用 Java 代码 特性： JNI是Java调用Native语言的一种特性 JNI是属于Java的，与Android无直接关系 实现： 在Java中声明Native方法（即需要调用的本地方法） 编译上述Java源文件javac（得到 .class文件） 通过javah命令导出JNI的头文件（.h文件） 使用Java需要交互的本地代码实现在Java中声明的Native方法，如Java需要与C++交互，那么就用C++实现Java的Native方法 编译.so库文件 通过Java命令执行 Java程序，最终实现Java调用本地代码 在JNI_OnLoad中注册 jint JNI_OnLoad(JavaVM* vm, void* reserved) &#123; //添加JNINativeMethod方法 static const JNINativeMethod gMethods[] = &#123; &#123;&quot;getUrl&quot;, &quot;()Ljava/lang/String;&quot;, (jstring*)getUrl&#125;, &#123;&quot;setData&quot;,&quot;([BI)V&quot;,(void*)setData&#125; &#125;; //注册 static string className = &quot;path/to/className&quot;; gJavaVM = vm; JNIEnv* env = NULL; if ((*vm)-&gt;GetEnv(vm, (void**) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123; return -1; &#125; assert(env != NULL); jclass clazz = (*env)-&gt;FindClass(env, className); if (clazz == NULL) &#123; return -1; &#125; if ((*env)-&gt;RegisterNatives(env, clazz, gMethods, numMethods) &lt; 0) &#123; return -1; &#125; return JNI_VERSION_1_6; &#125; 返回值及参数类型的通配说明 NDK 定义：Native Development Kit，是 Android的一个工具开发包，NDK是属于Android的，与Java并无直接关系 作用：快速开发C、C+ * 作用：快速开发C、C+ * 作用：快速开发C、C++的动态库，并自动将so和应用一起打包成APK。即可通过NDK在Android中使用JNI与本地代码（如C、C++）交互 实现： 配置Android NDK环境 创建Android项目，并与NDK进行关联 在Android 项目中声明所需要调用的Native方法 使用Android需要交互的本地代码实现在Android中声明的Native方法，比如 Android 需要与C++交互，那么就用C++实现Java的Native方法 通过 ndk - bulid 命令编译产生.so库文件 编译 Android Studio工程，从而实现Android 调用本地代码 Gradle的配置Module的gradle文件: apply plugin: &apos;com.android.library&apos; apply from: &quot;$&#123;project.rootDir&#125;/config/maven_push.gradle&quot; android &#123; compileSdkVersion 28 buildToolsVersion &quot;28.0.3&quot; defaultConfig &#123; minSdkVersion 14 targetSdkVersion 28 ndk&#123; moduleName &quot;framework&quot; &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false//缩减字符的混淆-针对java层 &#125; &#125; ... &#125; task clearJar(type: Delete) &#123; delete &quot;build/outputs/libs/&quot; &#125; def getVersionName() &#123; return project.ext.mCurVersion &#125; task makeJar(type: ProGuardTask, dependsOn: &quot;build&quot;) &#123; // 未混淆的jar路径 injars &apos;build/intermediates/packaged-classes/release/classes.jar&apos; // 混淆后的jar输出路径 outjars &quot;build/outputs/libs/efun-utils-$&#123;getVersionName()&#125;.jar&quot; // 混淆协议 configuration &apos;proguard-rules.pro&apos; &#125; task makeJar(type: Copy) &#123; from(&apos;build/intermediates/packaged-classes/release/&apos;) into(&apos;build/outputs/libs/&apos;) include(&apos;classes.jar&apos;) rename (&apos;classes.jar&apos;, &quot;efun-task-$&#123;getVersionName()&#125;.jar&quot;) &#125; ext.ndk = &apos;ndk&apos; task localProperty &#123; //注意：指定NDK实质路径是通过local.properties文件中的为准（也可以在project struct中设置-cmd+;） ndk = &quot;/Path/to/android-ndk-r18b/ndk-build&quot; &#125; task buildJni &lt;&lt; &#123; System.out.println(&quot;ndk:&quot;+ndk); exec &#123; commandLine ndk &#125; &#125; preBuild.dependsOn buildJni Make的配置在Linux下编译经常要写一个Makefile文件， 可以把这个Makefile文件理解成一个编译配置文件，它保存着如何编译的配置信息，即指导编译器如何来编译程序，并决定编译的结果是什么。 而Android.mk文件是针对Android的Makefile文件，该文件是GNU Makefile的一小部分，会被编译系统解析一次或多次。可以在每一个Android.mk file中定义一个或多个模块，你也可以在几个模块中使用同一个源代码文件。编译系统为你处理许多细节问题。 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog LOCAL_MODULE := efunframework-3.0 LOCAL_SRC_FILES := certificate.c \ md5.c \ secret_key.c \ include $(BUILD_SHARED_LIBRARY) 首先必须定义好LOCAL_PATH变量。然后清除所有LOCAL_XX变量的值。 宏函数my-dir, 由编译系统提供，用于返回当前路径（即包含Android.mk file文件的目录）。 宏CLEAR_VARS由编译系统提供，指定让GNU MAKEFILE为你清除许多LOCAL_XXX变量，因为所有的编译控制文件都在同一个GNU MAKE执行环境中，所有的变量都是全局的。 LOCAL_SRC_FILES:是本次需要编译的源文件。 LOCAL_SHARED_LIBRARIES:是本次编译需要链接的动态链接库文件，即.so文件。 LOCAL_STATIC_LIBRARIES:是本次编译要链接的静态链接库。 LOCAL_LDLIBS:是本次编译的链接选项，相当于gcc -l后的参数。 LOCAL_CFLAGS:同样是编译选项，相当于gcc -O后面的参数。 LOCAL_MODULE:是生成的模块名，这个变量必须定义，表示make后将要生成的文件的名字。 include:多以这样的形式出现，如:include $( CLEAR_VARS)、include $(BUILD_SHARED_LIBRARY)，其实这个include可以理解成”执行”的意思，比如清除一些变量、生成共享库，即生成.so文件。 AAR &amp; JAR使用Android Studio对工程进行编译后，会同时生成jar与aar文件。 位置jar: /build/intermediates/bundles/debug(release)/classes.jar aar: /build/outputs/aar/libraryname.aar 区别 jar 中只包含了class文件与清单文件。 aar中除了包含jar中的class文件还包含工程中使用的所有资源，class及res资源文件全部包含。 如果只是一个简单的类库那么使用生成的* .jar文件即可；如果你的是一个UI库，包含一些自己写的控件布局文件以及字体等资源文件那么就只能使用*.aar文件。 使用jar 拷贝到 libs 目录，并在gradle文件中添加 dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) implementation fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) //gradle 3.0+ &#125; aar 有两种方式： 本地使用：拷贝到libs目录，并在gradle文件中添加 repositories &#123; flatDir &#123; dirs &apos;libs&apos; &#125; &#125; dependencies &#123; compile(name:&apos;genius&apos;, ext:&apos;aar&apos;) &#125; 网络加载：将aar发布到mavenCentral仓库，在gradle文件中添加 repositories &#123; maven &#123; url &quot;http://xxx.com/project&quot; &#125; &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.2.1&apos; &#125; 多层Module依赖本地AARAndroid Studio多层Module依赖本地AAR，在编译的时候出发生错误，找不到AAR（ModuleA libs中有c.aar，ModuleB依赖ModuleA）此时需要在ModuleB的build.gradle中添加 repositories &#123; flatDir &#123; dirs &apos;../ModuleA/libs&apos;,&apos;libs&apos; &#125; &#125; 同时在dependencies中添加aar名称 compile(name:&apos;c&apos;, ext:&apos;aar&apos;) so加固so：shared object，即是由系统动态加载的共享目标文件。 破坏ELF header或者删除Section header 对要保护的so函数或者section进行加密，把解密函数放到另外一个so中 自定义的section并加密，load so库时在main函数之前把自定义section解密 NDK编译工具中可以集成LLVM-Obfuscator，需要修改交叉工具链的代码和一些配置参数，混淆代码 实现参考 JVMjava -server -Xms3550M -Xmx3550M -XX:ReservedCodeCacheSize=1024m -jar apktool_2.4.0.jar b ‘Path/to/unzip/document’ -client，-server这两个参数用于设置虚拟机使用何种运行模式，client模式启动比较快，但运行时性能和内存管理效率不如server模式，通常用于客户端应用程序。相反，server模式启动比client慢，但可获得更高的运行性能。在 windows上，缺省的虚拟机类型为client模式，如果要使用 server模式，就需要在启动虚拟机时加-server参数，以获得更高性能，对服务器端应用，推荐采用server模式，尤其是多个CPU的系统。在 Linux，Solaris上缺省采用server模式。 -Xms设置虚拟机可用内存堆的初始大小，缺省单位为字节，该大小为1024的整数倍并且要大于1MB，可用k(K)或m(M)为单位来设置较大的内存数。初始堆大小为2MB。例如：-Xms6400K，-Xms256M -Xmx设置虚拟机内存堆的最大可用大小，缺省单位为字节。该值必须为1024整数倍，并且要大于2MB。可用k(K)或m(M)为单位来设置较大的内存数。缺省堆最大值为64MB。例如：-Xmx81920K，-Xmx80M当应用程序申请了大内存运行时虚拟机抛出java.lang.OutOfMemoryError: Java heap space错误，就需要使用-Xmx设置 The -X options are non-standard and subject to change without notice.输入指令 java -X 查看 https://xinklabi.iteye.com/blog/837435 问题集 error=13, Permission denied 在Mac的Android Studio IDE上，若提示该错误，可针对提示中的问题路径修改访问权限chmod +x /Users/MyUserName/Library/Android/sdk/tools/androidchmod +x /Users/MyUserName/PathTo/Android/android-ndk-r18b You have not accepted the license agreements of the following SDK components 自动同意所有下载的SDK的license即可解决，yes | sdkmanager –licensesyes | sudo ~/Library/Android/sdk/tools/bin/sdkmanager –licenses]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>Module</tag>
        <tag>ProGuard</tag>
        <tag>Native</tag>
        <tag>JNI</tag>
        <tag>NDK</tag>
        <tag>AAR</tag>
        <tag>JAR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队管理实践]]></title>
    <url>%2F%E7%AE%A1%E7%90%86%2F%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[管理理论定义管理的定义：界定企业的使命，并激励和组织人力资源去实现这个使命。 核心本质是最大范围地激发他人的善意。 管理 = 正确决策 + 100%服从意识 = (目标 + 组织) + 激励善意执行。 团队及个人类型团队的类型 棒球队：各司其职，非团队组合 足球队：有分工有协作，目的一致 网球队：灵活分工，要求严格的团队 首先需要认清组员所属的团队类型，如果团队要转变必须突变，而不能渐变。棒球队员不需要、也不喜欢太多跟别人配合，网球员追求最紧密的团队融合，足球队员前锋知道回防后卫知道助攻。 安排原则不是绝对得对号入座，可以安排一些对于现有角色起锻炼作用的任务（双打网球）来互补他的意识。 个人的角色 管理者：通过他人完成工作，核心责任培养他人成长； 领导者：营造氛围提高绩效，创造激励，提升企业文化； 执行者：出结果。 每个人身上都有以上三种角色。 目标只有协同工作不是团队，团队一定是目标致力于业绩。 平衡矛盾要平衡好个人主义和团队的矛盾： 容纳个人的不同与集体一致的目标； 鼓励团队成员间的相互支持和对抗； 业绩与学习发展； 管理者权威与成员的判断力和自治力； “1358”管理精髓：关于管理的一个定义、管理的三大任务、管理者的五项工作和企业需要设定目标的八大领域。 秘籍及禁忌SMART大目标拆成阶段小目标营造公平的团队氛围，明确团队制度 如果说目标导向的绩效考核是看得见的手，那么公平的团队氛围和制度化的制度，就是另外一只看不见的手。制度的发挥杠杆效应和持续效应的作用，能让你的团队持续科学的高效工作。 成就激励、责任给予、信任、尊重认同、安全承诺、自由与授权、相对公平、个人公平、发展空间。帮助成员成长 系统的稳定性是建立在子系统的不稳定性之上，大型组织最大的问题就是脆弱性变得极强，越复杂的组织脆弱性越强。 复杂都是自下而上的产生，而不是自上而下。沟通反馈 乔哈里视窗-自我意识的发现：开放区、隐蔽区、盲目区、未知区。人的有效沟通就是这四个区域的有机融合； 大家在沟通中一定要注意，非语言沟通的技巧性，在沟通中肢体和态度是远远超过语言的能力的； 设定内部反馈机制：周会(总结)、月末会议。管理团队情绪，学会授权和容忍 学会授权和容忍才能提高团队凝聚力和归属感。 授权后才是管理的开始。出错时要学会容忍，正确时要不要吝啬赞美。要知道，批评时才是最好的拉近你和成员关系的时刻，同时，要管理好团队情绪。 4A模型： 识别情绪(Aware)关注行为变化，识别特征行为； 接受情绪(Accept)接受而不压制，理解四个阶段； 分析情绪(Analyze)找出情绪来源，抓住三种心态； 调整情绪(Adjust)及时坦诚沟通，关注团队目标。向上管理及人才储备 维度划分： 向下—管理下属； 向上—管理上司； 水平—管理平级； 向外—管理顾客、供应商等外部利益相关者； 向内—管理自己。 管理者的禁忌（有效的管理者）： 不矫情骄傲； 不装B； 不装老大； 不做缩头龟； 不指手划脚； 不拖后腿； 不扰乱军心； 不使坏； 不内讧； 不干操蛋事； 不贬低别人； 不各自为政。 模型人岗匹配模型 价值观； 知识技能； 行为能力。 冰山模型 知识、技能；（表达能力、组织能力、决策能力、学习能力） ——-水面上——- 社会角色：态度、价值观；（管理者、专家、教师；合作精神、献身精神） 自我概念；（自信心、乐观精神） 特质、品质；（正直、诚实、责任心） 动机。（成就需求、人际交往需求） 3D+E模型 Do（职责）：岗位职责内容要求； Display（能力）：胜任素质要求；（专业知识、技能要求） Deliver（业绩）：绩效考核指标，岗位绩效表现； Experience（经验）：任职经验要求。 团队成长模型 成立期：礼貌、松散观望、等待、保守、堤防； 冲突期：互相争吵、冲突、问题出现、竞争、拉帮结派； 发展期：有组织、技能增长、问题解决、冲突消除、输入和反馈、有限规则和方法； 成熟期：合作、成熟、高效、灵活、开放、信任。 管理者成长模型 认知自我 领导角色认知 卓越领导力模型 领导风格与管理情境 管理自我 领导素养修炼 性格与领导力 管理团队 团队业绩管理 团队文化建设 员工激励与授权 员工培训辅导 学习型团队建设 人际互动 沟通技巧（中、高级） 高效会议管理 跨部门沟通技巧 管理实践划分团队类型 棒球型： 问题：缺乏共同维护一个“球”的意识，但前提是他们也交流得太少；（yc、lsy） 安排：对接游戏，解决问题，研究；（偶尔安排互补任务-分享研究成果） 足球型： 问题：有维护一个“球”的意识，但只看见自己已知的部分，走不出圈子（tts、hzw、hwx） 安排：开发对框架影响度低的中小型需求项目 网球型： 问题：既知道目标，也知道扩展，灵活变化(yjl、htc)，但可能存在主动性问题(czh) 安排：架构设计、开发涉及面广的功能项目 设定目标 制定团队目标（组长给出规划） 制定个人目标（需切合团队大目标的方向，由个人制定主管复审，不强制但与晋升挂钩） 管理情绪 应用4A模型（包括主管及所有下属，主管还需给下属做指引）； 刻意保持记住，出错需要批判，但要注意忍住个人情绪，做得好要注意赞扬； 打破子系统的稳定性(帮助成长) 末尾淘汰制 末尾的制度：排名维度(上级评、自评、互评)、考察岗(去绩效/降薪)？ 激励 根据个人制定的目标（自定kpi）的价值等级、完成质量及时间、对待结果的态度三方面进行评估，给相应的鼓励奖励。 再划分一层整体利益、奖罚的绑定？ 任命采用人岗匹配模型、冰山模型、3D+E模型评估 自我提升时刻注意管理者成长模型的塑造 制定团队的规则、原则。。。待 REF：怎么才能做好团队管理｜方法论加模型案例]]></content>
      <categories>
        <category>管理</category>
      </categories>
      <tags>
        <tag>Manager</tag>
        <tag>Model</tag>
        <tag>Role</tag>
        <tag>Target</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[效率工具及技巧收录]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2F%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%8A%80%E5%B7%A7%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[转换脑图文件格式nodemind标准格式转换工具/path/to/text-to-freemind /path/to/text.txt &gt; freemind.mmtext.txt里用tab对每行进行缩进，缩进量与行所在类别对应。https://github.com/wbolster/text-to-freemind Google搜索技巧1.搜索到的结果“东拼西凑”，使用””进行完全匹配使用方法：”关键字”，通过给关键字加双引号的方法，得到的搜索结果就是完全按照关键字的顺序来搜。 2.不想要搜索某个关键词，使用-排除关键字使用方法：关键字 -排除关键字 。Tip：-后面没有空格。 3.记不清楚完整的关键词，使用*进行模糊匹配使用方法：关键字 * 关键字 4.只想在某个网站上查找，使用site指定网站使用方法：关键字 site:网址（网址中的域或者路径等也可使用*通配） 5.只想搜索某类型文件，使用filetype指定文件类型使用方法：关键字 filetype:文件类型 6.或逻辑搜索，用 OR使用方法：关键字 OR 关键字 7.未能准确判断关键词，使用 ~ 进行同义词搜索使用方法：关键字 ~排除关键字 8.两个数值间搜索，使用 “.. ”进行搜索使用方法：关键字 10.. 20 。Tip：注意..后跟空格 9.在网页标题、链接和主体中搜索关键词使用方法：intitle: 关键字 / inurl: 关键字 / intext: 关键字 10.搜索相关网站使用方法：related: 网址 11.直接翻译文本使用方法：translate: 关键字 。Tip：只支持中文？]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端服务器概念了解下]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2F%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A6%82%E5%BF%B5%E4%BA%86%E8%A7%A3%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[本文主要是收录些后端节点的概念，通过了解来帮助阅读后端的技术资讯、排查系统问题、项目需求会议整体讨论等情境上可以对后端相关的内容能有一定认知度，思考与自身领域的相关性，而不至于错过一些优秀的思维角度和设计理念、定位问题局限、相关议题参与度低等情况，也可以作为扩充知识面，学习后端的导索。 CGI先看一个普通的网络请求流程： Client -&gt; Web Server -&gt; CGIsClient &lt;- Web Server &lt;- CGIs 在上面的流程中，Web Server：如果是静态页面直接返回响应，如果是动态页面则提取请求信息发送给CGI程序。CGIs：多个通用网关接口(Common Gateway Interface)的进程响应请求； CGI的特性： Http 协议只存在于Web Client和Web Server之间，与CGI程序之间没有任何关系； Web Server与CGI程序之间的数据传输遵循的是CGI规范； Web Server和CGI程序运行在同一个主机上，每个CGI请求Web Server都会fork一个新的CGI程序的进程，等到请求处理完毕则该进程结束； 如果是请求动态页面（至于如何判断是静态页面还是动态页面则是在Web Server中通过正则表达式进行匹配），通过解析该请求携带的信息，并依据CGI规范将这些信息打包到CGI规定的变量中，然后在Web Server中调用OS中对应的CGI程序来解析该CGI请求，然后生成相应的页面返回给Web Server服务器，然后Web Server再将该内容返回给客户端； CGI程序不对Web客户端开放，CGI程序是与OS有关的，需要根据OS的环境使用适当的语言来开发，所以对系统平台的移植不友好，需更改代码或重新编译。 通俗来讲解的话，就是，一个HTTP请求到达一台服务器的80端口(Web Server)的时候，需要有个程序来响应这个请求。所谓HTTP response，其实只是运行一个程序，它的输入是HTTP request header，它的返回是HTTP response。程序运行方式的区别、HTTP request header的传递方式区别就是CGI、WSGI以及其他各种GI的区别。如果是CGI，通常来说是一个web server（例如apache、nginx）接收到请求后，将请求中的HTTP request header按照一定规则设置成环境变量，然后启动一个程序（Python脚本），将stdout的输出（其中包含HTTP response header）当成HTTP response返回给客户端。 FastCGIFastCGI是对CGI的一个从本质上改变的优化。 FastCGI程序只有一个进程来处理CGI请求，而且处理完该请求之后也不会销毁，而是作为守护进程继续运行。 FastCGI程序允许运行在不同的主机之上，而Web Server和FastCGI之间通过TCP连接进行通信，这种方式可以使Web Server和FastCGI程序独立配置和启动，也可以通过负载均衡提高系统的伸缩性和扩展性。 Servlet对于生成动态页面和进行数据的传输，CGI和Servlet是两个可实现的选项。而对于servlet来说，虽然目前Java EE有些式微，但作为实现微服务的前沿框架Spring Boot仍然是建立在Servlet的基础之上。 Servlet运行在一个进程中，对于每个请求则会生成一个单独的线程，由这些独立的线程处理对应的HTTP请求，Servlet执行完毕后不会销毁，而是驻留在内存中直到Servlet Container关闭，以便能随时处理HTTP请求。Servlet是由多个线程处理请求，所以各个请求之间可以进行很容易的进行数据共享。但如果将编译生成的字节码文件移动到另外的主机或者另外的操作系统中，只要是存在JVM就仍然可以运行。 Servlet和JSP两者分工协作，Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。 容器一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。通俗形容：容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。 容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。 容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。 容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。 容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。 Django在容器中，如果是Django跑在uWSGi、unicorn之类的容器里，那么程序是一个常驻进程，web server和Python进程用WSGI协议传递HTTP request header信息，然后返回给用户。如果是Django的dev server，它使用Python自带的wsgiref模块实现了一个简单的HTTP server （django/django/core/servers/basehttp.py at master 路 django/django 路 GitHub），响应HTTP请求。 同样Servlet是受控于另一个由Java实现的容器，Tomcat就是这样一个容器。 容器能为Servlet提供： 通信支持：利用容器提供的方法，你能轻松地让servle与Web服务器对话。 生命周期管理：容器控制着servlet的生与死。它会负责加载类、实例和初始化servlet、调用servlet方法，并使servlet实例能够被垃圾回收。 多线程支持：容器会自动地为它接收的每个servlet请求创建一个新的java线程。针对客户机的请求，如果servlet已经运行完相应的HTTP服务方法，这个线程就会结束（也就是会死掉）。 声明方式实现安全：利用容器，可以使用XML部署描述文件配置（和修改）安全性，而不必将其硬编码写到servlet（或其他）类代码中。 JSP支持：负责把JSP代码翻译成真正的java。 DockerDocker 是世界领先的软件容器平台。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核 的cgroup，namespace，以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。Docke最初实现是基于 LXC. Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 Docker的思想： 集装箱 标准化： ①运输方式 ② 存储方式 ③ API接口 隔离 Docker的基本概念： 镜像（Image） 容器（Container） 仓库（Repository） 使用Docker的优点： Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题；——一致的运行环境 可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间 避免公用的服务器，资源会容易受到其他用户的影响。——隔离性 善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展 可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署 容器与虚拟机的区别：容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， 容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动 。虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。 管理程序允许多个 VM 在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 占用大量空间 。而且 VM 启动也十分缓慢 。 并发量1M带宽到底能容纳多少人同时在线呢？ 对于一台中低端服务器通常支持在线人数最高为2000人左右，而且只适合普通网站建设后的服务器和文字型论坛，不包括图片类、下载类、视频类等。如果是其他类型的网站，那就要考虑更高配置的服务器以及更大的带宽。 “共享宽带”和“独享宽带”在租用服务器时一定要了解“共享宽带”和“独享宽带”的区别。有些服务器的带宽配置是共享带宽或者独享带宽，而共享带宽就是有一定数量的用户在使用，而独享带宽就只有自己在使用，但独享带宽的费用是比独享高出许多。 在线人数的因素1）访问量2）网站类型 如果是出文字的网站（如小说站），1M带宽带动日均5000IP，还勉强。如果是普通网站有图片，有文字、论坛、新闻资讯类型网站大概1M能带1000IP。考虑到高峰期并发，1M高峰期还会卡（假设1000IP同时并发，只有1KB带宽/用户）。 参考公式 支持连接数 = 服务器带宽/页面尺寸大小 打开网站8秒原则 评判用户从服务器下载文件的速度 页面的标准尺寸大小为（假设60KB） 通过计算大致结果是，1Mbps的带宽（服务器的1M带宽最快上下速度能达到1M/s），跟一般家用的带宽稍有区别，支持的连接数为：17个（=1M/60K）。因此，N M带宽可以支持的同时在线人数大概为N*17个。所以，1M带宽的服务器，日均3000IP以下应该没问题。当然如果网站每个页面都比较大的话，那就没这么多了。 服务器 服务器的质量：服务器分为高中低三种。不同型号品牌的服务器能够承受的流量是不同的，所以，这是影响同时在线访问数量的原因之一。 宽带的大小：假若服务器保证的最大带宽是5M (即5Mbit/s)，相应服务器的数据最高传输速度应为5Mbit/s x 1024/8=640KB，1分钟流量大约640 x 60=38400KB。假设毎个用户1分钟内始终占用10KB的流量，即该1分钟内支持占用这样的流量的同时在线访问人数为3840人（视频类大流量网站不在此例）。但并不能保证每个用户在1分钟内只有一次到该站的链接，假如每个用户在1分钟内有两次或以上到该站的链接）每个链接始终占用10KB的流量），那么支持在线人数应该在2000以下。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>CGI</tag>
        <tag>Servlet</tag>
        <tag>容器</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（七）小总结]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%83%EF%BC%89%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一连6篇，共12种设计模式已经介绍完了，其实这些都是最基本的模式，但也是最重要的模式，因为外面其它各种的模式比较多是从这些基础的模式上进行变体所得的。 虽然本系列是使用Java实现，但与其它语言的思路是共通的，只是可能其它语言有更好的语法或API帮助模式的实现而会有些许不一样而已。 希望后面还能继续在这介绍上更大领域上的设计模式，例如应用模式、业务流程模式、用户界面设计模式、组织模式、架构模式等等。 现在来做一个简单的回顾总结。 基础的模式 策略模式（Strategy）：封装可以互换的行为，并使用委托来决定要使用哪一个（委托即是一实例对象）。 装饰者模式（Decorator）：包装一个对象，以提供新新的行为。 适配器模式（Adapter）：封装对象，并提供不同的接口。 外观模式（Facade）：简化一群类的接口。 命令模式（Command）：封装请求成为对象。 状态模式（State）：封装了基于状态的行为，并使用委托在行为之间切换。 模板方法模式（TemplateMethod）：由子类决定如何实现一个算法中的步骤。 迭代器模式（Iterator）：在对象的集合之中游走，而不暴露集合的实现。 组合模式（Composite）：客户用一直的方式处理对象集合和单个对象。 工厂方法模式（FatoryMethod）：由子类决定要创建的具体类是哪一个。 抽象工厂模式（AbstractFatory）：允许客户端创建对象的家族，而无需指定他们的具体类。 观察者模式（Observer）：让对象能够在状态改变时被通知。 代理模式（Proxy）：包装对象，以控制对此对象的访问。 其它的模式 单例模式（Singleton）（在本系列中它没有出现，因为这个模式算是家喻户晓，不过使用时还是有一些注意点的，例如线程安全，如何实现更高效等） 桥接模式（Bridge） 生成器模式（Builder） 责任链模式（ChainOfResponsibility） 蝇量模式（Flyweight） 解释器模式（Interpreter） 中介者模式（Mediator）（在我们iOS的工程中就使用到这个模式，来建立起一个调度中心去控制不同组件间的相互访问） 备忘录模式（Memento） 原型模式（Prototype） 访问者模式（Visitor） 还有大名鼎鼎的MVC，它其实是一种复合模式。视图（View）和控制器（Controller）实现了策略模式，视图通过更换控制器改变行为；视图则采取组合模式来构建整体，例如窗口就是组合节点，按钮等就是叶节点；模型则实现了观察者模式，当状态改变时，相关的对象将持续更新，例如视图刷新（但iOS的多数例子中并不提倡这样直接通知视图，而是先通知控制器，由控制器改变视图）。 模式分类 创建型 Singleton AbstractFatory FatoryMethod Prototype Builder 行为型 TemplateMethod Iterator Command Observer State Strategy Mediator Visitor Memento Interpreter ChainOfResponsibility 结构型 Decorator Composite Facade Proxy Adapter Flyweight Bridge 设计原则 封装变化 多用组合，少用继承 针对接口编程，不针对实现编程 为交互对象之间的松耦合设计而努力 类应该对扩展开放，对修改关闭 依赖抽象，不要依赖具体类 只和朋友交谈 别找我，我会找你 类应该只有一个改变的理由 注意实际应用中，不要为了使用模式而使用，要使用满足需求的最简单解决方案。大多数的模式都是现有模式的变体，而非新模式，我们也能够依据自己的需要采用或调整。 最后感谢《Head First》这本书的作者，列出那么多生动有趣的案例和解释，每个章节中都有拿相似模式进行对比说明，由浅入深的介绍通俗易懂，让我们喜欢上设计模式，喜欢上对优雅代码的追求。 本系列的代码地址：戳这里]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（六）命令模式 & 观察者模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%85%AD%EF%BC%89%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%20%26%20%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[命令模式应用场景使用多功能的遥控器打开一个电灯 public interface Command &#123; public void execute(); &#125; public class LightOnCommand implements Command &#123; Light light; public LigitOnCommand(Light light) &#123; this.light = light; &#125; public void execute() &#123; light.on(); &#125; &#125; public class SimpleRemoteControl &#123; Command slot; public SimpleRemoteControl() &#123; &#125; public void setCommand(Command command) &#123; slot = command; &#125; public void buttonWasPressed() &#123; slot.execute(); &#125; &#125; public class RemoteControlTest &#123; public static void main(String[] args) &#123; SimpleRemoteControl remote = new SimpleRemoteControl(); Light light = new Light(); LightOnCommand lightOn = new LightOnCommand(light); remote.setCommand(lightOn); remote.buttonWasPressed(); &#125; &#125; 遥控器是调用者，电灯是接收者。创建一个命令并将接收者传给命令，然后将命令传给调用者。这样，将发出请求的对象和执行请求的对象解耦，通过命令对象沟通。 一个命令对象通过在特定接收者上绑定一组动作来封装一个请求，其它对象不知道究竟哪个接收者进行了哪些动作，只知道调用execute方法，请求的目的就能达到。 总结命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其它对象，命令模式也支持可撤销的操作。 观察者模式应用场景气象站将数据传输到显示装置上显示 方案一错误的示范 public class WeatherData1 &#123; public void measurementsChanged() &#123; float temp = getTemperature(); float pressure = getPressure(); displayer1.update(temp, pressure); displayer2.update(temp, pressure); &#125; &#125; 这样就耦合了具体的对象displayer1和displayer2了 方案二应用观察者 public interface Subject &#123; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers(); &#125; public interface Observer &#123; public void update(float temp, float pressure); &#125; public interface DisplayElement &#123; public void display(); &#125; public class WeatherData2 implements Subject &#123; private ArrayList observers; private float temperature; private float pressure; public WeatherData() &#123; observers = new ArrayList(); &#125; public void registerObserver(Observer o) &#123; observers.add(o); &#125; public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if (i &gt;=0) &#123; observers.remove(i); &#125; &#125; public void notifyObservers() &#123; for (int i = 0; i &lt; observers.size(); i++) &#123; Observer observer = (Observer)observers.get(i); observer.update(temperature, pressure); &#125; &#125; public void measurementsChanged() &#123; notifyObservers(); &#125; public void setMeasurements(float temperature, float pressure) &#123; this.temperature = temperature; this.pressure = pressure; measurementsChanged(); &#125; &#125; public class Displayer1 implements Observer, DisplayElement &#123; private float temperature; private Subject weatherData; public Displayer1(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; public void update(float temperature, float pressure) &#123; this.temperature = temperature; display(); &#125; public void display() &#123; //... 显示的实现 &#125; &#125; 方案三还可以利用系统内置观察方式实现 import java.util.Observable; import java.util.Observer; public class WeatherData3 implements Observable &#123; private float temperature; private float pressure; public WeatherData() &#123; &#125; //不再需要记住观察者的数据结构 public void measurementsChanged() &#123; setChanged(); //通知观察者前先标记状态改变了（系统API） notifyObservers(); //通知观察者（系统API） &#125; public void setMeasurements(float temperature, float pressure) &#123; this.temperature = temperature; this.pressure = pressure; measurementsChanged(); &#125; &#125; public class Displayer2 implements Observer, DisplayElement &#123; private float temperature; Observable observable; public Displayer1(Observable observable) &#123; this.observable = observable; observable.addObserver(this); &#125; public void update(Observer obs, Object arg) &#123; if (obs instanceof WeatherData3) &#123; WeatherData3 weatherData = (WeatherData3)obs; this.temperature = weatherData.getTemperature(); display(); &#125; &#125; public void display() &#123; //... 显示的实现 &#125; &#125; 可见系统内置的观察方式，已经帮我们定义了注册观察者、通知观察者及其触发的更新方法。只是特别需要注意setChanged()这个方法需要在状态改变后先调用，后再调用notifyObservers()。 总结观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（四）状态模式 & 代理模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%20%26%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[状态模式应用场景制作一部糖果机，拥有投钱、退钱、检查糖果、发放糖果的程序。 方案一在不同的操作下，先根据当前所在的状态作出对应的响应 public class GumballMachine1 &#123; final static int SOLD_OUT = 0; final static int NO_QUARTER = 1; final static int HAS_QUARTER = 2; final static int SOLD = 3; int state = SOLD_OUT; int count = 0; public GumballMachine(int count) &#123; this.count = count; if (count &gt; 0) &#123; state = NO_QUARTER; &#125; &#125; public void insertQuarter() &#123; if (state == HAS_QUARTER) &#123; System.out.println(&quot;You can&apos;t insert another quarter&quot;); &#125; else if (state == NO_QUARTER) &#123; state = HAS_QUARTER; System.out.println(&quot;You inserted a quarter&quot;); &#125; else if (state == SOLD_OUT) &#123; System.out.println(&quot;You can&apos;t insert a quarter, the machine is sold out&quot;); &#125; else if (state == SOLD) &#123; System.out.println(&quot;Please wait, we&apos;re already giving you a gumball&quot;); &#125; &#125; public void ejectQuarter() &#123; if (state == HAS_QUARTER) &#123; System.out.println(&quot;Quarter returned&quot;); state = NO_QUARTER; &#125; else if (state == NO_QUARTER) &#123; System.out.println(&quot;You haven&apos;t inserted a quarter&quot;); &#125; else if (state == SOLD) &#123; System.out.println(&quot;Sorry, you already turned the crank&quot;); &#125; else if (state == SOLD_OUT) &#123; System.out.println(&quot;You can&apos;t eject, you haven&apos;t inserted a quarter yet&quot;); &#125; &#125; public void turnCrank() &#123; if (state == SOLD) &#123; System.out.println(&quot;Turning twice doesn&apos;t get you another gumball&quot;); &#125; else if (state == NO_QUARTER) &#123; System.out.println(&quot;You turned but there&apos;s no quarter&quot;); &#125; else if (state == SOLD_OUT) &#123; System.out.println(&quot;Your turned, but there are no gumballs&quot;); &#125; else if (state == HAS_QUARTER) &#123; System.out.println(&quot;You turned...&quot;); state = SOLD; dispense(); &#125; &#125; public void dispense() &#123; if (state == SOLD) &#123; System.out.println(&quot;A gumball comes rolling out the slot&quot;); count = count - 1; if (count == 0) &#123; System.out.println(&quot;Oops, out of gumballs&quot;); state = SOLD_OUT; &#125; else &#123; state = NO_QUARTER; &#125; &#125; else if (state == NO_QUARTER) &#123; System.out.println(&quot;You need to pay first&quot;); &#125; else if (state == SOLD_OUT) &#123; System.out.println(&quot;No gumball dispensed&quot;); &#125; else if (state == HAS_QUARTER) &#123; System.out.println(&quot;No gumball dispensed&quot;); &#125; &#125; &#125; 基于方案一，当这个糖果机有新的需求，需要多加入一个“赢家”的状态，就要在每个方法中加入一个新的条件判断来处理，业务逻辑也会更加混乱。 方案二定义一个状态接口，将每个具体的状态封装成一个类实现该接口 public interface State &#123; public void insertQuarter(); public void ejectQuarter(); public void turnCrank(); public void dispense(); &#125; public class NoQuarterState implements State &#123; GumballMachine2 gumballMachine; public NoQuarterState(GumballMachine2 gumballMachine) &#123; this.gumballMachine = gumballMachine; &#125; public void insertQuarter() &#123; System.out.println(&quot;You inserted a quarter&quot;); gumballMachine.setState(gumballMachine.getHasQuarterState()); //这样设置是为了减轻对其它状态类的依赖 &#125; public void ejectQuarter() &#123; System.out.println(&quot;You haven&apos;t inserted a quarter&quot;); &#125; public void turnCrank() &#123; System.out.println(&quot;You turned but there&apos;s no quarter&quot;); &#125; public void dispense() &#123; System.out.println(&quot;You need to pay first&quot;); &#125; &#125; public class WinnerState implements State &#123; public void dispense() &#123; System.out.println(&quot;You&apos;re a winner, you get two gumballs for your quarter&quot;); gumballMachine.releaseBall(); if (gumballMachine.getCount() == 0) &#123; gumballMachine.setState(gumballMachine.getSoldOutState()); &#125; else &#123; gumballMachine.releaseBall(); if (gumballMachine.getCount() &gt; 0) &#123; gumballMachine.setState(gumballMachine.getNoQuarterState()); &#125; else &#123; System.out.println(&quot;Oops, out of gumballs&quot;); gumballMachine.setState(gumballMachine.getSoldOutState()); &#125; &#125; &#125; //... 其它接口方法实现报错信息，和实例对象 &#125; public class HasQuarterState implements State &#123; Random randomWinner = new Random(System.currentTimeMillis()); public void turnCrank() &#123; System.out.println(&quot;You turned...&quot;); int winner = randomWinner.nextInt(10); if ((winner == 0) &amp;&amp; (gumballMachine.getCount() &gt; 1)) &#123; gumballMachine.setState(gumballMachine.getWinnerState()); &#125; else &#123; gumballMachine.setState(gumballMachine.getSoldState()); &#125; &#125; //... 其它接口方法实现报错信息，和实例对象 &#125; //同理，再实现其它状态类。 public class GumballMachine2 &#123; State soldOutState; State noQuarterState; State hasQuarterState; State soldState; State winnerState; State state = soldOutState; int count = 0; public GumballMachine(int numberGumballs) &#123; soldOutState = new SoldOutState(this); noQuarterState = new NoQuarterState(this); hasQuarterState = new HasQuarterState(this); soldState = new SoldState(this); this.count = numberGumballs; if (numberGumballs &gt; 0) &#123; state = noQuarterState; &#125; &#125; public void insertQuarter() &#123; state.insertQuarter(); &#125; public void ejectQuarter() &#123; state.ejectQuarter(); &#125; public void turnCrank() &#123; state.turnCrank(); state.dispense(); &#125; void setState(State state) &#123; this.state = state; &#125; int getCount() &#123; return this.count; &#125; void releaseBall() &#123; System.out.println(&quot;A gumball comes rolling out the slot&quot;); if (count != 0) &#123; count = count - 1; &#125; &#125; &#125; 经过方案二的优化后，将状态封装成独立的类，并将动作委托到代表当前状态的对象。而整体代码则清晰简洁了，代码逻辑的划分更到位(局部化)，更改代码方便且不易影响其它状态。 总结状态模式允许对象基于内部状态而拥有不同的行为，在内部状态改变时改变它的行为，对象看起来好像修改了它的类。但状态模式是通过增加类的数目代价来获取弹性的。 延伸，和策略模式对比，主要是他们的意图不一样（他们的类图是一致的），策略模式通常会用行为或算法来配置Context类，状态模式允许Context随着状态改变而改变行为。 代理模式应用场景对糖果机的销售情况做监控 首先解释一下，这里的代理和Objective-C中所说的代理（Delegate）是有区别的，在下面的延伸部分再做详细说明。 //服务端的实现 import java.rmi.*; import java.io.*; import java.rmi.server.*; public interface GumballMachineRemote extends Remote &#123; public int getCount() throws RemoteException; //因为是远程操作，所以得声明异常 public String getLocation() throws RemoteException; public State getState() throws RemoteException; &#125; public interface State extends Serializable &#123; //只有扩展了序列化接口才可以在网络上传送 public void insertQuarter(); public void ejectQuarter(); public void turnCrank(); public void dispense(); &#125; public class NoQuarterState implements State &#123; transient GumballMachine3 gumballMachine; //为了不让GumballMachine加入到序列化，使用transient关键字修饰各个State实现类中的该实例变量 //... 其它方法的实现 &#125; //让GumballMachine继承UnicastRemoteObject，使其成为远程服务 public class GumballMachine3 extends UnicastRemoteObject implements GumballMachineRemote &#123; public GumballMachine(String location, int numberGumballs) throws RemoteException &#123; //... &#125; //... GumballMachineRemote远程接口的实现，rmi系统会自动针对这些接口生成可被远程访问的方法 &#125; //客户端的实现 public class GumballMonitor &#123; GumballMachineRemote machine; public GumballMonitor(GumballMachineRemote machine) &#123; this.machine = machine; &#125; public void report() &#123; try &#123; System.out.println(machine.getLocation()); System.out.println(machine.getCount()); System.out.println(machine.getState()); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //测试程序 public class test1 &#123; void test() throws Exception &#123; try &#123; GumballMachineRemote machine = (GumballMachineRemote) Naming.lookup(&quot;rmi://xx.xx.com/gumballmachine&quot;); GumballMonitor monitor = new GumballMonitor(machine); monitor.report(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 这里，GumballMachineRemote就是一个远程代理。 总结代理模式为另一个对象提供一个替身或占位符以访问这个对象，以便控制或管理访问。 延伸，代理还有很多变体，例如虚拟代理（控制访问实例化开销大的对象）、保护代理（基于调用者控制对象方法的访问）、防火墙代理、缓存代理等。 代理模式与装饰者模式的区别，装饰者模式只能装饰点缀，不会实例化任何对象，它是为对象加上行为，而代理则是通过创建代理对象控制访问。 Objective-C中的代理是指实现一个协议（接口）的对象，通过委托这个对象去执行协议中的方法，而无需关系该对象是什么，但它并没有是谁的替身或占位符的意思，也不是用于控制访问。 Java内置的代理支持可建立动态代理(反射)，将调用分配到所选的处理器，下面再提供一个用动态代理的实现保护代理例子 public interface PersonBean &#123; void setName(String name);//想要控制别人不能设置，自己能设置 void setHotOrNotRating(int rating);//想要控制自己不能设置，别人能设置 &#125; public class PersonBeanImpl implements PersonBean &#123; String name; int rating; public void setName(String name) &#123; this.name = name; &#125; public void setHotOrNotRating(int rating) &#123; this.rating += rating; &#125; &#125; //import java.lang.reflect.* public class OwnerInvocationHandler implements InvocationHandler &#123; PersonBean person; public OwnerInvocationHandler(PersonBean person) &#123; this.person = person; &#125; //动态代理的任何接口方法被调用时，会调用该invoke方法 public Object invoke(Object proxy, Method method, Object[] args) throws IllegalAccessException &#123; try &#123; if (method.getName().startWith(&quot;get&quot;)) &#123; return method.invoke(person,args); &#125; else if (method.getName().equals(&quot;setHotOrNotRating&quot;)) &#123; throw new IllegalAccessException(); &#125; else if (method.getName().startWith(&quot;set&quot;)) &#123; return method.invoke(person,args); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; public class NoOwnerInvocationHandler implements InvocationHandler &#123; PersonBean person; public OwnerInvocationHandler(PersonBean person) &#123; this.person = person; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws IllegalAccessException &#123; try &#123; if (method.getName().startWith(&quot;get&quot;)) &#123; return method.invoke(person,args); &#125; else if (method.getName().equals(&quot;setHotOrNotRating&quot;)) &#123; return method.invoke(person,args); //与OwnerInvocationHandler相反 &#125; else if (method.getName().startWith(&quot;set&quot;)) &#123; throw new IllegalAccessException(); //与OwnerInvocationHandler相反 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; //这样就无需额外定义代理类，在使用时通过下面的Java内置代理支持方法获取动态的代理 public class test2 &#123; PersonBean getOwnerProxy(PersonBean person) &#123; return (PersonBean) Proxy.newProxyInstance(person.getClass().getClassLoader(),person.getClass().getInterfaces(),new OwnerInvocationHandler(person)); &#125; PersonBean getNoOwnerProxy(PersonBean person) &#123; return (PersonBean) Proxy.newProxyInstance(person.getClass().getClassLoader(),person.getClass().getInterfaces(),new NoOwnerInvocationHandler(person)); &#125; &#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（五）工厂模式 & 装饰者模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%20%26%20%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式应用场景创建不同类型的披萨对象 方案一直接new出具体类型的对象 public class PizzaStore1 &#123; Pizza orderPizza(String type) &#123; Pizza pizza; if (type.equals(&quot;cheese&quot;)) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(&quot;clam&quot;)) &#123; pizza = new ClamPizza(); &#125; pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125; &#125; 方案二将具体(直接耦合、实现)的、会变化的创建对象部分抽离，包装进一个类，这常被称为“静态工厂”（或叫“简单工厂”）。它的缺点是不能通过继承来改变创建方法的行为。 public class PizzaStore2 &#123; SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory) &#123; this.factory = factory; &#125; Pizza orderPizza(String type) &#123; Pizza pizza = factory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125; &#125; public class SimplePizzaFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if (type.equals(&quot;cheese&quot;)) &#123; pizza = new CheesePizza(); &#125; else if (type.equals(&quot;clam&quot;)) &#123; pizza = new ClamPizza(); &#125; return pizza; &#125; &#125; 通过方案二封装出来的创建披萨简单工厂，将具体的实现解耦出来只依赖接口了，其它分店也可以复用了，修改要创建的类型时也更封闭。 假若PizzaStore开始搞加盟店，不同的加盟店会根据当地的口味调整提供Pizza的种类，在简单工厂中再根据多一个地区标识去判断就会越来越复杂，耦合越来越严重。 方案三使用“工厂方法”，来监控创建的披萨质量（当然还是可以继承方案二中的简单工厂，提供不同的子类工厂给PizzaStore来创建，这也是工厂方法，但PizzaStore就无法过多地干预创建的过程） public abstract class PizzaStore3 &#123; public Pizza orderPizza(String type) &#123; Pizza pizza; pizza = createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125; abstract Pizza createPizza(String type); &#125; public class NYPizzaStore3 extends PizzaStore3 &#123; Pizza createPizza(String type) &#123; if (type.equals(&quot;cheese&quot;)) &#123; return new NYStyleCheesePizza(); &#125; else if (type.equals(&quot;clam&quot;)) &#123; return new NYStyleClamPizza(); &#125; &#125; &#125; public class ChicagoPizzaStore3 extends PizzaStore3 &#123; Pizza createPizza(String type) &#123; if (type.equals(&quot;cheese&quot;)) &#123; return new ChicagoStyleCheesePizza(); &#125; else if (type.equals(&quot;clam&quot;)) &#123; return new ChicagoStyleClamPizza(); &#125; &#125; &#125; 工厂方法(模式)通过让子类决定该创建的对象是什么，达到对象创建的过程封装的目的。 这里还涉及一个涉及原则“反依赖倒置原则”，可以按下面三点方针去遵循：1）变量不可以持有具体类的引用；2）不要让类派生自具体类；3）不要覆盖基类中已实现的方法。 上面的方案二和方案三中的工厂或者工厂方法中，都还是依赖了具体类(即 NY or Chicago 这两个地区种类的披萨)，并不符合“反依赖倒置原则”，若未来除cheese和clam外还多了3种披萨，那这两个地区的披萨总和就从4个增至10个 方案四优化工厂中的依赖关系 public interface PizzaIngredientFactory &#123; public Dough createDough(); public Sauce createSauce(); &#125; public class NYPizzaIngredientFactory implements PizzaIngredientFactory &#123; public Dough createDough() &#123; return new ThinCrustDough(); &#125; public Sauce createSauce() &#123; return new MarinaraSauce(); &#125; &#125; public class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory &#123; public Dough createDough() &#123; return new ThickCrustDough(); &#125; public Sauce createSauce() &#123; return new PlumTomatoSauce(); &#125; &#125; public abstract class Pizza &#123; String name; Dough dough; Sauce sauce; abstract void prepare(); //... 其它方法 &#125; public class CheesePizza extends Pizza &#123; PizzaIngredientFactory ingredientFactory; public CheesePizza(PizzaIngredientFactory ingredientFactory) &#123; this.ingredientFactory = ingredientFactory; &#125; void prepare() &#123; //抽象工厂在此起关键作用了 dough = ingredientFactory.createDough(); sauce = ingredientFactory.createSauce(); &#125; //... 其它方法 &#125; public class ClamPizza extends Pizza &#123; PizzaIngredientFactory ingredientFactory; public ClamPizza(PizzaIngredientFactory ingredientFactory) &#123; this.ingredientFactory = ingredientFactory; &#125; void prepare() &#123; dough = ingredientFactory.createDough(); sauce = ingredientFactory.createSauce(); &#125; //... 其它方法 &#125; public class NYPizzaStore4 extends PizzaStore3 &#123; protected Pizza createPizza(String type) &#123; Pizza pizza = null; PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory(); if (type.equals(&quot;cheese&quot;)) &#123; //（间接）应用抽象工厂（传给产品来使用） pizza = new CheesePizza(ingredientFactory); &#125; else if (type.equals(&quot;clam&quot;)) &#123; pizza = new ClamPizza(ingredientFactory); &#125; return pizza; &#125; &#125; public class ChicagoPizzaStore4 extends PizzaStore3 &#123; protected Pizza createPizza(String type) &#123; Pizza pizza = null; PizzaIngredientFactory ingredientFactory = new ChicagoPizzaIngredientFactory(); if (type.equals(&quot;cheese&quot;)) &#123; pizza = new CheesePizza(ingredientFactory); &#125; else if (type.equals(&quot;clam&quot;)) &#123; pizza = new ClamPizza(ingredientFactory); &#125; return pizza; &#125; &#125; 这个就是“抽象工厂模式”，通过采取对象的组合的方式实现（工厂与产品组合，产品使用不同的工厂创建配件族），现在即使披萨的基本种类增至5个，也不至于要另外为2个不同地区同时新增6(2x3)种地区性披萨，也就是说类的增量只有基本种类的3个新披萨。 同时可以看到，NYPizzaIngredientFactory和ChicagoPizzaIngredientFactory里其实都用到了“工厂方法模式”，只是方法不止一个，而是包括了创建这个产品的家族的多个方法。 总结工厂方法模式是定义出一个创建对象的接口，但由子类决定要实例化的类是哪一个，让类把实例化推迟到子类。抽象工厂模式提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。 装饰者模式应用场景计算有n种调料可添加的饮品的价格 方案一为每种调料都创建一个对应的布尔值，用于在计价时判断是否算上对应调料的价格。 此方案就不贴代码出来了，因为太多的if-else，没什么技术含量。（若不使用该方案，也应该不至于对每个调料创建一个子类来解决if-else多的问题吧） 方案二将不同的调料定为不同的装饰者，将饮品定为被装饰者，根据需要可包裹多层的装饰(即添加多种调料) public abstract class Beverage &#123; //当然也可以是接口 String description = &quot;Unknown beverage&quot;; public String getDescription() &#123; return description; &#125; public abstract double cost(); &#125; public abstract class CondimentDecorator extends Beverage &#123; public abstract String getDescription(); &#125; //基础饮品（第一层被装饰的） public class Espresso extends Beverage &#123; public Espresso() &#123; description = &quot;Espresso&quot;; &#125; public double cost() &#123; return 1.99; &#125; &#125; public class HouseBlend extends Beverage &#123; public HouseBlend() &#123; description = &quot;HouseBlend&quot;; &#125; public double cost() &#123; return 0.89; &#125; &#125; //调料（/饮品，第n层被装饰的，也是装饰第n-1层的） public class Mocha extends CondimentDecorator &#123; Beverage beverage; public Mocha(Beverage beverage) &#123; this.beverage = beverage; &#125; public String getDescription() &#123; return beverage.getDescription() + &quot;, Mocha&quot;; &#125; public double cost() &#123; return 0.20 + beverage.cost(); &#125; &#125; 装饰者可以在被装饰者的行为前面或/与后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。 可以使用无数个装饰者去包装一个组件，因为装饰者一般对组件的客户是透明的，除非客户依赖的组件是具体类型，当然简单的只包一层也是可以的（不一定要使用上面例子中的嵌套同类的实例对象在类中）。 总结装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。这是一个符合对扩展开放，对修改关闭原则的模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（三）适配器模式 & 外观模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%20%26%20%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式应用场景鸭子中有绿头鸭、红头鸭等，现在还缺一点鸭子的品种，想用火鸡冒充鸭子。 public interface Duck &#123; public void quack(); public void fly(); &#125; //绿头鸭 public class MallardDuck implements Duck &#123; public void quack() &#123; System.out.println(&quot;Quack&quot;); &#125; public void fly() &#123; System.out.println(&quot;I&apos;m flying&quot;); &#125; &#125; //火鸡 public interface Turkey &#123; public void gobble(); public void fly(); &#125; public class WildTurkey implements Turkey &#123; public void gobble() &#123; System.out.println(&quot;Gobble gobble&quot;); &#125; public void fly() &#123; System.out.println(&quot;I&apos;m flying a short distance&quot;); &#125; &#125; //适配器 public class TurkeyAdapter implements Duck &#123; Turkey turkey; public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; public void quack() &#123; turkey.gobble(); &#125; public void fly() &#123; for (int i=0; i &lt; 5; i++) &#123; turkey.fly(); &#125; &#125; &#125; 客户通过目标接口调用适配器的方法对适配器发出请求，适配器使用被适配者接口把请求转换成被适配者的一个或多个调用接口，客户接收到调用的结果，但并未察觉这一切是适配器做起转换作用。 适配器模式是将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 总结当需要使用现有的类而其接口不符合需要时，使用适配器。 延伸，适配器模式有两种形式，对象适配和类适配，类适配其实就是用(java)多重继承实现，效果一样但不够灵活。和装饰者比较，适配器是包装了一个对象并改变它的接口，装饰者是将对象包装起来后增加新行为和责任。 外观模式应用场景 假设想看一出电影大片，但看之前要准备一大堆操作，执行如下 popper.on(); popper.pop(); lights.dim(10); screen.down(); projector.on(); projector.setInput(dvd); projector.wideScreenMode(); amp.on(); amp.setDvd(dvd); amp.setSurroundSound(); amp.setVolume(5); dvd.on(); dvd.play(movie); 当你想关闭时，又是一堆操作。 我们使用组合的方式将各个子系统汇集起来，然后实现统一个的接口来优化 public class HomeTheaterFacade &#123; Amplifier amp; Tuner tuner; DvdPlayer dvd; CdPlayer cd; Projector projector; TheaterLights lights; Screen screen; PopcornPopper popper; public HomeTheaterFacade(Amplifier amp,Tuner tuner,DvdPlayer dvd,CdPlayer cd,Projector projector,Screen screen,TheaterLights lights,PopcornPopper popper) &#123; this.amp = amp; this.tuner = tuner; this.dvd = dvd; this.cd = cd; this.projector = projector; this.screen = screen; this.lights = lights; this.popper = popper; &#125; public void watchMovie(String movie) &#123; System.out.println(&quot;Get ready to watch a movie ... &quot;); popper.on(); popper.pop(); lights.dim(10); screen.down(); projector.on(); projector.setInput(dvd); projector.wideScreenMode(); amp.on(); amp.setDvd(dvd); amp.setSurroundSound(); amp.setVolume(5); dvd.on(); dvd.play(movie); &#125; public void endMovie() &#123; System.out.println(&quot;Shutting movie theater down ... &quot;); popper.off(); lights.on(); screen.up(); projector.off(); amp.off(); dvd.stop(); dvd.eject(); dvd.off(); &#125; &#125; 这样就实现了外观模式了。外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。也可以理解为是一个包装了多个被适配者的适配器。 外观模式和适配器模式的设计原则是，最少知识原则（又叫“墨忒耳法则”），只和你的密友谈话，不要让太多的类耦合在一起，避免修改系统的一部分而影响到其它部分。 再举一些避免耦合过多类的示例 public float getTemp1() &#123; Thermometer thermometer = station.getThermometer(); return thermometer.getTemperature(); &#125; public float getTemp2() &#123; return station.getTemperature(); &#125; 总结当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观，从一个复杂的子系统中解耦。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（二）迭代器模式 & 组合模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%20%26%20%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[迭代器模式应用场景假设有西餐和煎饼两种菜单，需要招待员打印出这两种菜单的所有菜品项目。 方案一暴露出集合给外部进行遍历 public class MenuItem &#123; String name; String description; boolean vegetarian; double price; public MenuItem(String name, String description, boolean vegetarian, double price) &#123; this.name = name; this.description = description; this.vegetarian = vegetarian; this.price = price; &#125; public String getName() &#123; return name; &#125; public String getDescription() &#123; return description; &#125; public String getPrice() &#123; return price; &#125; public String isVegetarian() &#123; return vegetarian; &#125; &#125; public class PancakeHouseMenu1 &#123; //煎饼菜单 ArrayList menuItems; public PancakeHouseMenu() &#123; menuItems = new ArrayList(); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;,&quot;Pancakes with scrambled eggs, and toast&quot;,true,2.99); addItem(&quot;Regular Pancake Breakfast&quot;,&quot;Pancakes with fried eggs, sausage&quot;,false,2.99); addItem(&quot;Blueberry Pancakes&quot;,&quot;Pancakes made with fresh blueberries&quot;,true,3.49); addItem(&quot;Waffles&quot;,&quot;Walfles, with yoiur choice of blueberries or strawberries&quot;,true,3.59); &#125; public void addItem(String name, String description, boolean vegetarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegetarian, price); menuItems.add(menuItem); &#125; public ArrayList getMenuItems() &#123; return menuItems; &#125; &#125; public class DinerMenu1 &#123; //西餐菜单 static final int MAX_ITEMS = 6; int numberOfItems; MenuItem[] menuItems; public DinerMenu() &#123; menuItems = new MenuItem[MAX_ITEMS]; addItem(&quot;Vegetarian BLT&quot;,&quot;(Fakin&apos;) Bacon with lettuce &amp; tomato on whole wheat&quot;,true,2.99); addItem(&quot;BLT&quot;,&quot;Bacon with lettuce &amp; tomato on whole wheat&quot;,false,2.99); addItem(&quot;Soup of the day&quot;,&quot;Soup of the day, with a side of potato salad&quot;,false,3.29); addItem(&quot;Hotdog&quot;,&quot;A hot dog, with saurkraut, relish, onions, topped with cheese&quot;,false,3.05); &#125; public void addItem(String name, String description, boolean vegetarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegetarian, price); if (numberOfItems &gt;= MAX_ITEMS) &#123; System.err.println(&quot;Sorry, menu is full! Can&apos;t add item to menu&quot;); &#125; else &#123; menuItems[numberOfItems] = menuItem; numberOfItems += 1; &#125; &#125; public MenuItem[] getMenuItems() &#123; return menuItems; &#125; &#125; public class Waitress1 &#123; //招待员 public void printMenu() &#123; PancakeHouseMenu1 pancakeHouseMenu = new PancakeHouseMenu1(); ArrayList breakfastItems = pancakeHouseMenu.getMenuItems(); DinerMenu1 dinerMenu = new DinerMenu1(); MenuItem[] lunchItems = dinerMenu.getMenuItems(); //需要用两个for循环分别遍历两种不同类型的菜单项集合(菜单) for (int i = 0; i &lt; breakfastItems.size(); i++) &#123; MenuItem menuItem = (MenuItem)breakfastItems.get(i); System.out.print(menuItem.getName()+&quot; &quot;); System.out.println(menuItem.getPrice()+&quot; &quot;); System.out.println(menuItem.getDescription()); &#125; for (int j = 0; j &lt; lunchItems.length; j++) &#123; MenuItem menuItem = lunchItems[j]; System.out.print(menuItem.getName()+&quot; &quot;); System.out.println(menuItem.getPrice()+&quot; &quot;); System.out.println(menuItem.getDescription()); &#125; &#125; &#125; 从上面的方案一看，招待员的打印菜单实现中带有两次循环，且捆绑于具体的集合类型。 方案二利用迭代器改进 为了让招待员更方便地遍历菜单，需要定义一个迭代器接口，然后分别实现煎饼和西餐两种具体的迭代器。这样招待员使用迭代器遍历时就可以调用统一的接口而不用关心这两种菜单内的差异处理，循环代码也因此变成只有一个。 public interface Iterator &#123; boolean hasNext(); Object next(); &#125; public class DinerMenuIterator2 implements Iterator &#123; MenuItem[] items; int position = 0; public DinerMenuIterator(MenuItem[] items) &#123; this.items = items; &#125; public Object next() &#123; MenuItem menuItem = items[position]; position += 1; return menuItem; &#125; public boolean hasNext() &#123; if (position &gt;= items.length || items[position] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; &#125; 同理，实现 PancakeHouseMenuIterator2。 public class DinerMenu2 &#123; //... public Iterator createIterator() &#123; return new DinerMenuIterator2(menuItems); &#125; &#125; DinerMenu去掉了getMenuItems方法，因为不再以暴露出内部的实现给外部进行遍历，改为提供封装好遍历逻辑的迭代器给外部直接使用。同理，再为 PancakeHouseMenu2 添加 createIterator 方法。 public class Waitress2 &#123; PancakeHouseMenu2 pancakeHouseMenu; DinerMenu2 dinerMenu; public Waitress(PancakeHouseMenu2 pancakeHouseMenu, DinerMenu2 dinerMenu) &#123; this.pancakeHouseMenu = pancakeHouseMenu; this.dinerMenu = dinerMenu; &#125; public void printMenu() &#123; Iterator pancakeIterator = pancakeHouseMenu.createIterator(); Iterator dinerIterator = dinerMenu.createIterator(); System.out.println(&quot;Menu\n---\nBreakfast&quot;); printMenu(pancakeIterator); System.out.println(&quot;\nLunch&quot;); printMenu(dinerIterator); &#125; private void printMenu(Iterator iterator) &#123; while (iterator.hasNext()) &#123; MenuItem menuItem = (MenuItem)iterator.next(); System.out.print(menuItem.getName()+&quot;, &quot;); System.out.print(menuItem.getPrice()+&quot; -- &quot;); System.out.print(menuItem.getDescription()); &#125; &#125; &#125; 从上面看，方案二中，招待员仍然捆绑于两个具体的菜单类，我们应该做得更针对接口编程，解耦招待员和具体菜单的关系。 方案三利用java.util.Iterator 系统本身有迭代器相关接口和已实现的类可直接利用，同时本次抽象出菜单接口供招待员使用，解耦招待员和煎饼西餐两个具体菜单的关系。 public interface Menu &#123; public Iterator createIterator(); &#125; public class PancakeHouseMenu3 implements Menu &#123; //煎饼菜单 ArrayList menuItems; public PancakeHouseMenu() &#123; menuItems = new ArrayList(); addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;,&quot;Pancakes with scrambled eggs, and toast&quot;,true,2.99); addItem(&quot;Regular Pancake Breakfast&quot;,&quot;Pancakes with fried eggs, sausage&quot;,false,2.99); addItem(&quot;Blueberry Pancakes&quot;,&quot;Pancakes made with fresh blueberries&quot;,true,3.49); addItem(&quot;Waffles&quot;,&quot;Walfles, with yoiur choice of blueberries or strawberries&quot;,true,3.59); &#125; public void addItem(String name, String description, boolean vegetarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegetarian, price); menuItems.add(menuItem); &#125; public Iterator createIterator() &#123; return menuItems.iterator(); //因ArrayList支持Iterator接口，故直接免去 PancakeHouseMenuIterator3 的实现。 &#125; &#125; public class DinerMenu3 implements Menu &#123; //... public Iterator createIterator() &#123; return new DinerMenuIterator3(menuItems); //因数组list（MenuItems[]）不支持Iterator接口，故仍需实现 DinerMenuIterator3 &#125; &#125; public class DinerMenuIterator3 implements Iterator &#123; //... //还需实现 java.util.Iterator 的remove public void remove() &#123; if (position &lt;= 0) &#123; throw new IllegalStateException(&quot;You can&apos;t remove an item until you&apos;ve done at least one next()&quot;); &#125; if (items[position-1] != null) &#123; for (int i = position-1; i &lt; (items.length-1); i++) &#123; items[i] = items[i+1]; &#125; items[items.length-1] = null; &#125; &#125; &#125; public class Waitress3 &#123; Menu pancakeHouseMenu; Menu dinerMenu; public Waitress(Menu pancakeHouseMenu, Menu dinerMenu) &#123; this.pancakeHouseMenu = pancakeHouseMenu; this.dinerMenu = dinerMenu; &#125; &#125; 为了演示Hashtable的Iterator，再添加一个咖啡菜单 public class CafeMenu implements Menu &#123; Hashtable menuItems = new Hashtable(); public CafeMenu() &#123;&#125; public void addItem(String name, String description, boolean vegetarian, double price) &#123; MenuItem menuItem = new MenuItem(name, description, vegetarian, price); menuItems.put(menuItem.getName(), menuItem); &#125; public Iterator createIterator() &#123; return MenuItems.values().iterator(); &#125; &#125; 再优化一下招待员，使他不用在每次增减菜单时都要改到内部的代码。这也是得益于Menu接口的诞生 public class Waitress4 &#123; ArrayList menus; public Waitress(ArrayList menus) &#123; this.menus = menus; &#125; public void printMenu() &#123; Iterator menuIterator = menus.iterator(); while(menuIterator.hasNext()) &#123; Menu menu = (Menu)menuIterator.next(); printMenu(menu.createIterator()); &#125; &#125; private void printMenu(Iterator iterator) &#123; //... &#125; &#125; 总结迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚合，简化了聚合的接口和实现，让责任各得其所。 延伸，类的每个责任都有改变的潜在区域，超过一个责任，意味着超过一个改变的区域，应尽量让每个类保存单一责任，即一个类应该只有一个引起变化的原因。 组合模式应用场景基于上一节的迭代器模式中的菜单例子，假设要历遍菜单的菜单项中，可能还有子菜单，继续打印包括子菜单里的所有菜单项。 首先定义一个菜单项和子菜单的抽象类，可以作为个别对象和对象组合的父类，使其可被统一的处理。 public abstract class MenuComponent1 &#123; public void add(MenuComponent1 menuComponent) &#123; throw new UnsupportedOperationException();&#125; public void remove(MenuComponent1 menuComponent) &#123; throw new UnsupportedOperationException();&#125; public MenuComponent1 getChild(int i) &#123; throw new UnsupportedOperationException();&#125; public String getName() &#123; throw new UnsupportedOperationException();&#125; public String getDescription() &#123; throw new UnsupportedOperationException();&#125; public String getPrice() &#123; throw new UnsupportedOperationException();&#125; public String isVegetarian() &#123; throw new UnsupportedOperationException();&#125; public void print() &#123; throw new UnsupportedOperationException();&#125; &#125; public class MenuItem1 extends MenuComponent1 &#123; //... public void print() &#123; System.out.print(&quot; &quot;+getName()); if (isVegetarian()) &#123; System.out.print(&quot;(v)&quot;); &#125; System.out.print(&quot;, &quot;+getPrice()); System.out.print(&quot; -- &quot;+getDescription()); &#125; &#125; public class Menu1 extends MenuComponent1 &#123; ArrayList menuComponents = new ArrayList(); String name; String description; public Menu(String name, String description) &#123; this.name = name; this.description = description; &#125; public void add(MenuComponent1 menuComponent) &#123; menuComponent.add(menuComponent);&#125; public void remove(MenuComponent1 menuComponent) &#123; menuComponent.remove(menuComponent);&#125; public MenuComponent1 getChild(int i) &#123; return (MenuComponent)menuComponent.get(i);&#125; public String getName() &#123; return name; &#125; public String getDescription() &#123; return description; &#125; public void print() &#123; System.out.print(&quot;\n &quot;+getName()); System.out.print(&quot;, &quot;+getDescription()); System.out.print(&quot;----------------&quot;); Iterator iterator = menuComponents.iterator(); while(iterator.hasNext()) &#123; MenuComponent1 menuComponent = (MenuComponent)iterator.next(); menuComponent.print(); //如果元素是(子)菜单，则产生递归效果 &#125; &#125; &#125; public class Waitress &#123; MenuComponent1 allMenus; public Waitress(MenuComponent1 allMenus) &#123; this.allMenus = allMenus; &#125; public void printMenu() &#123; allMenus.print(); &#125; &#125; public class MenuTestDrive &#123; public static void main(String args[]) &#123; MenuComponent1 pancakeHouseMenu = new Menu1(&quot;Pancake House Menu&quot;,&quot;Breakfast&quot;); MenuComponent1 dinerMenu = new Menu1(&quot;Diner Menu&quot;,&quot;Lunch&quot;); MenuComponent1 cafeMenu = new Menu1(&quot;Cafe Menu&quot;,&quot;Dinner&quot;); MenuComponent1 dessertMenu = new Menu1(&quot;Dessert Menu&quot;,&quot;Dessert of course&quot;); MenuComponent1 allMenus = new Menu1(&quot;All Menus&quot;,&quot;All menus combined&quot;); allMenus.add(pancakeHouseMenu); allMenus.add(dinerMenu); allMenus.add(cafeMenu); dinerMenu.add(new MenuItem1(&quot;Pasta&quot;,&quot;Spaghetti with Marinara Sauce, and a slice of sourdough bread&quot;,true,3.89)); dinerMenu.add(dessertMenu); dessertMenu.add(new MenuItem1(&quot;Apple Pie&quot;,&quot;Apple pie with a flakey crust, topped with vanilla ice cream&quot;,true,1.59)); Waitress waitress = new Waitress((allMenus)); waitress.printMenu(); &#125; &#125; 上面使用了树状结构设计菜单组件MenuComponent，Menu类是组件的其中一个具体实现，并可以往上面添加菜单组件MenuComponent，实现嵌套存储。 上面的实现中没有提供遍历的元素，如果要提供出来则需要做一套这个树的迭代器。 假设现在要找出所有素食菜品，做一下改造 public abstract class MenuComponent2 &#123; //... public Iterator createIterator() &#123;&#125;; &#125; public class Menu2 extends MenuComponent2 &#123; //... public Iterator createIterator() &#123; return new CompositeIterator(menuComponents.iterator()); &#125;; &#125; public class MenuItem2 extends MenuComponent2 &#123; //... public Iterator createIterator() &#123; return new NullIterator(); // 为了保持一致性和安全性，提供空迭代器给外部遍历时进行假调用（因为外部只认菜单组件的接口，而不会理会具体实现是否支持） &#125;; &#125; public class NullIterator implements Iterator &#123; public Object next() &#123; return null; &#125; public boolean hasNext() &#123; return false; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125; //树(组合)迭代器 public class CompositeIterator implements Iterator &#123; Stack stack = new Stack(); //用来存放整个组合里面的所有迭代器 public CompositeIterator(Iterator iterator) &#123; stack.push(iterator); &#125; public Object next() &#123; if (hasNext()) &#123; Iterator iterator = (Iterator) stack.peek(); //使用栈顶的迭代器历遍，一个迭代器历遍完后hasNext内会自动更新栈顶的迭代器 MenuComponent component = (MenuComponent) iterator.next(); if (component instanceof Menu) &#123; stack.push(component.createIterator()); //将子菜单的迭代器推入栈 &#125; return component; &#125; else &#123; return null; &#125; &#125; public boolean hasNext() &#123; if (stack.empty()) &#123; return false; &#125; else &#123; Iterator iterator = (Iterator) stack.peek(); if (!iterator.hasNext()) &#123; stack.pop(); return hasNext(); //递归 &#125; else &#123; return true; &#125; &#125; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125; public class Waitress2 &#123; //... public void printVegetarianMenu() &#123; Iterator iterator = allMenus.createIterator(); while(iterator.hasNext()) &#123; MenuComponent2 menuComponent2 = (MenuComponent2)iterator.next(); try &#123; if (menuComponent2.isVegetarian()) &#123; menuComponent2.print(); &#125; &#125; catch (UnsupportedOperationException e) &#123; &#125; &#125; &#125; &#125; 总结组合模式允许将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。使用组合结构，我们能把相同的操作应用在组合和个别对象上，即忽略对象组合和个别对象之间的差别。 组合模式以单一责任设计原则换取了透明性，但失去了相对的安全性，即是调用者可能会对一个元素做出不恰当或没意义的操作方法调用，这个是典型的折衷案例。 延伸：组件还可以有指向父节点的指针，方便反向游走；有顺序的子节点，增删节点方法需额外设计；缓存起需要历遍计算的结果，节省开支。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git手册]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2FGit%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[记录一些常用的Git命令方便使用时查询，以及简单交代对应的原理，便于操作时理解实际意义。 本地创建并切换到新分支newBranchName git checkout -b bugFix git branch bugFix git checkout bugFix 使用指定分支创建分支，并切换 git checkout -b special master 提交版本 git commit 假设在master上要合并回bugFix的提交版本 git merge bugFix 与上一个指令同等效果，分支结构会更清晰的变基(在bugFix上进行，但因安全性和可跟踪性问题而建议少用。指令可以解读为“变基到xx分支上“，后可带一个可选参数，表示使用哪个分支进行变基) git rebase master 查看当前HEAD指向的引用，一般的指向是HEAD-&gt;master-&gt;versionHash git symbolic-ref HEAD 查看提交记录的哈希值 git log 相对引用切换，切换到master的上一次(如果上一次有两个父节点，可添加数字指定)和前3次的提交记录，或指定hash(支持只输入前4位)，还可以链式操作 git checkout master^ git checkout master~3 git checkout f2e1 git checkout HEAD~^2~2 强制变更分支指向的提交（相对引用方式） git branch -f master HEAD~3 回退版本，改写本地历史 git reset HEAD~1 撤销远端的更改，还原版本 git revert HEAD 复制版本，控制顺序 git cherry-pick C2 C4 交互式的rebase，在不清楚版本hash时又想用cherry-pick按顺序复制版本时使用(会在vi编辑文件下配置要复制的版本的顺序，利用参数–interactive或-i) git rebase -i branch/HEAD~4 若漏掉了文件没有加，或者提交信息写错了，想要撤消刚才的提交操作，可以使用 –amend 选项重新提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明 git commit --amend 永久指向提交版本的Tag git tag tagV1 verC1 查找最近的标签，输出样式，&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;（hash是下面ref的哈希值） git describe &lt;ref&gt; 强制变更分支指向 git branch -f feature C2 远程克隆本地路径时是真正的拷贝，克隆远端时是复制远端的版本到本地形成关联。而且克隆后，本地会自动将远端分支命名为origin/master，origin是远端仓库的默认名称，所以本地的master分支并不是项目的真正master分支，若尝试手动切换到origin/master，只会产生与其相同引用的分离HEAD状态，因为Git不允许直接在远端项目上操作。 git clone git_url 从远程仓库获取数据（下载缺失的提交记录，并更新本地的远程分支指针。但不会改动本地仓库的状态，因为怕你还没完成本地的版本） git fetch git fetch origin foo 抓取远程仓库的更新并合并到本地分支新建一个版本提交记录（=fetch + merge）。如果不想用合并的方式，可以在后面加上参数–rebase，将本地当前的提交记录变基到远端的偏离历史的提交记录上，这样的提交轨迹线会相对清晰。 git pull git pull --rebase 将本地变更上传到指定的远程仓库。若使用指定source和destination的方式时 (比较少用到)，需要遵循下面的格式，使用冒号分隔，destination是指需更新的远端分支名称，但不需加origin/前缀标识，而原来已经在跟踪该远端的同名本地分支不会有所变动，source则可以是任何一个提交记录。 git push git push &lt;remote&gt; &lt;place&gt; git push origin master git push origin &lt;source&gt;:&lt;destination&gt; 追踪远程分支（下面指令意思是创建分支foo，并通过参数-u设置跟踪origin/master，如果当前就在foo上还可以省略掉foo） git branch -u origin/master foo 删除远端分支；创建本地分支。 git push origin :foo git fetch origin :bar 列出远程主机 (如 origin) git remote git remote -v 关联远程分支(默认master) git remote add origin url.git 等等Github或一些git管理工具，远程仓库是不允许代码贡献者直接push的(作者自己的本地则没有限制)，而是发起一个pull request，让项目作者自己fetch&amp;merge/pull贡献者代码(像是反过来一样，要合并外部的代码时，外部的代码视作一个远端仓库，而它则是贡献者在开发前期进行fork所创建，fork类似clone)。 关于 rebase 的优缺点：优点:Rebase 使你的提交树变得很干净, 所有的提交都在一条线上缺点:Rebase 修改了提交树的历史(比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。)如果喜欢保留提交历史，可以选用merge代替。 其它一些pull的使用例子（复杂版的fetch + merge） git pull origin foo = git fetch origin foo; git merge o/foo git pull origin bar~1:bugFix = git fetch origin bar~1:bugFix; git merge bugFix 永久记住密码；查询用户信息 git config --global credential.helper store git config user.name git config user.email 删除密码，只要在仓库的.git/config文件中删除[credential] helper = store这行内容即可，这样每次对git源提交记录版本时都需要输入密码。修改密码则是先删除该项，然后操作一次git源，再补回该项，这样下次输的新密码就被记录起来了。 Ref感谢这个Git实操练习网站还有一峰大的Git远程操作详解Git Book]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（一）策略模式 & 模板方法模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%20%26%20%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[以往在开发或者重构代码的时候，会经常用上一些技巧来达到抽象和解耦等目的，但并没有系统地详细了解和分类总结过程中所用到的方法，现在回过头来看一些设计模式的方法论，借鉴前人总结的开发经验，感触还蛮大的。而且在了解这些正统、专业的方法论后，后续与其它程序员在沟通代码设计时就有更高效的语言去描述了，当然前提是大家都对这有所了解。 上一年初对公司的iOS项目进行了一次大重构后，今年又有计划要对Android那边的项目也进行一次优化重构，这次必须得在行动前梳理梳理这设计模式的知识，尽量在工作中需要的地方清晰合理地应用起来。 这个系列主要都是参考《Head First》，也是按书本上所用的语言Java来做Demo（合乎我接下来搞Android呢）。好，那就开始吧~（为了节省篇幅，下面方法体中的规范会有所将就） 策略模式应用场景已知有父类鸭子和它的一些子类，如青头鸭、橡皮鸭等，起初实现需求时，他们都还没有飞翔功能，现在想对能飞翔的子类添加飞方法实现。 方案一利用继承实现的话，如下 public abstract class Duck1 &#123; public void quack() &#123;System.out.println(&quot;quack&quot;);&#125; public void swim() &#123;System.out.println(&quot;swim&quot;);&#125; public abstract void display(); public void fly() &#123;System.out.println(&quot;fly&quot;);&#125;; &#125; public class MallardDuck1 extends Duck1 &#123; //青头鸭 public void display() &#123;System.out.println(&quot;MallardDuck display&quot;);&#125; &#125; public class RedheadDuck1 extends Duck1 &#123; //红头鸭 public void display() &#123;System.out.println(&quot;RedheadDuck display&quot;);&#125; &#125; public class RubberDuck1 extends Duck1 &#123; //橡皮鸭 public void display() &#123;System.out.println(&quot;RubberDuck display&quot;);&#125; @Override public void quack() &#123;System.out.println(&quot;squeak&quot;);&#125; &#125; public class DecoyDuck1 extends Duck1 &#123; //诱利鸭 public void display() &#123;System.out.println(&quot;RubberDuck display&quot;);&#125; @Override public void quack() &#123; &#125; &#125; 从上面的代码看，要添加一个 fly 方法，其实是不适合直接在父类 Duck 中通过继承的方式实现而让子类获得此方法，因为并非所有子类鸭子都会飞。若为使大部分能飞的鸭子子类可以复用 fly 方法而硬要在父类中添加，则一些不会飞鸭子子类需要重写 fly 方法改为什么都不做。同时发现，已经实现了的 quack 方法也是与 fly 一样的情况。 方案二利用接口改进，如下 public interface FlyBehavior &#123; public void fly(); &#125; public interface QuackBehavior &#123; public void quack(); &#125; public abstract class Duck2 &#123; public void swim() &#123;System.out.println(&quot;swim&quot;);&#125; public abstract void display(); &#125; public class MallardDuck2 extends Duck2 implements FlyBehavior, QuackBehavior &#123; //青头鸭 public void display() &#123;System.out.println(&quot;MallardDuck display&quot;);&#125; public void fly() &#123;System.out.println(&quot;MallardDuck fly&quot;);&#125;; public void quack() &#123;System.out.println(&quot;MallardDuck quack&quot;);&#125;; &#125; public class RedheadDuck2 extends Duck2 implements FlyBehavior, QuackBehavior &#123; //红头鸭 public void display() &#123;System.out.println(&quot;RedheadDuck display&quot;);&#125; public void fly() &#123;System.out.println(&quot;RedheadDuck fly&quot;);&#125;; public void quack() &#123;System.out.println(&quot;RedheadDuck quack&quot;);&#125;; &#125; public class RubberDuck2 extends Duck2 implements QuackBehavior &#123; //橡皮鸭 public void display() &#123;System.out.println(&quot;RubberDuck display&quot;);&#125; public void quack() &#123;System.out.println(&quot;RubberDuck quack&quot;);&#125;; &#125; public class DecoyDuck2 extends Duck2 &#123; //诱利鸭 public void display() &#123;System.out.println(&quot;DecoyDuck display&quot;);&#125; &#125; 这样修改后，会发现重复的代码多了，像 fly 和 quack 接口方法，若子类很多且大部分都实现了 fly 或 quack 接口的时候（即使有部分的实现不一样），在需要调整 fly 或 quack 的实现时要改动到的地方就会变得很多了。 方案三利用组合的形式改进，如下 public interface FlyBehavior &#123; public void fly(); &#125; public class FlyWithWings implements FlyBehavior &#123; public void fly() &#123;System.out.println(&quot;Fly with wings&quot;);&#125; &#125; public class FlyNoWay implements FlyBehavior &#123; public void fly() &#123;System.out.println(&quot;Can&apos;t fly&quot;);&#125; &#125; public interface QuackBehavior &#123; public void quack(); &#125; public class Qucak implements QuackBehavior &#123; public void quack() &#123;System.out.println(&quot;Quack&quot;);&#125; &#125; public class Squeak implements QuackBehavior &#123; public void quack() &#123;System.out.println(&quot;Squeak&quot;);&#125; &#125; public class MuteQuack implements QuackBehavior &#123; public void quack() &#123;System.out.println(&quot;Silence&quot;);&#125; &#125; public abstract class Duck3 &#123; FlyBehavior flyBehavior; QuackBehavior quackBehavior; void performFly() &#123; flyBehavior.fly(); &#125; void performQuack() &#123; quackBehavior.quack(); &#125; public void swim() &#123;System.out.println(&quot;swim&quot;);&#125; public abstract void display(); &#125; public class MallardDuck3 extends Duck3 &#123; //青头鸭 public MallardDuck3() &#123; quackBehavior = new Qucak(); flyBehavior = new FlyWithWings(); &#125; public void display() &#123;System.out.println(&quot;MallardDuck display&quot;);&#125; &#125; public class RedheadDuck3 extends Duck &#123; //红头鸭 public RedheadDuck3() &#123; quackBehavior = new Qucak(); flyBehavior = new FlyWithWings(); &#125; public void display() &#123;System.out.println(&quot;RedheadDuck display&quot;);&#125; &#125; public class RubberDuck3 extends Duck &#123; //橡皮鸭 public RubberDuck3() &#123; quackBehavior = new Squeak(); flyBehavior = new FlyNoWay(); &#125; public void display() &#123;System.out.println(&quot;RubberDuck display&quot;);&#125; &#125; public class DecoyDuck3 extends Duck &#123; //诱利鸭 public DecoyDuck3() &#123; quackBehavior = new MuteQuack(); flyBehavior = new FlyNoWay(); &#125; public void display() &#123;System.out.println(&quot;DecoyDuck display&quot;);&#125; &#125; 现在，飞翔和啼叫的动作委托了两个抽象的实例变量去处理。而且在 Duck 中添加两个实例变量的 set 方法，更是可以在运行时动态地设定这两种行为。 这总结出3个设计原则: 找出变化之处独立出来，封装变化； 针对接口编程而不要针对实现编程（即是对方法进行抽离抽象成接口后使用，若在父类或子类中直接实现后使用就会因太过于通用而失去了灵活性）； 多组合，少继承。 总结策略模式，就是一套算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 模板方法模式应用场景假设有茶和咖啡两个类(如下所示代码)，它们在冲泡的过程中，有部分步骤方法实现是重复的，现在需要进行优化抽取出公共的代码。 public class Coffee1 &#123; void prepareRecipe() &#123; boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); &#125; void boilWater() &#123;System.out.println(&quot;Boiling water&quot;);&#125; void brewCoffeeGrinds() &#123;System.out.println(&quot;Dripping Coffee through filter&quot;);&#125; void pourInCup() &#123;System.out.println(&quot;Pouring into cup&quot;);&#125; void addSugarAndMilk() &#123;System.out.println(&quot;Adding Sugar and Milk&quot;);&#125; &#125; public class Tea1 &#123; void prepareRecipe() &#123; boilWater(); steepTeaBag(); pourInCup(); addLemon(); &#125; void boilWater() &#123;System.out.println(&quot;Boiling water&quot;);&#125; void steepTeaBag() &#123;System.out.println(&quot;Steeping the tea&quot;);&#125; void pourInCup() &#123;System.out.println(&quot;Pouring into cup&quot;);&#125; void addLemon() &#123;System.out.println(&quot;Adding Lemon&quot;);&#125; &#125; 方案一创建一个咖啡因饮料的基类，将咖啡和茶的公共方法抽取到此基类中，它们各自实现自己特有的步骤方法 public abstract class CaffeineBeverage2 &#123; void prepareRecipe() &#123; boilWater(); pourInCup(); &#125; public void boilWater() &#123;System.out.println(&quot;Boiling water&quot;);&#125; public void pourInCup() &#123;System.out.println(&quot;Pouring into cup&quot;);&#125; &#125; public class Coffee2 extends CaffeineBeverage2 &#123; void prepareRecipe() &#123; boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); &#125; void brewCoffeeGrinds() &#123;System.out.println(&quot;Dripping Coffee through filter&quot;);&#125; void addSugarAndMilk() &#123;System.out.println(&quot;Adding Sugar and Milk&quot;);&#125; &#125; public class Tea2 extends CaffeineBeverage2 &#123; void prepareRecipe() &#123; boilWater(); steepTeaBag(); pourInCup(); addLemon(); &#125; void steepTeaBag() &#123;System.out.println(&quot;Steeping the tea&quot;);&#125; void addLemon() &#123;System.out.println(&quot;Adding Lemon&quot;);&#125; &#125; 此时，会发现 prepareRecipe 并没有完全抽取到基类，因为子类的 prepareRecipe 实现里面是包含子类特有的步骤方法，基类中的 prepareRecipe 其实并没什么实质的意义，只是包含上基类知道的公共步骤方法，具有真正意义的只能靠子类重写的 prepareRecipe。 但这时问题又来了，子类重写的 prepareRecipe 方法里还是存在重复的代码，就是 boilWater 和 pourInCup 这两个步骤，而且如果 prepareRecipe 其中的实现变动（例如步骤顺序等改变）那要改的地方就很多了（每一个子类里），需要再进一步抽象 prepareRecipe 。 方案二抽象出特性的步骤方法 public abstract class CaffeineBeverage3 &#123; void prepareRecipe() &#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125; public void boilWater() &#123;System.out.println(&quot;Boiling water&quot;);&#125; public void pourInCup() &#123;System.out.println(&quot;Pouring into cup&quot;);&#125; abstract void brew(); abstract void addCondiments(); &#125; public class Coffee3 extends CaffeineBeverage3 &#123; public void brew() &#123;System.out.println(&quot;Dripping Coffee through filter&quot;);&#125; public void addCondiments() &#123;System.out.println(&quot;Adding Sugar and Milk&quot;);&#125; &#125; public class Tea3 extends CaffeineBeverage3 &#123; public void brew() &#123;System.out.println(&quot;Steeping the tea&quot;);&#125; public void addCondiments() &#123;System.out.println(&quot;Adding Lemon&quot;);&#125; &#125; 抽象出特性的步骤方法后，prepareRecipe 可以完全抽取到基类中实现了，而基类也不用关注两个抽象步骤方法 brew 和 addCondiments 的具体实现。 这里咖啡和茶经过两次的方法抽取后，算法原本在这两个子类中控制的，改由基类咖啡因饮料主导，从而可以保护和约束这个算法的框架，即是基类更专注于算法本身，子类提供完整的实现。 这个例子中是在继承的关系上演示的，实际情况可能会有变种，例如算法本身并不在基类上，而是在另外一个独立类上实现，完整的实现通过接口（iOS上对应的是协议）去获取。 最后，关于这个例子中子类实现的完整步骤方法，有时候子类可能想要动态控制是否执行这个步骤，所以设计者在模板算法中对于可选执行的步骤，应该提供钩子hook给子类去自行决定是否执行（基类或算法所在的类上可以实现默认或空的钩子方法，等子类选择重写），如下例 public abstract class CaffeineBeverageWithHook &#123; void prepareRecipe() &#123; boilWater(); brew(); pourInCup(); if (customerWantsCondiments()) &#123; addCondiments(); &#125; &#125; abstract void brew(); abstract void addCondiments(); public void boilWater() &#123;System.out.println(&quot;Boiling water&quot;);&#125; public void pourInCup() &#123;System.out.println(&quot;Pouring into cup&quot;);&#125; boolean customerWantsCondiments() &#123; return true; &#125; &#125; public class CoffeeWithHook extends CaffeineBeverageWithHook &#123; public void brew() &#123;System.out.println(&quot;Dripping Coffee through filter&quot;);&#125; public void addCondiments() &#123;System.out.println(&quot;Adding Sugar and Milk&quot;);&#125; public boolean customerWantsCondiments() &#123; String answer = getUserInput(); if (answer.toLowerCase().startsWith(&quot;y&quot;)) &#123; return true; &#125; else &#123; return false; &#125; &#125; private String getUserInput() &#123; String answer = null; System.out.print(&quot;Would you like milk and sugar with your coffee (y/n)?&quot;); BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); try &#123; answer = in.readLine(); &#125; catch (IOException ioe) &#123; System.err.println(&quot;IO error trying to read your answer&quot;); &#125; if (answer == null) &#123; return &quot;no&quot;; &#125; return answer; &#125; &#125; 一般，都是底层组件（具体实现者）挂钩到高层组件（抽象执行者）上， 另外需要注意一点，算法里的步骤切割得太细就会让子类实现的步骤方法麻烦复杂，但太粗太少就会比较没有弹性，这个需要折衷考虑。 总结模板方法模式其实是定义了一个算法的大纲，定义了算法的步骤，并由它的子类或接口实现者定义其中的某些步骤的内容，它也是一种代码复用的技巧，当中的抽象类可以定义具体方法、抽象方法和钩子，为防止子类改变模板方法，可以将模板方法声明为final。 延伸，对比一下，模板方法模式和策略模式有点相似，但是策略模式通过组合委托对象的形式是可以动态更换算法中的实现步骤，不过算法的封装因为散落在子类而没有绝对的控制权，会较容易出现重复代码。而工厂方法则是模板方法的一种特殊版本。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter开发（实践篇）]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2FFlutter%E5%BC%80%E5%8F%91%EF%BC%88%E5%AE%9E%E8%B7%B5%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[环境搭建iOS 克隆Flutter项目git clone -b beta https://github.com/flutter/flutter.git 将flutter加入path使用zsh的同学要注意，修改.zshrc才有效，而不是.bash_profile。 export PATH=[克隆项目的目录]/flutter/bin:$PATH 安装iOS依赖的工具 $ brew install --HEAD libimobiledevice $ brew install ideviceinstaller ios-deploy cocoapods 安装VS Code下载地址 在VS中安装Dart以及Flutter若Android也使用VS Code的话，也是同样需要该步骤。 运行Flutter的环境检查第一次运行flutter指令时会下载额外的内容和编译出flutter工具，需要等一段时间。 flutter doctor Android 初始化项目在AS的偏好设置的插件菜单中选择浏览仓库，再选择安装Flutter插件，同时也安装Dart插件，然后重启。参考 安装adb及使用 brew cask install android-platform-tools adb devices adb install /Path/to/app-debug.apk 通过flutter doctor的指引来同意lisence 创建工程App开发创建纯Flutter的App工程 flutter create myApp 如果在App里导入了包(package)或者插件(plugin)，执行flutter packages get命令后，以iOS为例，插件的平台源码会在下图的新建路径上存放并引用，如下图 原身在下面的路径中 /Users/user/.pub-cache/hosted/pub.dartlang.org 在App编译时，包或者插件的lib中的dart以及plugin中的platform(iOS/Android)代码就被一并编译到App.framework中 包及插件开发Flutter的包，是指通过利用pubspec.yaml文件发布版本的形式提供纯Dart的依赖Flutter框架实现的库给Flutter的App使用，或者提供给Native App中的Flutter Module使用。 flutter create --template=package hello Flutter的插件，其实它也算是包的一种，是指提供可访问Native功能的Dart接口库，中间通过channel技术实现通信，插件同样可以通过发布版本提供。 flutter create --template=plugin -i objc -a java plugin_template -i -a 参数是分别指定iOS和Android两平台代码使用的语言（预设到模板中）。 混合开发混合开发是在Native App的基础上，嵌入Flutter的模块，共同开发。 flutter create -t module my_flutter 若想在混合开发中解除对Flutter的依赖，可以先来看看Flutter它所依赖的文件： Flutter库和引擎：Flutter.framework（flutter.jar）； Flutter工程的产物：App.framework（vm/isolate_snapshot_data/instr），App和Module最后的产物都是这种形式； Flutter Plugin：编译出各种Plugin的framework，内含插件的Dart以及响应它的OC代码（iOS:GeneratedPluginRegistrant.m; Android:GeneratedPluginRegistrant.java）。 将这三部分的编译结果抽取出来，打包成一个SDK依赖的形式提供给Native工程，就可以解除Native工程对Flutter工程的直接依赖了。 运行调试运行flutter run 编译flutter build ios --no-codesign [--simulator] #针对模拟器 flutter build apk 第一次打开Flutter的Android工程后，点击make project按钮先构造项目，实质就是通过gradle拉取对应依赖的库，而iOS工程若无podfile则可以直接运行编译，否则需先执行pod install命令。 热重载ctrl+s/cmd+s，保存文件变更，即可触发热重载，或者点击运行时工具栏中的reload按钮。 但是在以下情况会导致重载失败： 编译错误； 控件类型从StatelessWidget到StatefulWidget的转换； 全局变量和静态成员变量的变更。 修改了main函数中创建的根控件节点； 某个类从普通类型转换成枚举类型，或者类型的泛型参数列表变化； 遇到的问题iOS 在iOS端跑pod install时，提示/Path/To/ExistingApp/Flutter/engine路径无效，需要自行先在ExistingApp项目根目录下创建Flutter文件夹； iOS编译报错，FlutterPluginRegistrant Target中的GeneratedPluginRegistrant.h提示#import &lt;Flutter/Flutter.h&gt;找不到，可以手动为该Target引用上Flutter.framework，或将App Build Phases中的Run Script移到Check Pods Mnifest.lock之后； iOS编译报错，提示 /packages/flutter_tools/bin/xcode_backend.sh: No such file or directory，此时要在BuildSettings中的User-Defined中设置环境变量FLUTTER_ROOT，值flutter sdk的路径（包含packages文件夹），其对应App Run Script脚本中的$FLUTTER_ROOT； 如何切换设备，若Mac上有多个Xcode，且VScode使用最新版本的iPhone模拟器时，会有以下报错，此时，在VScode最底下的工具条中点击设备进行切换，如下图中的iPhoneX 12.0(ios)可切换为iPhoneX(ios Emulator) Code Signing Warning: “Runner” isn’t code signed but requires entitlements. It is not possible to add entitlements to a binary without signing it. Xcode10运行报错，在File-&gt;Workspace Settings-&gt;Build System 改成 Legacy Build System即可。参考 Multiple commands produce ‘/Users/Library/Developer/Xcode/DerivedData/Runner-dunimcekkdlkcxevvsirtjrlpkdg/Build/Products/Debug-iphonesimulator/Runner.app/Frameworks/Flutter.framework’: 1) Target ‘Runner’ has copy command from ‘/Users/Flutter/plugin_template/example/ios/Flutter/Flutter.framework’ to ‘/Users/Library/Developer/Xcode/DerivedData/Runner-dunimcekkdlkcxevvsirtjrlpkdg/Build/Products/Debug-iphonesimulator/Runner.app/Frameworks/Flutter.framework’2) That command depends on command in Target ‘Runner’: script phase “[CP] Embed Pods Frameworks” App.framework中的dart代码没更新时，在debug模式下在vs上reload一下即可。 运行崩溃，提示 Image Not Found。Flutter工程生成的App.framework和Flutter.framework导入应用工程后运行崩溃。在Embedded Binaries中添加上App.framework和Flutter.framework即可解决。 Library not loaded: @rpath/App.framework. Reason: Image Not Found 展示FlutterViewController后没有内容显示，同时报错了。将Flutter(插件)工程中的flutter_assets复制到应用工程，且以绝对路径添加，flutter_assets在与二进制文件同级目录下。 [VERBOSE-2:engine.cc(112)]Engine run configuration was invalid.[VERBOSE-2:FlutterViewController.mm(437)] Could not launch engine with configuration. 无法在模拟器上跑release相关的代码暂时还不支持在模拟器上启动release模式或跑引用了release模式下生成的Flutter App库的项目。而又为什么一定要跑release模式呢，因为debug模式生成的Flutter.framework含dart的虚拟机进行JIT，苹果暂时还不允许该动态编译（可以的话热更也就已经用上了）。debug模式是方便我们reload调试，不用重复停止和运行工程项目。参考 无法在真机上安装编译通过后在安装阶段报错，替换为debug模式下生成的App.framework和Flutter.framework则能正常安装（但运行时会崩溃，因为debug模式下导出的App.framework不含arm7s和arm64的真机框架）。而换回自行在Generated.xcconfig修改FLUTTER_BUILD_MODE和FLUTTER_FRAMEWORK_DIR为release值(具体值为release和path/to/flutter/bin/cache/artifacts/engine/ios-release)，通过运行Flutter项目后提出的App.framework和Flutter.framework则继续报错。后来通过以下方式编译Flutter项目再提取App.framework和Flutter.framework即解决。执行下面这条指令会自动更新Generated.xcconfig中上述提到的项为release值，这样编译得到的framework才有效。 flutter build ios --no-codesign --release 参考链接参考链接 app installation failed. Could not inspect the application package Android Android在gradle build时提示错误，将.flutter/packages/flutter_tools/gradle/flutter.gradle中的maven {...}一段移到jcenter()之上即可。参考 flutter Could not find lint-gradle-api.jar com.android.tools.lint:lint-gradle-api:26.1.2` Configuration(Target)的Android App中提示Please select Android SDK，此时运行选项 File -&gt; Sync Project with Gradle Files（在主面板的右上角也有便捷按钮）即可解决。参考 Android下，No Target Device Found，没有设备可用，在 Edit Configurations中，右下方的 Deployment Target 选项选择Open Select Deployment Target Dialog即可。参考 构建及定位Android的apk文件。菜单选项 Build-&gt;Build APK：是随机生成签名的构建，而 Build-&gt;Generate Signed APK：是指定签名的构建(签名为sha1文件)。构建完毕后，在弹出的Tips中点击Local链接可找到APK所在位置（flutterProject/build/host/outputs/apk） 功能实现问题透明背景官方探究中（跟进）: https://github.com/flutter/flutter/issues/9321 Flutter上调用原生桥接口报错没找到方法 Dart Error Unhandled exception MissingPluginException No implementation found for method 由于添加channel的注册表对象没与作为Flutter视图显示的对象（实现FlutterPlugin协议的FlutterViewController）一致。 即是下面该方法中，生成register的flutterViewController（register=[flutterViewController registrarForPlugin:pluginName]）在显示时，才能使用efun_flutter_plugin该channel名调用EFFlutterModule中的代理方法 + (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar &#123; FlutterMethodChannel* channel = [FlutterMethodChannel methodChannelWithName:@&quot;efun_flutter_plugin&quot; binaryMessenger:[registrar messenger]]; [registrar addMethodCallDelegate:[EFFlutterModule shareInstance] channel:channel]; &#125; 拉伸listView子项使用itemExtent属性，为listView内容指定高度。 限制listView滑动将itemExtent设为指定高度后，再配合shrinkWrap设为true，但此时仍可能还是可以手动滑动到listView，这时将listView的padding设为EdgeInsets.zero即可解决，因为listView内容的底部默认多出一个padding的白色栏，若此高度超出屏幕的话listView还是可以被手动滑动，然后还有设置上controller属性（无需实现监听），这样就既能限制滑动也能有效使键盘弹出后界面自动上移。 原生跳转到Flutter白屏1秒 提早注册 采用release下的AOT模式 跳转Route无效Navigator.pushNamed(context, arguments[&apos;route&apos;]);以上的context必须为当前渲染View中的context，否则push无效。 从Native获取到的字典无法直接复制给Map _InternalLinkedHashMap&lt;dynamic, dynamic&gt;’ is not a subtype of type ‘Map&lt;String, dynamic&gt; var resultValues = Map&lt;String, String&gt;.from(result);参考 收起键盘且清除焦点FocusScope.of(context).requestFocus(new FocusNode());为ScrollView添加滑动事件监听ScrollController scrollController = ScrollController(); scrollController.addListener(scrolledListView); ListView(controller: scrollController,...); Null scrolledListView() { scrollController.jumpTo(scrollController.position.minScrollExtent); }隐世滑动ScrollView到指定位置scrollController.jumpTo(scrollController.position.minScrollExtent);获取TextField的text值var textController = TextEditingController(); textfield = TextField( controller: controller, ... ); String wanted = textController.textTextField的装饰TextField( decoration: InputDecoration( hintText: placeholder, fillColor: Colors.white, filled: true, contentPadding: EdgeInsets.fromLTRB(5.0, 5.0, 5.0, 5.0), border: new OutlineInputBorder( borderRadius: BorderRadius.circular(5.0), ), ) );TextField输入密文TextField( obscureText: true, ... );为背景添加点击事件监听GestureDetector( onTap: () {}, child: backgroundWidget )显示TextfieldFlutter中的Textfield必须用MaterialApp包裹的Scaffold包裹的Widget来包裹，才能显示，否则渲染报错。 按比例分割的自动约束在Column或者Row中，的Widget均使用Expanded包裹，且对每个Expanded设置其flex属性，其比例就等于它的flex在其所在的Column或Row中所有Expanded的flex总和的占比，同时在Expanded中的控件则会被自动伸缩。 均匀分布Colomn或Row的子项： mainAxisAlignment: MainAxisAlignment.spaceEvenly获取屏幕SizeWidget build(BuildContext context) { Size size = MediaQuery.of(context).size; ... return widget }定义可继承的成员变量final platformMethodChannel = MethodChannel(&apos;com.fun.global/ui&apos;);往Native传值try { Map&lt;String, String&gt; map = { &quot;email&quot;: email, &quot;password&quot;: password }; final String result = await methodChannel.invokeMethod(&apos;#methodName&apos;,map); //不一定返回String，现为示例 print(result); } on PlatformException catch (e) { String message = &quot;exception: ${e.message}.&quot;; print(message); } 渐变动画Navigator.push( context, PageRouteBuilder( pageBuilder: (BuildContext context, _, __) { return EmailLoginView(); }, transitionsBuilder: (___, Animation&lt;double&gt; animation, ____, Widget child) { return FadeTransition( opacity: Tween&lt;double&gt;(begin: 0.0, end: 1.0).animate(animation), child: child, ); }, transitionDuration: Duration(milliseconds: 500),), );参考 倒计时Future&lt;Null&gt; onTapSendVerificationCodeButton() async &#123; if (_seconds == 0) &#123; setState(() &#123; _startTimer(); &#125;); else &#123; return; &#125; &#125; _startTimer() &#123; _seconds = 60; _timer = new Timer.periodic(new Duration(seconds: 1), (timer) &#123; if (_seconds == 0) &#123; _cancelTimer(); return; &#125; _seconds--; _sendButtonTitle = &apos;$_seconds(s)&apos;; setState(() &#123;&#125;); if (_seconds == 0) &#123; _sendButtonTitle = &apos;发送验证码&apos;; &#125; &#125;); &#125; _cancelTimer() &#123; _timer?.cancel(); &#125; Indicator先对State调用setState((){…})对界面刷新，在setState的回调块中将Indicator添加到Stack的顶层(children的最后一个元素，前面的元素为原来Widget)，一般通过一个状态变量控制该Stack是否要添加Indicator。https://codingwithjoe.com/flutter-how-to-build-a-modal-progress-indicator/ 获取平台信息import &apos;dart:io&apos;; Platform.isIOS;自定义路由跳转动画class MyCustomRoute&lt;T&gt; extends MaterialPageRoute&lt;T&gt; &#123; MyCustomRoute(&#123; WidgetBuilder builder, RouteSettings settings &#125;) : super(builder: builder, settings: settings); @override Widget buildTransitions(BuildContext context, Animation&lt;double&gt; animation, Animation&lt;double&gt; secondaryAnimation, Widget child) &#123; if (settings.isInitialRoute) return child; // Fades between routes. (If you don&apos;t want any animation, // just return child.) return new FadeTransition(opacity: animation, child: child); &#125; &#125; class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( onGenerateRoute:(RouteSettings settings) &#123; switch (settings.name) &#123; case &apos;/&apos;: return new MyCustomRoute( builder: (_) =&gt; new HomeView(), settings: settings, ); case &apos;/emailLoginView&apos;: return new MyCustomRoute( builder: (_) =&gt; EmailLoginView(), settings: settings, ); &#125; &#125;, ); &#125; &#125; 注意MaterialApp中的home和routes参数对onGenerateRoute的影响。 Android端的输入法不响应在activity生命周期onResume之后创建显示的flutterView，输入法不会响应。这个是flutter的bug。解决方法是，改一下window的可见性（Visibility），例如隐藏再显示。 桥Flutter 侧： class GlobalBridge &#123; static const MethodChannel global_ui_channel = const MethodChannel(&apos;com.fun.global/ui&apos;); //设置通道对Flutter的回调 static void registerChannel() &#123; global_ui_channel.setMethodCallHandler(handleMethodCall); &#125; //原生调Flutter的处理 static Future&lt;dynamic&gt; handleMethodCall(MethodCall methodCall) async &#123; if (method == &apos;xxx&apos;) &#123; ... &#125; &#125; //Flutter调Native static Future&lt;dynamic&gt; callMethod(String method,[dynamic arguments]) &#123; return global_ui_channel.invokeMethod(method,arguments); &#125; Native 侧（iOS）： //设置Flutter的插件名 + (void)registerWithRegistry:(NSObject&lt;FlutterPluginRegistry&gt;*)registry &#123; NSObject&lt;FlutterPluginRegistrar&gt;* registrar = [registry registrarForPlugin:@&quot;global_plugin&quot;]; [[self class] registerWithRegistrar:registrar]; &#125; //获取桥通道并设置通道对Native的回调 + (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar &#123; FlutterMethodChannel *globalUiChannel = [FlutterMethodChannel methodChannelWithName:@&quot;com.fun.global/ui&quot; binaryMessenger:[registrar messenger]]; [registrar addMethodCallDelegate:[EFNGlViewNavigator sharedNavigator] channel:globalUiChannel]; [EFNGlViewNavigator sharedNavigator].globalUiChannel = globalUiChannel; &#125; //Flutter调原生的处理 - (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result &#123; NSString *method = call.method; if ([method isEqualToString:@&quot;#request_bindFacebook&quot;]) &#123; [SomeClass requestWithCompletion:^(NSDictionary * _Nullable resultDict, NSError * _Nullable error) &#123; result(resultDict); &#125;]; &#125; &#125; //原生调Flutter - (void)callFlutterMethod:(NSString *)method arguments:(id)arguments result:(nullable FlutterResult)callback &#123; if (method.length&gt;0) &#123; [self.globalUiChannel invokeMethod:method arguments:arguments result:callback]; &#125; &#125; 调试在main函数中设置debugPaintSizeEnabled为true import &apos;dart:developer&apos;; void main() { debugPaintSizeEnabled=true; }cmd+shift+p，然后输入Flutter Toggle Debug Painting，开启Debug Painting模式 参考 其它国际化：参考异步：参考构造：参考alertDialog：参考正则表达式：参考AppUiDemo：参考效率：参考隐藏状态栏：参考 总结整体的环境搭建、开发流程并不复杂，Dart语言上手也很快。热重载对于调试App的UI真的是一大福音，不过在Module的混合开发模式下，要想与原生起到联调且能继续使用热重载功能的这部分还没搞清楚怎么弄。Flutter的UI搭建体验上也很好，经过封装，整体结构还是可以很清晰地被阅读，既有高的搭建效率也有高的易读性。这次实践主要是与原生交互、Flutter UI效果，后续还要了解网络、数据存储等一些关键部分。希望Flutter能继续保持现在高热的状态发展，造福跨平台的开发者，不要在某天和哪个平台的财主闹翻了而抛弃兼容影响大家。 Ref:Flutter中文网 Flutter iOS环境搭建 介绍视频 Flutter原理与实践 不要一知半解，深入理解flutter的编译原理，好吗 为什么Flutter会选择 Dart ？ 什么是 LLVM？Swift, Rust, Clang 等语言背后的支持 Dart-on-LLVM揭秘Flutter Hot Reload 开发包与插件Add-Flutter-to-existing-apps [iOS原生项目集成](Flutter https://juejin.im/post/5b4615576fb9a04fb614d382) 闲鱼flutter混合工程持续集成的最佳实践 Flutter新锐专家之路：混合开发篇 Change iOS rootViewController with Flutter Flutter框架基础 在Flutter中构建布局 MaterialApp使用详解 Flutter中的状态管理 Hummingbird: Building Flutter for the Web]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
        <tag>iOS</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter开发（介绍篇）]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2FFlutter%E5%BC%80%E5%8F%91%EF%BC%88%E4%BB%8B%E7%BB%8D%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍1. Flutter是什么？ Flutter是谷歌的是一款完全免费、开源的移动UI框架，其实也就是移动应用程序SDK，里面包含框架、控件和一些工具，可以快速在iOS和Android上构建相对高质量的原生用户界面，它也可以与现有的代码一起工作。 简单来说，Flutter可以用一套代码同时构建Android和iOS应用，并且可以达到原生应用一样的性能。 2. 使用什么语言？ Dart，它是一门动态类型或者说是可选类型的语言，可选类型的意思是既可以是动态类型也可以是静态类型。如果你想体验Dart语言，但又不想在你的电脑上安装Dart开发环境，那你可以使用Google提供的Dart云编译服务——DartPad DartPad是一个自由、开放的源码服务，帮助开发人员学习Dart语言，进入DartPad的源代码会被发送到谷歌云计算平台上运行，服务器会将源代码进行编译并处理成JavaScript返回给浏览器，编译产生的错误和警告也会返回 3. 响应式设计 Flutter采用响应式界面开发，以事件数据流作为核心开发模型。它的界面只能被描述而不能被操作，例如我们常用的TextView.setText()这样的API操作是不存在的。Flutter中使用Widget来描述界面，Widget只是界面的配置信息，当数据改变时，需要重新创建Widget去更新界面，这样虽然Widget会创建销毁得非常频繁，但Flutter使用的Dart虚拟机能高效处理这种短周期的轻量对象。 可能这里有人对响应式编程还不了解，这里简单介绍一下，响应式编程本质是基于观察者模式实现的，它在界面开发上的应用目的与MVVM有类似之处，但因MVVM实现Model和View双向绑定时有一定程度的状态混乱，所以后来结合函数式编程的思想催生了响应式界面开发，将MVVM中的VM使用事件数据流替代了，使Model利用事件流回到最初的事件驱动，再利用数据流来驱动View刷新，这里的事件流可以类比为被监听者，数据流可以类比为监听者预设的回调函数。 （响应式是与异步数据流交互的编程范式，思路是除了点击和悬停(hover)的事件，你还可以给其他任何事物创建数据流。数据流无处不在，任何东西都可以成为一个数据流，例如变量、用户输入、属性、缓存、数据结构等等，你可以监听这样的数据流，并做出相应的反应） 4. 热重载 只需要点击保存或者“Hot Reload”按钮，就可以立即更新到正在运行的设备上，不需要重新编译App，甚至不需要重启App，立即就可以看到更新后的样式。 优点缺点1. 优点 Flutter 最受欢迎的功能之一是其极速热重载。在开发过程中，Flutter 使用 JIT 编译器，通常可以在一秒之内重新加载并继续执行代码。只要有可能，应用程序状态在重新加载时保留下来，以便应用程序可以从停止的地方继续。 同时Flutter以 60fps 运行，使用 Flutter 创建的用户界面的性能远远优于使用其他跨平台开发框架创建的用户界面，不仅仅比跨平台的应用程序好，而且和最好的原生应用程序一样好。 一般移动应用上导致卡顿严重的原因还有一部分是源于垃圾回收的处理上，事实上，这只是访问共享资源（内存）的一种特殊情况，在很多语言中都需要使用锁，但在回收可用内存时，锁会阻止整个应用程序运行。但是 Dart 几乎可以在没有锁的情况下执行垃圾回收。Dart 使用先进的分代垃圾回收和对象分配方案，该方案对于分配许多短暂的对象（对于 Flutter 这样的反应式用户界面来说非常完美，Flutter 为每帧重建不可变视图树）都特别快速。Dart 可以用一个指针凹凸分配一个对象（不需要锁）。这也会带来流畅的滚动和动画效果，而不会出现卡顿。 另外，在 Flutter 的界面布局上，是直接通过 Dart 编码来定义，不需要使用 XML 或模板语言，也不需要使用可视化设计器之类的工具，是一种可阅读即可视的体验。 Flutter 内置了对Material Design和Cupertino (iOS-flavor)的 UI 组件库，也提供了可定制的 UI 组件，不再受制于OEM控件的限制 2. 缺点 增加了包体，Android版Flutter应用程序（没有Material Components，只是一个Center构建的单个widget的应用）的大小，并将其打包为release版，大小约为6.7MB。对于这个简单的应用程序，核心引擎大约3.3MB，框架+应用程序代码大约是1.25MB，LICENSE文件（包含在app.flx中）是55k，必需的Java代码.dex为40k，并且约有2.1MB的ICU数据。 3. 与其它跨平台方案对比 Flutter将UI组件和渲染器从平台移动到应用程序中，这使得它们可以自定义和可扩展。Flutter唯一要求系统提供的是canvas（画布，像iOS中的CoreGraph），以便定制的UI组件可以出现在设备的屏幕上。Dart程序和执行数据编码和解码的原生平台代码（蓝色，适用于iOS或Android）之间仍然有一个接口，但这能比JavaScript桥接器快几个数量级。下图是Flutter与React Native的实现对比 实现原理框架 Flutter的架构主要分成三层:Framework，Engine和Embedder。Framework使用dart实现，包括Material Design风格的Widget，和针对iOS的Cupertino风格的Widgets，其中又包括文本、图片、按钮等基础Widgets，然后是渲染，动画，手势等组成。 Engine使用C++实现，主要包括:Skia，Dart和Text。Skia是开源的二维图形库，提供了适用于多种软硬件平台的通用API。其已作为Google Chrome，Chrome OS，Android, Mozilla Firefox, Firefox OS等其他众多产品的图形引擎，Text文本渲染（先经过衍生自minikin的libtxt库，再由HartBuzz选择字型和成型），在Android和Fuchsia上使用FreeType渲染，在iOS上使用CoreGraphics来渲染字体。Dart部分主要包括:Dart Runtime，Garbage Collection(GC)，如果是Debug模式的话，还包括JIT(Just In Time)支持。 Embedder是一个嵌入层，即把Flutter嵌入到各个平台上去。这里做的主要工作包括渲染Surface设置,线程设置，以及插件等。从这里可以看出，Flutter的平台相关层很低，平台(如iOS)只是提供一个画布，剩余的所有渲染相关的逻辑都在Flutter内部，这就使得它具有了很好的跨端一致性。 编译编译器Dart2js：将Dart转换为js后再由浏览器上js的V8引擎进行词法和语法分析，得到语法树后再解释执行。DartVM，它是使用LLVM实现的，可以实现JIT和AOT两种编译方式。 编译方式：可以分为JIT和AOT JIT：Script Snapshot AOT：Machine Code JIT全称是Just In Time，代码可以在程序执行时期编译，因为要在程序执行前进行分析、编译，JIT编译可能会导致程序执行时间较慢；而AOT编译，全称Ahead Of Time，是在程序运行前就已经编译，从开发者修改代码、编译较慢，但运行时不需要进行分析、编译，因此执行速度更快。 在Release模式下： 上图为iOS的编译流程，gen_snapshot是dart编译器，采用了tree shaking(类似依赖树逻辑，可生成最小包，也因而在Flutter中禁止了dart支持的反射特性)等技术，负责生成汇编形式机器代码。再通过xcrun等工具链生成最终的App.framework。所有的dart代码，包括业务代码，三方package代码，它们所依赖的flutter框架代码，最终将会编译成App.framework。 上图为Android编译流程，vm/isolate_snapshot_data/instr内容均为arm指令，其中vm_中涉及runtime等服务(如gc)，用于初始化DartVM。isolate__则对应了我们的应用dart代码，用于创建一个新的isolate，isolate/vm_snapshot_data/instr均最后位于app的本地data目录下，而此部分又属于可写内容，可通过下载并替换的方式，完成App的动态更新。 而iOS的Flutter.framework和Android的flutter.jar对应了Flutter架构中的engine部分，以及Embedder。默认是从google仓库拉取。当需要自定义修改的时候，可通过下载engine源码，利用Ninja构建系统来生成。Flutter相关代码的最终产物是:App.framework(dart代码生成)和Flutter.framework(引擎)。 在Debug模式下： iOS的Flutter.framework和flutter.jar中是有JIT支持的，在Release模式下并没有JIT部分。而App.framework只有几个简单的API，其Dart代码存在于snapshot_blob.bin文件里，位于flutter_assets下。这部分的snapshot是脚本快照，里面是简单的标记化的源代码。所有的注释，空白字符都被移除，常量也被规范化，没有机器码，tree shaking或混淆。 小结一下，debug阶段下是使用Kernel Snapshot模式(对应JIT编译)，将dart代码生成标记化的源代码，在运行时编译，解释执行；release阶段下，ios使用AOT编译，编译器将dart代码生成汇编代码，最终生成app.framwork，android使用了Core JIT编译，dart转化为二进制模式，在VM启动前载入。 控件 如上图所示，在Flutter界面渲染过程分为三个阶段：布局、绘制、合成，布局和绘制在Flutter框架中完成，合成则交由引擎负责。 Flutter的控件树在实际显示时会转换成对应的渲染对象（RenderObject）树来实现布局和绘制操作。中间的Element是Flutter用来分离控件树和真正的渲染对象的中间层，控件用来描述对应的element属性，控件重建后可能会复用同一个element。 在Flutter里面，一切皆控件，它们的基类都是Widget，通过组合、嵌套不同类型的控件，就可以构建出任意功能、任意复杂度的界面。Widget 是每个 Flutter 应用的基础。每个 Widget 是一部分用户界面上不可变的定义。和其他框架把 View、controller、 Layout 和其他资源分开定义不一样，Flutter 具有一致的、唯一的对象模型Widget。 Flutter控件主要分为两大类，StatelessWidget和StatefulWidget，StatelessWidget用来展示静态的文本或者图片，如果控件需要根据外部数据或者用户操作来改变的话，就需要使用StatefulWidget。StatelessWidget和StatefulWidget并不会直接影响RenderObject的创建，它们只负责创建对应的RenderObjectWidget，StatelessElement和StatefulElement也是类似的功能。 StatelessWidget是无中间状态变化的widget，需要更新展示内容就得通过重新new，flutter推荐尽量使用StatelessWidget。 StatefullWidget是存在中间状态变化，它通过引入state类存放中间态，通过调用state.setState()进行此节点及以下的整个子树更新。这也是反映flutter界面开发是一种响应式编程，数据变更时发送通知到对应的可变更节点，由上到下重新create widget树进行刷新，这种思路比较简单，不用关心数据变更会影响到哪些节点。 热重载Flutter通过将新的代码注入到正在运行的DartVM中，来实现Hot Reload这种神奇的效果，在DartVM将程序中的类结构更新完成后，Flutter会立即重建整个控件树，从而更新界面。流程如下图所示 应用场景App端1. App开发 2. 包开发 包（Package），其实就是为Flutter的App或者Module而提供的，换其它的一些说法也可以说是组件、工具库包等。要和原生交互的，比如获取设备信息或者启动设备硬件等原生操作，又或者要封装Flutter框架中的功能，都可以通过这个形式实现后交付给Flutter项目或模块里使用。但是由原生触发Flutter中的函数或向Flutter索取信息的就没必要使用Flutter的插件实现了，也不合适，因为实现出来的Package并不是提供给Flutter项目使用，不过这种情况相对较少。原生和Flutter的交互主要是通过两端均注册对应的channel，然后利用其进行通信。 3. 混合开发 混合开发就是在原有的原生工程上创建Flutter的模块（Module），使原项目可以逐渐过渡，而不用一次性全部转移到Flutter上实现。 Web端Flutter团队正在开发一个Web的架构，叫作Hummingbird。与在移动应用中渲染出控件及界面一样，Hummingbird其实是在引擎层面上，即dart:ui代替原来的引擎，从而实现了在Web端上的渲染。 Flutter的团队也正在选择一组Web技术来完成构建的任务。Flutter一次渲染一帧UI，在每个帧内Flutter会构建widgets，执行布局，最后在屏幕上绘制。构建是通过dart2js，将所有 widget和widget frame都编译成了JavaScript，移植到Web上。布局则是除了文本外其它内容都由框架进行布局并编译到Web。而最难的部分则是绘制，目前在探索的绘制方案主要包括：HTML+CSS+Canvas和CSS Paint API两种。 CSS Paint API，它不是JavaScript独立完成的，它有自己的内存空间，它会在 DOM 更改提交之后，在浏览器的绘制阶段执行绘制工作，然后它是由显示列表所支持而非位图，这样它就具有了2D canvas的绘制效率和无像素化的优点，但不支持绘制文本。 HTML + CSS的方式可以称作为一种叫DomCanvas的画布，它被浏览器的显示列表支持，浏览器的渲染引擎可以帮我们完成一些优化，还可以任意应用变换而不必担心像素化。但若无法使用DomCanvas来表现图片的话，则转为使用Canvas，其性能和绘图兼容性好，但其表示为位图导致存在像素化的问题，及其操作代价较大，还需继续探研高效的方法。 桌面操作系统Flutter 的设计理念就是希望它可以作为一个灵活且便携的 UI 工具包，以适应各种需要绘制屏幕内容的平台。根据一些新闻消息，像Flutter Desktop Embedding 就是一个使 Flutter 运行于 macOS、Linux 和 Windows 等桌面操作系统的项目。 Ref:不要一知半解，深入理解flutter的编译原理 深入了解Flutter界面开发 揭秘Flutter Hot Reload Dart语法学习 为什么 Flutter 会选择 Dart Hummingbird: 在Web上运行Flutter应用 Flutter原理与实践 Flutter中文网]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
        <tag>iOS</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向（五）总结篇]]></title>
    <url>%2FiOS%2FiOS%E9%80%86%E5%90%91%EF%BC%88%E4%BA%94%EF%BC%89%E6%80%BB%E7%BB%93%E7%AF%87%2F</url>
    <content type="text"><![CDATA[最后一遍，总结一下关于安全开发的攻防要点，借鉴一些经验，记录一些小而黑的技巧，还有我读小黄书后的知识点梳理。 iOS安全开发防护摘要1、本地数据很多开发者喜欢用NSUserDefaults来存储一些全局数据，但是这些信息可以直接在app目录文件中读到，如果你也把username和password存在里面。。。当然，如果安全级别不高的程序，这么写也没什么问题；很多app也会存一些简单的数据到本地sqlite文件中，但实际上，完全可以使用加密sqlite的，当然，还是那句话，安全级别不高的程序，这么写没什么问题。 2、网络接口保护现在绝大部分的app都已经是联网程序了，经典模式就是http+json，客户端一解析，再做的漂亮一点就齐活。然而只要架上Charles或是tcpdump，完整的url request+response就看的清清楚楚。有了这些url，你的网络数据就无密可保，尤其是一些资源型的服务，直接通过getList的模式就能把所有的数据抓回来。这种情况下，即使是https也没用，Charles轻松就能搞定，可以看相关的文章。而且即使不用Charles或tcpdump，直接用代码hook网络接口，一样能把数据拿到。 另外插播一句：json是个好东西，它的展现就是一个Dictionary，数据呈现的非常清晰。但是它也绝对是最容易被盯上的点。设想一下，攻击者hook了接口数据，此时直接把json或Dictionary打印出来，信息是不是就一览无余了？在笔者的概念里，把Dictionary/json转成普通的业务对象再传递，即使被拦截，起码不会那么直观地被看到。当然了，这只能给逆向者增加一点麻烦，纯属细枝末节。笔者看过不少app，大概70%都是这种全裸奔的网络请求，比如“网易新闻”；剩下的会对url做一定的保护，比如加token和timestamp，如“36kr”，这样确实就把抓数据的难度陡然提升了；最“变态”的是“我查查”，他们直接把url做了加密/编码，这种情况下想要复制出来就需要大费周章，而且如果这种编码方式不是通用的，就更难逆向解析了。 3、混淆混淆有两种模式，一种是对函数名做混淆，另一种是对代码做混淆，两种都直接增加逆向的难度，但是挡是挡不住的，尤其是逆向者还有大把的时间。但但是代码混淆的性价比是很高的，就是你这边付出了一点时间，而黑客就要多付出几十倍的时间。 4、程序结构在app这种小而美的领域中，如果代码结构也设计的非常简洁漂亮，实在是一件令人赏心悦目的事情。不过对于逆向工程，越是这种设计结构，越容易定位，有时甚至不用上什么大招，直接从.h文件名和函数列表就能初步定位想要关心的核心代码，如WhatsApp。而一个反例是微信，微信的质量水准是有目共睹的，不过想要对它进行逆向工程就是一件比较痛苦的事情，因为最新的5.1有3000多个.h文件，如此庞大的代码量直接将逆向工作量提升一个数量级。在笔者的分析过程中，经常会被一堆的Mgr、Event、Service给搅的心烦意乱。这2个app只是两个极端的比较，毕竟WhatsApp全公司才50人，一个iPhone版的开发者不过数人，结构自然清晰；而微信早已是一个庞然大物，各部门之间相互合作，一层层的代码库抽象封装好给其它组调用，即使是很简单的调用可能也要串3、4个场，不过这样也间接增加了逆向的复杂度。 5、C或block函数现在iOS方面的逆向工具都是针对OC来的，而一旦代码以C函数或block函数来实现，相当于就采用了匿名函数，想要定位它就只能使用IDA，并且还很容易定位不准。笔者曾经在查看知乎日报的一段对token进行编码的问题上绕了很大的圈子，依然没有定准位，最后干脆放弃了，那段代码就是拿block来完成的。而且，如果是C代码，在IDA中看起来就不是易读的OC风格伪代码了，看起来也会比较累。 6、代码中的关键数据关键数据写在代码里，可以保存的是加密后的数据，使用的时候才解密处理。密钥要定期更换。比如3个月或半年换一次，如果密钥是从接口通过非对称加密获取的，直接修改服务端就可以了。如果密钥是写在代码里的。就等APP升级新的版本的时候，新版本的APP和其对应的接口版本都修改为新的密钥就可以了。旧的接口版本和APP版本还用以前的密钥，等强制更新的时候才会失效。如果一个APP 一个密钥用上几年都不变 ，是很危险的。离职的人员都可以直接用以前的代码来获取相关的数据。特别是支付相关的，有的服务端甚至没有去校验支付的金额或其他数据，导致离职人员用1分钱可以买到任何价格的线上产品。 7、代码方面在release环境下NSLog不要打印日志，否则iOS系统日志里都可以查看到，在.pch文件中加下面的几行代码就可以解决 #ifdef DEBUG #define NSLog(...) NSLog(__VA_ARGS__) #define debugMethod() NSLog(@&quot;%s&quot;, __func__) #else #define NSLog(...) #define debugMethod() #endif 而Swift中打印要用print。AFNetworking的allowInvalidCertificates属性要设置成false，validatesDomainName属性 设置成true。否则HTTPS通信就可以被解密。一般开发的测试环境的HTTPS不是CA颁发的，而是自签名证书，访问的也不是域名，而是IP。所以可以在测试环境忽略证书和域名 #ifdef DEBUG manager.securityPolicy.allowInvalidCertificates = YES; manager.securityPolicy.validatesDomainName = NO; #endif 开发者在意的安全防护1、想要保证程序中的信息不被截取几乎是不可能的，因为即使再加密，密文也总要变成明文供业务逻辑来使用，攻击者只要盯住这个点就能达到目标； 2、想保护服务器的资源客户端在相当程度上只是一个UI展现，即使被破解也不是那么重要的，真正重要的是服务器端的资源，那么就要在网络层进行防护了。现在大家都比较喜欢用http，而且都集中喜欢使用AF、ASI等几个开源库，逆向者只要盯住这几个口，就能把来往的request+response全部获取，进而可以仿制一个客户端，此时服务器的资源也就全面开放了。同样的，使用AsyncSocket也是一回事。此时有3种防护措施：1）服务器控制，不允许同一IP/客户端频繁抓取数据；2）对url加上token、timestamp，甚至url编码，虽然碰上高手还是不能100%安全，但是破解者想要达到目的，就需要考虑付出的精力是不是值得了；3）传输数据加密，并且将加解密的代码层级加深，尤其是放到C或block函数中，这样又将安全等级提高了一级。 3、想保护程序不被伪造或克隆克隆/伪造其实是件非常容易的事，甚至都不需要太多逆向工作，只要能把网络请求搞定，剩下的就是代码量、以及是否比被仿者做的更好的问题了。 总的来说，客户端没太多可保护的空间，它应该就是个业务展现和数据解析的工具，与其花精力想防这个防那个，不如把精力放在网络接口的保护上，尤其是加解密代码提取到C或block中。 微信的安全防护措施1、不在业务表现上做太多无用功除了代码结构比较庞大之外，微信没有做特别的动作； 2、服务器控制所有的决断性的动作由服务器控制，几乎不可能靠通过篡改客户端的代码来获取更大的权限。笔者曾经针对每天20个漂流瓶的限制尝试扩大权限，但是即使把本地代码逻辑放开，在超过20个瓶子之后，再捞回来的永远是海星，显然是服务器控制住了。当然，本地LBS坐标是无法被服务器控制的，这也就是坐标穿越插件能起作用的根本原因。 3、网络数据加密通过对网络接口的拦截，虽然能得到socket收取的二进制数据，首先是无法直接解密，其次是从那许多代码中找解密代码非常费劲，纵然加解密都能搞定，想伪造也十分麻烦，packet中包罗了相当多的信息，我估计就是把他们的代码开放给开发者，想理清这一部分都不是一件轻松的事情。 4、登录唯一性即使能够伪造微信的请求，一旦登录获取数据，原账号就会被踢下线并且得到通知，这本身就是一个安全警告，说起来也算是服务器控制。 以上引自这里。 行业状况爱加密以安全加固作为业务销售，为客户提出了各种安全方案，这里可以作为一个方向了解，地址。 技巧绕过ptrace反调试http://bbs.iosre.com/t/debugserver-ptrace/8037 反调试http://iosre.com/t/topic/8179 读《iOS应用逆向工程》梳理]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向（四）实战篇]]></title>
    <url>%2FiOS%2FiOS%E9%80%86%E5%90%91%EF%BC%88%E5%9B%9B%EF%BC%89%E5%AE%9E%E6%88%98%E7%AF%87%2F</url>
    <content type="text"><![CDATA[这篇主要是更详细地讲解一步一步找出目标的方法，从定位view，到定位其Controller，再到定位目标函数，以及一些工具在实际场景下的使用过程，比如IDA等。看到最后，我可能会被读者喷是标题党，但是我也很无奈，等下次吧，会再努力尝试一下。 逆向分析探寻作墙页面的C在App打开被墙的页面，然后使用Reveal或者cycript来分析当前显示页面V（View）的C（ViewController）。这里拿回上一篇文章所用的方式说明，利用cycript来定位 cy# [[UIApp keyWindow] recursiveDescription].toString() cy# button=#0x10c22b490 cy# [button setHidden:YES] cy# [button nextResponder] 列出keyWindow上视图的层级结构后，根据内容特征，如label的text属性值与当前页面上的内容对比，找出吻合的内容进行验证，例如设置控制的隐藏。确认是当前页面的控件后则可以开始根据响应链的关系，如子视图的nextResponder是父视图，若该父视图没有它的父视图了，则其nextResponder就是对应的Controller，通过这样来找出当前页面的Controller。 在被墙的页面上，根据确认支付按钮，找出了当前的C为XDBigNameViewController 探寻需解锁的数据源IDA分析 然后可以先直接在IDA上开始对业务逻辑进行初步的了解，定位到关键的函数。 XDBigNameViewController在其setUI方法上创建了一个XDBigNameTool（一个View），其delegate设为当前的XDBigNameViewController对象并叠加到后者自身的view属性上，可以猜测这个XDBigNameTool就是界面上的墙。 XDBigNameViewController确认了协议XDBigNameToolDelegate，该协议只有一个必须实现的方法 - (void)clickunlock; 。 触发 clickunlock 后会初始化订单ID和价格信息并存入数据库，然后push出一个叫XDPayViewController的页面。在这个XDPayViewController里，实现了StoreKit的一个代理方法 paymentQueue:updatedTransactions: ，意味着苹果内购完成后的回调可能执行该方法。 在这个paymentQueue:updatedTransactions:方法中，当transactionState返回的结果是1uLL时，执行XDPayViewController的completeTransaction: ，并且跳转到 LABEL_11 继续执行 switch ( (unsigned __int64)objc_msgSend(*(void **)(v21 + 8 * v7), &quot;transactionState&quot;) ) &#123; ... case 1uLL: objc_msgSend(v4, &quot;removeProgressingView&quot;); objc_msgSend(v4, &quot;addProgressingViewWithMessage:&quot;, CFSTR(&quot;交易成功，校验信息&quot;)); -[XDPayViewController completeTransaction:](v4, &quot;completeTransaction:&quot;, v8); v12 = objc_msgSend(&amp;OBJC_CLASS___SKPaymentQueue, &quot;defaultQueue&quot;); goto LABEL_11; ... LABEL_11: v13 = (void *)objc_retainAutoreleasedReturnValue(v12); objc_msgSend(v13, &quot;finishTransaction:&quot;, v8); v11 = (__int64)v13; ... &#125; 查看一下 StoreKit里SKPaymentTransactionState定义，再结合此处的提示信息，可以肯定case 1uLL里执行的操作是内购成功后的业务逻辑，调用了内部方法completeTransaction:。 XDPayViewController的completeTransaction:方法的（Pseudocode后的）反编译结果如下 从上面的实现可以大概看出做了以下几件事情 获取receipt-data； 生成请求验证前所需的其它参数（ordercode、paytype、payfrom、productId等）； 缓存ordercode信息； 定义请求的成功和失败回调block； 发起请求。 还没研究出怎么在block中打断点，参考 对逆向中的block打断点。 在Main Window的反编译里 可以看到X20这个寄存器一直保存着receipt-data，并在验证成功的回调block中被引用。 中间一段对X8的操作，是在收集请求前的参数集合，包括进行base64编码后的receipt-data 再经过分析，X29是方法里从头到尾没有被重新赋值过并一直保持激活的一个变量，在block中也被引用到，由此可以猜测它是方法传入的型参transaction，并在成功回调的block中对这个transaction进行finish操作。 这里尝试过使用cycript动态调用该completeTransaction:（先利用nextResponder找出当前XDPayViewController的地址，再进行调用），模拟传入nil作为transaction参数，这时会触发如下的网络请求 会返回错误的结果，提示验证失败。 此前已经在应用的沙盒、UserDefault、本地数据库等应用内的地方搜查过一遍，收费的数据并没有放在本地（按常理来说也不太可能这样存放）。 制作Tweak 到这里已经可以知道，收费内容是需要在receipt-data被验证成功了才会返回，到这里暂时就没辙了。 但若在知道破绽时，后续还需要做Tweak插件来hook一些方法的实现，就拿上面调用completeTransaction:并传入nil的transaction举例，做成Tweak。 首先，需要创建一个头文件，重新定义需要hook的类和方法或属性，目的是为了欺骗编译器使其能找到方法的声明 //In iosrefuguiqiming.h @interface XDPayViewController : NSObject - (void)completeTransaction:(id)transaction; @end //In Tweak.xm #import &quot;iosrefuguiqiming.h&quot; %hook XDPayViewController - (void)paymentQueue:(id)queue updatedTransactions:(id)transactions &#123; %log; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;iosre&quot; message:@&quot;processing&quot; delegate:self cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil]; [alert show]; [alert release]; [self completeTransaction:nil]; //%orig(queue,transactions); &#125; %end 然后make package、make install把deb安装到设备上，自动重启springboard或者tweak指定的进程后，deb就已经生效了。此时打开target app，点击内购后就马上弹出插入的提示框和发起支付的验证请求。 结语虽然结果未能达到目标，但过程足以让我们学会了动手去分析和改造一个app，像破壳、静态的反编译分析、动态的lldb调试、自制tweak等，让我们拥有了借鉴别人App的防御机制的能力，像这次的探索就再次印证了做苹果的内购，必须在服务端对收据进行验证，并且要建立完善的订单匹配逻辑，防止被攻击者重放或者篡改订单来获取收费资源。待之后有新思路再回来尝试重新进攻该次实践App的验证逻辑。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向（三）分析篇]]></title>
    <url>%2FiOS%2FiOS%E9%80%86%E5%90%91%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E6%9E%90%E7%AF%87%2F</url>
    <content type="text"><![CDATA[在逆向环境、工具准备得七七八八后，就开始学习一下逆向的套路。先要定位一个逆向的目标App和需要Tweak它的功能点，然后通过网络分析、动态分析、静态分析、沙盒分析等方法，来看看一般是如何给一个App做逆向的，怎么找出题目的位置、有什么解法。知道题该怎么解后，接着是学习怎么造Tweak，怎么把别人App的功能扭曲成自己想要的效果。 需求分析目标应用是一个关于协助起名字的App，通过提供指定的起名条件，例如双名还是单名，姓，出生年月，性别的信息，来获取（符合风水命理的）对应的名字组合。 结果中会有小吉名，大吉名，和大师推荐名的分类，其中大吉名和大师推荐名是要分别付款解锁才能查看的。 下面就针对这两个付款功能，尝试破解。 网络分析无论是启动应用的初始化请求，还是起名分析请求（已经请求过的起名条件则不会重复发起网络请求），都会带有下面这些参数 appname naming_fugui_iphone client iPhone device iPhone openudid FD7925AB-92C0-438C-B6E1-C58339553B57 idfa 332C7245-BCD7-458A-BB1F-BC25F6C2D541 sign 600D1E13A20AEADE3C5485E78418DC3E ver 1.2 appname代表当前App名称，估计其作用为区分不同的马甲包； client和device估计是区分操作系统、操作终端、设备类型等； openudid估计用户的唯一标识； idfa则是熟知的广告ID； sign估计就是对部分参数值按一定顺序（如appname+client+device+openudid+secretkey），加入密钥key进行签名后的序列（因为尝试修改了它，或者以上参数后就无法获取数据了） 在初始化请求中返回的data主要是一些动态控制的设置内容，如广告、好评、定时本地推送、跑马灯、支付渠道等等。 其次，起名分析请求获得的结果如下，其中tjm字段对应推荐名板块、zxm字段对应小吉名板块、info字段对应资料分析板块，对应大吉名板块的数据并没有返回。然后还有一个叫product的字段，里面包含了三个类似品项的对象，其中一个值得注意的是product_identifier为test的对象，它的价格只需0.01，萌生第一个试想：购买大吉名时换成这个商品ID是否行得通。 &#123; &quot;code&quot;: &quot;E00000000&quot;, &quot;msg&quot;: &quot;\u64cd\u4f5c\u6210\u529f\u3002&quot;, &quot;data&quot;: &#123; &quot;tjm&quot;: [...], &quot;zxm&quot;: [...], &quot;info&quot;: &#123;...&#125;, &quot;product&quot;: &#123; &quot;jiMing&quot;: &#123; &quot;product_identifier&quot;: &quot;zhangjingfuguiqiming001&quot;, &quot;product_name&quot;: &quot;...&quot;, &quot;product_desc&quot;: &quot;...&quot;, &quot;product_price&quot;: 25 &#125;, &quot;tuiJian&quot;: &#123; &quot;product_identifier&quot;: &quot;zhangjingfuguiqiming002&quot;, &quot;product_name&quot;: &quot;...&quot;, &quot;product_desc&quot;: &quot;...&quot;, &quot;product_price&quot;: 40 &#125;, &quot;tianJiang&quot;: &#123; &quot;product_identifier&quot;: &quot;test&quot;, &quot;product_name&quot;: &quot;...&quot;, &quot;product_price&quot;: 0.01 &#125; &#125; &#125; &#125; 砸壳先ssh到手机上 $ iproxy 4567 22 $ ssh -p 4567 root@127.0.0.1 先定位出其可执行文件所在的目录路径。在手机打开Target App，然后通过当前运行的进程查找 iPhone:~ root# ps -e | grep /Applications PID TTY TIME CMD1234 ?? 0:08.97 /var/containers/Bundle/Application/XXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/Target.app/Target Appstore App可执行文件是在/var/containers/Bundle/Application/样式的路径里面，再通过对比其相关的.app文件名含义就不难找到正确的路径。 然后是定位Target App的Documents目录路径。利用cycript进入Target App的进程后，使用cycript的语法获取当前沙盒目录中Documents的路径 iPhone:~ root# cycript -p targetAppPID cy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0] 最后就是将dumpdecrypted.dylib拷贝到Target App的Documents目录下(开启iproxy中) $ rsync -avz -e &quot;ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 4567&quot; --progress /Path/to/dumpdecrypted.dylib root@127.0.0.1:/var/mobile/Containers/Data/Application/YYYYYYY-YYYY-YYYY-YYYY-YYYYYYYYYYYY/Documents/ 开始砸壳 iPhone:~ root# cd iPhone:/path/to/Documents root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/XXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/Target.app/Target dyld: could not load inserted library ‘dumpdecrypted.dylib’ because no suitable image found. Did find: dumpdecrypted.dylib: required code signature missing for ‘dumpdecrypted.dylib’ /private/var/mobile/Containers/Data/Application/YYYYYYY-YYYY-YYYY-YYYY-YYYYYYYYYYYY/Documents/dumpdecrypted.dylib: required code signature missing for ‘/private/var/mobile/Containers/Data/Application/YYYYYYY-YYYY-YYYY-YYYY-YYYYYYYYYYYY/Documents/dumpdecrypted.dylib’Abort trap: 6 若报以上错误，可参考这里解决，思路就是使用MacOS上任何一个有效的证书对dumpdecrypted.dylib先做一个签名再拷贝到Target App的Documents ## 列出可签名证书 $ security find-identity -v -p codesigning ## 为dumpecrypted.dylib签名 $ codesign --force --verify --verbose --sign &quot;iPhone Developer: xxx xxxx (xxxxxxxxxx)&quot; dumpdecrypted.dylib 再次砸壳，就成功了 mach-o decryption dumper DISCLAIMER: This tool is only meant for security research purposes, not for application crackers. [+] detected 64bit ARM binary in memory.[+] offset to cryptid found: @0x1000b0c08(from 0x1000b0000) = c08[+] Found encrypted data at address 00004000 of length 3801088 bytes - type 1.[+] Opening /private/var/containers/Bundle/Application/4E0F7779-AD12-4634-9758-BB398648BBA6/XDQiMing.app/XDQiMing for reading.[+] Reading header[+] Detecting header type[+] Executable is a plain MACH-O image[+] Opening XDQiMing.decrypted for writing.[+] Copying the not encrypted start of the file[+] Dumping the decrypted data into the file[+] Copying the not encrypted remainder of the file[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset c08[+] Closing original file[+] Closing dump file 最后的最后，就是将砸壳后的文件 Target.decrypted 拷贝回MacOS上。 动态分析定位目标函数的方法主要是利用cycript实现。 1.注入进程 iPhone:~ root# ps -e | grep /Applications 5288 ?? 0:05.52 /var/containers/Bundle/Application/4E0F7779-AD12-4634-9758-BB398648BBA6/TargetApp.app/TargetApp 5296 ttys001 0:00.00 grep /var/containers/Bundle/Application/ iPhone:~ root# cycript -p 5288 2.分析UI层次结构 先打开TargetApp到需要定位的功能页面 然后使用历遍打印排查的方式，将逐级界面上的控件列表输出分析 cy# [[UIApp keyWindow] recursiveDescription].toString() ps：加.toString()是为了格式化换行符等符号，使输出更易于阅读，以往让cycript开启翻译格式符号功能的?expand指令已经失效了。 得出的结果是这个样子的 其中，发现有一个LCTableView，其包含的XDPayCell里有显示微信和推荐已安装微信的用户使用这两个文案的Unicode，所以可以基本确定LCTableView就是选择支付方式的列表。 &lt;LCTableView: 0x101a72600; baseClass = UITableView; frame = (0 192; 320 153.6); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x17045b0f0&gt;; layer = &lt;CALayer: 0x17043a820&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;320, 153.60000228881836&#125;&gt; &lt;UITableViewWrapperView: 0x1018fd400; frame = (0 0; 320 153.6); gestureRecognizers = &lt;NSArray: 0x17045b420&gt;; layer = &lt;CALayer: 0x17043a860&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;320, 153.59999999999999&#125;&gt; &lt;XDPayCell: 0x101a73000; baseClass = UITableViewCell; frame = (0 0; 320 51.2); autoresize = W; layer = &lt;CALayer: 0x17043b760&gt;&gt; &lt;UITableViewCellContentView: 0x10c22ced0; frame = (0 0; 320 51.2); gestureRecognizers = &lt;NSArray: 0x17045ce00&gt;; layer = &lt;CALayer: 0x17043bce0&gt;&gt; &lt;UIView: 0x10c22ccd0; frame = (0 0; 320 46.9333); layer = &lt;CALayer: 0x17043bb20&gt;&gt; &lt;UIImageView: 0x100779510; frame = (12.8 8.53333; 29.8667 29.8667); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17043bbc0&gt;&gt; &lt;UILabel: 0x10c22d1d0; frame = (55.4667 8.53333; 85.3333 12.8); text = &apos;\u5fae\u4fe1&apos;; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x170481ae0&gt;&gt; &lt;_UILabelContentLayer: 0x17442e6e0&gt; (layer) &lt;UILabel: 0x10c22d460; frame = (55.4667 27.3067; 320 11.0933); text = &apos;\u63a8\u8350\u5df2\u5b89\u88c5\u5fae\u4fe1\u7684\u7528\u6237\u4f7f\u7528&apos;; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x170480050&gt;&gt; &lt;_UILabelContentLayer: 0x17442e6c0&gt; (layer) &lt;UIImageView: 0x10c22d820; frame = (288 0; 19.2 46.9333); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x17043bb00&gt;&gt; ... &lt;UIButton: 0x10c22b490; frame = (12.8 362.667; 294.4 38.4); opaque = NO; layer = &lt;CALayer: 0x17043acc0&gt;&gt; &lt;UIButtonLabel: 0x10c22ca20; frame = (110.5 8.5; 73.5 21.5); text = &apos;\u786e\u8ba4\u652f\u4ed8&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x170480af0&gt;&gt; &lt;_UILabelContentLayer: 0x17043be80&gt; (layer) 然后与LCTableView同级的还有一个UIButton，也基本可以猜测到其就是确认支付按钮，下面来验证一下 cy# button=#0x10c22b490 cy# [button setHidden:YES] 发现确认支付按钮隐藏了，证实 #0x10c22b490 就是我们要找的对象。 如果界面布局比较复杂，控件繁多又没有什么标识能识别的时候，可以换个角度，通过找其相关的更易定位的控件或容器来间接寻找，同样是使用setHidden这种方式，配合上subviews和superView方法。 如果怀疑是一个独立的window时，可以使用[UIApp windows]来获取。 3.定位函数 cy# [button allTargets] [NSSet setWithArray:@[#&quot;&lt;XDPayViewController: 0x101194000&gt;&quot;]]] cy# [button allControlEvents] 64 cy# [button actionsForTarget:#0x101194000 forControlEvent:64] @[&quot;clickDetermineBtn&quot;] 这样就能定位到函数的实现是在 XDPayViewController类 的 clickDetermineBtn方法里。 分析函数地址的方法** 计算真实地址 **真实的地址其实就是偏移后的基地址 偏移后的基地址 = 偏移前的基地址 + ASLR偏移 ASLR偏移可以在lldb下使用以下指令获得 (lldb) image list -o -f [ 0] 0x00000000000c8000 /var/containers/Bundle/Application/4E0F7779-AD12-4634-9758-BB398648BBA6/Target.app/TargetApp(0x00000001000c8000) [ 1] 0x00000001005d0000 /Users/nero/Library/Developer/Xcode/iOS DeviceSupport/10.3.3 (14G60)/Symbols/usr/lib/dyld ... 在[序号]左边紧挨的地址就是 ASLR偏移 偏移前的基地址则需要在IDA/Hopper里查看 就拿上面XDPayViewController实现的paymentQueue:updatedTransactions:方法为例，其偏移后的地址就是 0xC8000 + 0x10006D5F8，即0x1001355F8。 需要注意ASLR偏移的选取，这里因为XDPayViewController属于TargetApp这个模块，所以选择TargetApp的ASLR偏移，即是ASLR偏移要根目标类所在的模块来决定。 真是需要动静结合才能获得真实的地址啊，而拿真实地址的主要目的是下断点 (lldb) b 0x100079ba4 Breakpoint 1: where = XDQiMing`_mh_execute_header + 154532, address = 0x0000000100079060 这里的where是不会直接显示相应的符号，这是因为OC方法没有符号，而lldb则用上了一个有符号的函数+offset来表示。 然后恢复进程继续运行，操作界面使断点所在函数触发，再结合使用lldb的调试指令就能获取或更改该函数运行时的变量数据 (lldb) c Process PID resuming Process 3255 stopped * thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 2.1 frame #0: 0x0000000100079ba4 XDQiMing`_mh_execute_header + 154532 XDQiMing`_mh_execute_header: -&gt; 0x100079ba4 &lt;+154532&gt;: sub sp, sp, #0xb0 ; =0xb0 0x100079ba8 &lt;+154536&gt;: stp d11, d10, [sp, #0x30] 0x100079bac &lt;+154540&gt;: stp d9, d8, [sp, #0x40] 0x100079bb0 &lt;+154544&gt;: stp x28, x27, [sp, #0x50] Target 0: (XDQiMing) stopped. (lldb) ni (lldb) si (lldb) p (char *)$r1 (lldb) register write $rn x 还有一种可以不用派上IDA就能知道真实地址的方法 (lldb) po [XDBigNameViewController _shortMethodDescription] &lt;XDBigNameViewController: 0x1004e33e0&gt;: in XDBigNameViewController: Properties: @property (retain, nonatomic) LCCollectionView* collectionView; (@synthesize collectionView = _collectionView;) ... Instance Methods: - (void) initData; (0x100079a00) ... in LCViewController: Properties: @property (retain, nonatomic) UIImageView* imageView; (@synthesize imageView = _imageView;) ... Instance Methods: - (void) pushViewControllerClass:(Class)arg1 Param:(id)arg2 Animated:(BOOL)arg3; (0x100141efc) ... 更多的黑科技请参阅这个链接。 静态分析头文件分析利用class-dump这款工具就能够将破壳的二进制文件中的所有头文件导出，然后建立一个空的Xcode工程导入这些头文件来翻看，方便阅读和查找内容 class-dump -H /Users/mac/Desktop/Payload/Kt.app -o /Users/mac/Desktop/Payload Mach-O分析Mach-O为Machine Object文件，是一种可执行文件、目标代码、动态库、内核转储的文件格式，利用IDA或者Hopper Disassembeler等交互式反汇编工具能实现对二进制代码的反汇编，他们能支持多种操作系统和多种CPU指令集反编译。 要注意反编译的可执行的二进制文件是fat binary还是thin binary，若是fat binary则应先减肥，指定保留一个架构（与IDA中选择反编译的架构需一致，但最新版本的IDA好像已经支持导入fat binary，可以免去对二进制文件减肥的步骤） $ lipo -info /path/to/execution Non-fat file: /path/to/execution is architecture: arm64 $ lipo -thin armv7 execution -output execution_armv7 IDA收费版的IDA还有一个很好用的功能，就是传说中的F5（Pseudocode） 作用就是将下图汇编样式的语法转换为下下图中的c样式语法表示，阅读代码时更直观方便，不用再去ARM官网查指令、分析寄存器的交替（其实这是基本功，先了解其原理还是有好处）。 这里有更详细的IDA介绍和IDA使用说明可供参考。 ARM汇编在调用方法前，常用R0R3（x0x3）寄存器保存objc_msgSend中的各个参数，分别是调用者、selector、参数1、参数2，在调用方法后，返回结果会存到R0，若有超过两个的参数时，多出的参数会存在栈中，地址是*SP、 *(SP+sizeOfLastArg)、…。 更多的汇编指令和详细说明可以参考ARM官方文档。 Tweak开发Tweak创建配置环境变量 export THEOS=/opt/theos 若不先配置环境变量的话，当make的时候会提示以下错误 Makefile:1: /makefiles/common.mk: No such file or directoryMakefile:6: /tweak.mk: No such file or directory 创建theos工程 /opt/theos/bin/nic.pl 1.选择模板=&gt;2.tweak项目名=&gt;3.deb包名=&gt;4.作者名=&gt;5.tweak作用对象（bundleID表示）=&gt;6.安装后需重启的应用（进程名表示） Tweak编写创建Tweak项目后，tweak.xm里的自带模板如下 /* How to Hook with Logos Hooks are written with syntax similar to that of an Objective-C @implementation. You don&apos;t need to #include &lt;substrate.h&gt;, it will be done automatically, as will the generation of a class list and an automatic constructor. %hook ClassName // Hooking a class method + (id)sharedInstance &#123; return %orig; &#125; // Hooking an instance method with an argument. - (void)messageName:(int)argument &#123; %log; // Write a message about this call, including its class, name and arguments, to the system log. %orig; // Call through to the original function with its original arguments. %orig(nil); // Call through to the original function with a custom argument. // If you use %orig(), you MUST supply all arguments (except for self and _cmd, the automatically generated ones.) &#125; // Hooking an instance method with no arguments. - (id)noArguments &#123; %log; id awesome = %orig; [awesome doSomethingElse]; return awesome; &#125; // Always make sure you clean up after yourself; Not doing so could have grave consequences! %end */ 涉及到函数语法包括： %hook：指定要hook的class，以%end结尾 %log：将函数的类名、参数等写入syslog %orig：调用hook的原函数 %group：将%hook分组 %init：初始化某个%group %ctor：显式定义调用%init %new：添加新函数 %c：作用等同于NSClassFromString Tweak编译编译 make Making all for tweak Nero_first_iosre…make[2]: Nothing to be done for `internal-library-compile’. 若手动删除了obj文件后再make出现以上报错的话，将和obj同一个目录的.theos里面的东西删掉就能解决。 若发现make后的obj里没有.dylib文件，那是因为新版本的Theos已经将它放到了obj同目录下的.theo/obj/debug/http://bbs.iosre.com/t/obj/3197 clang: warning: libstdc++ is deprecated; move to libc++ with a minimum deployment target of iOS 7 如果是出现以上warning的话，狗神说不用管。 warning: no debug symbols in executable 出现以上warning的话，可先尝试安装一下LZMA make[3]: * No rule to make target ‘/path/to/project.dylib’. Stop.make[2]: * [/path/to/project.dylib] Error 2make[1]: * [internal-library-all_] Error 2make: * [project.all.tweak.variables] Error 2 出现上面error的话，检查项目路径是否带有中文。 sudo cpan IO::Compress::Lzma 不过我安装了仍然存在该警告，但不影响打包 - -。 打包 make package dm.pl: building package com.nero.firstproject:iphoneos-arm&#39; in./packages/com.nero.firstproject_0.0.1-1+debug_iphoneos-arm.deb’ 看到上面的输出，即代表已经生成了可发布及安装的deb包了，在项目根目录下的packages文件夹中。 另外，可以使用dpkg查看deb包的结构 cd packages dpkg -c com.nero.firstproject_0.0.1-1+debug_iphoneos-arm.deb drwxr-xr-x root/wheel 0 2018-07-20 12:40 .drwxr-xr-x root/wheel 0 2018-07-20 12:40 ./Librarydrwxr-xr-x root/wheel 0 2018-07-20 12:40 ./Library/MobileSubstratedrwxr-xr-x root/wheel 0 2018-07-20 12:40 ./Library/MobileSubstrate/DynamicLibraries-rwxr-xr-x root/wheel 98704 2018-07-20 12:40 ./Library/MobileSubstrate/DynamicLibraries/firstproject.dylib-rw-r–r– root/wheel 57 2018-07-20 12:40 ./Library/MobileSubstrate/DynamicLibraries/firstproject.plist 若要重新编译，可使用下面指令，并清除.theos文件夹里的所有内容 make clean 然后是把deb安装到手机上。当然也可以手动用scp或者iFunbox拷贝deb到手机上再通过iFile安装。 make install THEOS_DEVICE_IP = 192.168.1.231ARCHS = arm64 armv7sTARGET = iphone:latest:8.0 有网友提到使用make install要注意的坑是将上面三行内容写在Makefile（相当于app项目中的info.plist文件）的最开头位置，原理也是通过scp完成。 安装deb后可以在Cydia的已安装-&gt;专业人士一栏里找到该deb，点击进去能查看详细的信息]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向（二）工具篇]]></title>
    <url>%2FiOS%2FiOS%E9%80%86%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B7%A5%E5%85%B7%E7%AF%87%2F</url>
    <content type="text"><![CDATA[关于逆向的第二篇，也还没是正题，先来以使用的目的来分类一下逆向需要哪些工具，分别在什么平台上使用和有什么作用，部分还直接带上使用示例。在一些使用方式比较绕的工具上，同样也准备了坑点的描述，记录一下痛苦的心路历程，一个问题可能就卡了1、2天。 砸壳工具dumpdecrypted平台：MacOS &amp; iOS作用：砸壳线上加密App 先从github下载dumpdecrypted的源码，然后编译成dylib备用。 $ cd dumpdecrypted-master/ $ make 静态分析工具class dump平台：MacOS作用：导出头文件 下载连接 $ open /usr/local/bin $ sudo chmod 777 /usr/local/bin/class-dump $ class-dump --help 将下载好的class-dump复制到/usr/local/bin 更改其权限 IDA平台：MacOS作用：反汇编。 下载地址，点evaluation version，选择下载IDA 7.0 Freeware。 动态分析工具Cycript平台：iOS作用：命令行上编写及运行代码，或注入代码到进程并执行。 直接在Cydia就能找到下载。 debugserver平台：iOS作用：debug App，供LLDB的接入。 在使用debugserver之前，首先要帮它添加task_for_pid权限，才能以进程为单位调试到别人的App。 先从iOS拷贝出debugserver $ rsync -avz -e &quot;ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 4567&quot; --progress root@127.0.0.1:/Developer/usr/bin/debugserver /Path/to/debugserver/ 然后对debugserver瘦身 $ lipo -info /Path/to/debugserver/ $ lipo -thin arm64 /Path/to/debugserver/ -output /Path/to/debugserver/ 不知ldid从哪个版本开始支持对fat binary的签名，反正最后的一个版本1.2.1是支持的，如果支持的可以忽略上面的瘦身步骤 再对对debugserver进行签名 ent.xml下载地址，下载到/Path/to/debugserver/后执行下面命令 $ cd /Path/to/debugserver/ $ /opt/theos/bin/ldid -Sent.xml debugserver //或直接用brew的ldid执行 可以使用下面指令确认一下debugserver的签名属性是否正确，若输出ent.xml的内容则证明签名成功 ldid -e debugserver 然后将debugserver拷贝回iOS $ rsync -avz -e &quot;ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 4567&quot; --progress /Path/to/debugserver/debugserver root@127.0.0.1:/usr/bin/debugserver 最后SSH到iOS为debugserver添加执行权限 iPhone:~ root# chmod +x /usr/bin/debugserver //或 iPhone:~ root# chmod 777 /usr/bin/debugserver 当ldid签名无效时，可以尝试用下面的方法重签debugserver codesign -s - --entitlements ent.plist -f debugserver 若上述的ent.xml、ent.plist下载不了，可以用下面的内容自己建文件 ent.plist &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/ PropertyList-1.0.dtd&quot;&gt; &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;com.apple.springboard.debugapplications&lt;/key&gt; &lt;true/&gt; &lt;key&gt;run-unsigned-code&lt;/key&gt; &lt;true/&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;task_for_pid-allow&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt; ent.xml &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt; &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;com.apple.springboard.debugapplications&lt;/key&gt; &lt;true/&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;task_for_pid-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;run-unsigned-code&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt; 另外，还可以在iOS上在BigBoss那安装上Toolchain，在Mterminal上使用ldid来直接对iOS的debugserver进行签名，免去了拷贝来拷贝去的麻烦。 使用示例 //启动进程并等待LLDB接入 //*为所有IP可接入，接入端口为1234 debugserver -x posix *:1234 /Path/to/TargetApp.app/TargetApp //附加进程 debugserver *:1234 -a /Path/to/TargetApp.app/TargetApp 第二版小黄书教的debugserver -x backboard无效，提示 debugserver-@(#)PROGRAM:debugserver PROJECT:debugserver-360.0.26.3 for arm64.error: failed to launch process debugserver: failed to get the task for process -1 网上说的debugserver -x spring无效，但输出的提示有指出有效的类型有哪些，估计spring已经被抛弃了 error: invalid TYPE for the –launch=TYPE (-x TYPE) option: ‘spring’Valid values TYPE are: auto Auto-detect the best launch method to use. posix Launch the executable using posix_spawn. fork Launch the executable using fork and exec. backboard Launch the executable through BackBoard Services. frontboard Launch the executable through FrontBoard Services. 最后还是用posix解决了。 LLDB平台：MacOS作用：调试用的Debugger 运行LLDB $ /Applications/Xcode.app/Contents/Developer/usr/bin/lldb 连接debugserver (lldb) process connect connect://IP:port Process 1281 stopped * thread #1, stop reason = signal SIGSTOP frame #0: 0x000000010061d000 dyld`_dyld_start dyld`_dyld_start: -&gt; 0x10061d000 &lt;+0&gt;: mov x28, sp 0x10061d004 &lt;+4&gt;: and sp, x28, #0xfffffffffffffff0 0x10061d008 &lt;+8&gt;: mov x0, #0x0 0x10061d00c &lt;+12&gt;: mov x1, #0x0 Target 0: (TargetApp) stopped. 暂时还没了解如何用iproxy的本地IP连接lldb，但我在iproxy开启的情况下使用Mac热点分配的IP来连接也很快，几秒而已。 使用示例 (lldb) b function //在函数起始位置设断点 (lldb) b l //查看所有断点 (lldb) b s -a 0xAddress //设置断点 (lldb) b dis [breakPointNumber] //禁用所有断点 [或指定禁用的断点号] (lldb) b en //启用所有断点 [或指定启用的断点号] (lldb) b del //删除所有断点 [或指定删除的断点号] (lldb) c //继续运行 //设置一组断点，通过以下命令 (lldb) b com add 1 // 指定某一断点下执行的指令集合 Enter your debugger command(s). Type &apos;DONE&apos; to end. (lldb) po [$r0 class] (lldb) p (char *)$r1 (lldb) DONE (lldb) ni //nexti 进入函数体的下一步 (lldb) si //stepi 不进入函数体的下一步 (lldb) register write $rn x //给指定寄存器rn赋值x //lldb下control + c能强制断掉现在的进程，相当于Xcode中的暂停 Theos平台：MacOS作用：编写和编译插件等 brew install dpkg brew install ldid 先安装两个Theos依赖的工具dpkg和ldid $ export THEOS=/opt/theos $ sudo git clone --recursive git://github.com/DHowett/theos.git $THEOS $ sudo chown -R 777 $THEOS $ cp /usr/local/Cellar/ldid/xx_version/bin/ldid /opt/theos/bin/ldid /opt/theos/bin/ldid $ sudo chmod 777 /opt/theos/bin/ldid $ sudo chmod 777 /opt/theos/bin/ldid $ cp /usr/local/Cellar/dpkg/xx_version/bin/dpkg-deb /opt/theos/bin/ldid /opt/theos/bin/dpkg-deb $ sudo chmod 777 /opt/theos/bin/dpkg-deb 下载Theos 复制ldid到Theos下，并更改其权限 复制dpkg-deb到Theos下，并更改其权限 辅助工具SSH平台：MacOS &amp; iOS作用：远程操作 如果打算先在iOS的Cydia上下载一个OpenSSH，然后在MacOS上的终端通过ssh连接上去iOS，而又当你的设备是10.3.x版本的系统，那就掉坑了。 SSH连不上？戳这里 简单来说，解决方法就是 卸载干净iOS上的OpenSSH和OpenSSL； 添加源 http://cydia.ichitaso.com/test ； 在上述源里下载 dropbear （OpenSSH的替代品）； 重新安装OpenSSL 这个时候再试试 ssh root@deviceIP （继续用22端口即可，有些网友说用2222的亲测不对） 不能使用OpenSSH的原因是 Yalu jailbreakCan I install OpenSSH?No, the jailbreak already comes with a working SSH daemon (dropbear). Installing OpenSSH can create issues on your jailbroken device. 中途确认dropbear进程是否有在运行的可用以下指令 ps aux|grep dropbear ps -e | grep ssh 接下来才进入正题，直接在同Wifi环境下ssh，此链接过程可能会十分漫长 $ ssh root@172.16.xxx.xxx 若嫌Wifi连接太慢，可以使用usbmuxd工具来利用usb实现连接，安装 $ brew install usbmuxd 把iPhone的默认端口22映射到Mac上 $ iproxy 4567 22 waiting for connection 保持上面的终端，新建一个终端进行连接（root的默认密码是alpine，有必要的话首次登陆后注意修改密码） $ ssh -p 4567 root@127.0.0.1 root@127.0.0.1&apos;s password: 当你想使用scp的时候直接改用rsync代替吧，在使用着iproxy的情况示例 rsync -avz -e &quot;ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 4567&quot; --progress /path/to/source/file root@127.0.0.1:/path/to/destination/ 这是参考自狗神分享的rsync替代scp帖子中，一位逆友后来更新的指令。 为什么要使用rsync替代scp？原因是yalu102自带的SSH缺少了scp，无法用WINSCP传输文件。 说一下我踩到的坑，在使用着iproxy的情况下执行scp来copy file示例如下（注意-P要大写） $ scp -P 4567 /Users/xx/dumpdecrypted.dylib root@127.0.0.1:/var/xx/Documents/ sh: scp: command not found 会发现出现以上报错，原因上面已交代。 google一下，发现部分外国帖子和大量国人已经针对上述问题总结出下面解决方法，先到Cydia下载wget到iOS上，然后在iOS的Terminal执行下面指令 wget mila432.com/scp ldid -S scp chmod 777 scp mv scp /usr/bin/scp 但是！mila432.com/scp 这个地址的内容已不存在了..最后，就是用rsync解决了（其实低端点用iFunBox等工具也是可以的），拷贝成功后会输出 building file list …1 file to considerdumpdecrypted.dylib 197528 100% 157.13MB/s 0:00:00 (xfer#1, to-check=0/1)sent 8418 bytes received 42 bytes 2417.14 bytes/sectotal size is 197528 speedup is 23.35 如果设备重启了，重新越狱后发现ssh连不上，提示以下错误的时候，则需要重装Dropbear和OpenSSL $ ssh -p 4568 root@127.0.0.1 ssh: connect to host 127.0.0.1 port 4568: Connection refused ssh: connect to host 127.0.0.1 port 4568: Connection refused ssh_exchange_identification: read: Connection reset by peer 如果出现下面的错误，清空文件/Users/username/.ssh/known_hosts中的内容就能解决。或者切换到一个新的映射端口上，如 iproxy 2222 22，区别开之前经常使用的端口 $ ssh -p 2222 root@127.0.0.1 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the ECDSA key sent by the remote host is SHA256:NhckXKSdwvSSLhago6bQb1/lIqRaLqAxHd6kHOPIYQs. Please contact your system administrator. Add correct host key in /Users/username/.ssh/known_hosts to get rid of this message. Offending ECDSA key in /Users/username/.ssh/known_hosts:3 ECDSA host key for [127.0.0.1]:2222 has changed and you have requested strict checking. Host key verification failed. dyld_decache平台：MacOS作用：抽取出iOS的系统库文件（从iOS拷贝到MacOS上）的二进制文件。 当要分析系统框架中的类及其方法时，就需要用到这个工具。抽取iOS库的二进制文件来分析，是为了避免MacOS和iOS上分析出的指令和地址数据不一致。 抽取后的库放入IDA分析库本身和其各个方法的基地址，然后结合ASLR偏移计算出偏移后的真实地址，最后就可以根据真实地址打断点。 下载地址]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向（一）越狱篇]]></title>
    <url>%2FiOS%2FiOS%E9%80%86%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89%E8%B6%8A%E7%8B%B1%E7%AF%87%2F</url>
    <content type="text"><![CDATA[关于逆向的第一篇先来讲一下 iOS 10.3.x 的越狱，因为之后的逆向工程均在iOS 10.3.3上进行，而且现在的iOS越狱工具有很多选择，哪个才适合作为逆向的基础环境，这里也稍作一下分析。然后介绍怎么使用工具进行越狱，有什么坑需要注意。 Meridianhttps://www.i4.cn/news_detail_18056.html 有Cydia 工作正常 支持RootApp安装 (iFile Filza 等） Substrate不生效（暂不支持插件，等更新） 采用全新的Kppless技术，支持iPhone7系+ 等待Substrate兼容 越狱性质，依然是 Semi-Untethered JailBreak 半完美越狱 （App引导越狱） 越狱完没有Cydia的同学，执行命令 uicache 刷新缓存即可 g0blinhttps://mrmad.com.tw/g0blin 目前處於RC2（公開測試）狀態，還不是很穩定，需要等後續更新才能解決不少問題。 目前還會導致第三方APP內無法使用 Touch ID錯誤問題。 GPS有可能會無法正成定位，可重新開機舊可解決。 少數用戶發現RC2版本會導致耗電問題。 少數GUI Tweaks會導致閃退現象，例如 BytaFonts 2、 Cydia Eraser等。 G0blin 是針對 iOS 10.3.x 越獄工具，: 是將 Yalu 的 KPP Bypass 技術加以拓展沿用至後續版本。: 正因為如此，所以兩者有很多相似的地方，: 同時也只支援搭載 A7-A9 處理器的裝置，也就是最新的 iPhone 7 跟 iPad Pro 10.5 是不支援的。对比https://mrmad.com.tw/ios1033-cydia-tweak-list g0blin用的v0rtex+yalu102kppbypass，支持16年前出的所有64位设备。cydia和substrate基本上能工作，目前g0blin官方还没有放出ipa，现在的妖精v4是jakejames利用妖精放出的源代码所开发的一个分支版本，目前已经停止更新，软件基本上可以使用可能还有一些小bug和不稳定的情况 meridian利用v0rtex+kppless越狱，支持所有64位设备，目前substrate不支持kppless，cydia部分工作，substrate完全不工作，需要等待saurik更新 https://www.ptt.cc/bbs/iOS/M.1517425637.A.0A3.html目前 iOS 10.3 有3個比較正式(知名)的越獄工具，分別是64位元 G0blin 10.3.x KPPBypass 與 Meridian iOS 10.x KPPLess，還有32位元的 h3lix iOS 10.x。KPPLess 由於不需要觸發KPP，所以會比 G0blin &amp; Yalu 還穩定許多。但是由於越獄的方式比較特殊，因此現有的 Cydia 跟 Substrate 都不相容。目前多數人知道的 Electra 也是這種 KPPLess 的方式。由於 G0blin 的運作方式，所以可以相容現有的 Cydia 也就是基本上是一個「完整」越獄工具，只不過還會有舊的 Yalu 老毛病：Failed,Retry 的小困擾。 工具集综上所述，故选择g0blin Cydia Impactorhttp://www.cydiaimpactor.com/ g0blinhttps://g0blin.sticktron.net/G0BLIN更新至RC2修复无法注销问题修复CYDIA图标不出现问题可卸载dropbear,安装OpenSSH代替 安装安装流程https://bbs.feng.com/read-htm-tid-11596960.html 打开cydia impactor，拖拽ipa到窗口里 输入APPLE ID回车，输入密码回车。（若有两重验证的可在apple id管理https://appleid.apple.com/account/manage里生成一个App-Specific Passwords来替代填入，或者先关闭双重验证） 回到手机信任越狱软件并打开。 点击jailbreak越狱按钮等待越狱（如果失败重启需重新尝试），完成后点respring注销即可。（如果安装过其他越狱工具的，第一次使用本工具请点击软件界面右上角叹号，勾选settings的re-install boottstrap保存后再进行越狱）越狱成功后即可直接打开cydia使用，可正常安装插件。重启后需要重新越狱。 （注意：如果重启了，需重新引导越狱，打开软件直接点jailbreak越狱即可。。请不要勾选boottstrap选项!!!不要勾选！！！不要勾选！！！不要勾选！！！不然越狱环境会被重置，插件会被删除。如果连g0blin都闪退，就需要用Impactor重新安装g0blin的ipa，同样重新越狱时不要打开boottstrap，点jailbreak就好了）注：cydia无法联网的可以试一下去助手下载乐网APP，连上V/PN后再打开cydia应该就可以联网了。然后在cydia安装conditionalWIFI2，重启后去设置-WIFI下拉看到cydia的wifi权限是默认关闭的，打开它就可以联网了，这时候蜂窝数据里面也会有cydia的联网选项。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>越狱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap手册]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2FBootstrap%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[介绍Bootstrap是Twitter推出的一个用于前端开发的开源工具包。它由Twitter的设计师Mark Otto和Jacob Thornton合作开发，是一个CSS/HTML/JS框架，用于开发响应式布局、移动设备优先的 WEB 项目。 支持预处理脚本：可以直接使用 Bootstrap 提供的 CSS 样式表，同时 Bootstrap 的源码是基于最流行的 CSS 预处理脚本 - Less 和 Sass 开发的。你可以采用预编译的 CSS 文件快速开发，也可以从源码定制自己需要的样式。 一个框架、多种设备：网站和应用能在 Bootstrap 的帮助下通过同一份代码快速、有效适配手机、平板、PC 设备，这一切都是 CSS 媒体查询（Media Query）的功劳。 Bootstrap3官网 开发环境&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--Responsive--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;!--CSS--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; &lt;!--jQuery--&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!--JavaScript--&gt; &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt; &lt;/html&gt; 网格系统 &lt;!-- 1.网格系统 flexbox支持一页12列；大屏幕时横放，小屏幕时竖放；若一行中不足12列，其它列可以扩展宽度； 包含四种列尺寸：xs=屏宽小于768px(phones)、sm=屏宽大于等于768px(tablets)、md=屏宽大于等于992px(small laptops)、lg=屏宽大于等于1200px(laptops/desktops) 两种容器类：container=响应式容器，在不同的屏幕宽度下，均有对应的固定尺寸，一般至于最外层做整体布局，有水平滚动条；container-fluid=用于100% 宽度，占据全部视口（viewport）的容器，没有水平滚动条 div类格式：col-*-#，*=网格种类(尺寸)，#=所占列数 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6&quot;&gt;6 cols&lt;/div&gt; &lt;div class=&quot;col-xs-1&quot;&gt;6 cols&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-4&quot;&gt;4 cols&lt;/div&gt; &lt;div class=&quot;col-xs-8&quot;&gt;8 cols&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 字体 &lt;!-- 2.字体 默认字体大小：14px；行高：1.428(&lt;body&gt;或&lt;p&gt;)；底间距：行高的一半或最小10px(&lt;p&gt;) &lt;h1&gt;至&lt;h6&gt;是从36px至12px &lt;small&gt;更小、更浅的标题 &lt;mark&gt;浅色的高亮标签 &lt;abbr&gt;CSS提示信息 &lt;blockquote&gt;包含&lt;footer&gt;代表引用中的长破折号以及浅色文案，用于引用中最后说明出处，若class=&quot;blockquote-reverse&quot;则标签右对齐 &lt;dl&gt; &lt;dt&gt; 列出强调的元素 &lt;code&gt; 高亮代码 &lt;kbd&gt;高亮键盘字符(黑底框) &lt;p&gt;中可使用text-muted、text-primary、text-success、text-info、text-warning、text-danger、bg-primary、bg-success、bg-info、bg-warning、bg-danger设置文字颜色和背景颜色，也可以使用text-left、text-justify、text-center、ext-nowrap、text-right对齐文字 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;h3&gt;Miscellaneous&lt;small&gt;stuff&lt;/small&gt;&lt;/h3&gt; &lt;p class=&quot;bg-info&quot;&gt;The Gutenberg Press 1454&lt;/p&gt; &lt;p class=&quot;text-success&quot;&gt;revolutionized printing&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;The only source of knowledge is experience.&lt;/p&gt; &lt;footer&gt;Albert Einstein&lt;/footer&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;kbd&gt;Enter&lt;/kbd&gt; is a &lt;code&gt;kbd&lt;/code&gt; element&lt;/p&gt; &lt;p class=&quot;bg-warning text-center&quot;&gt;Paragraph formats&lt;/p&gt; &lt;/div&gt; 表格 &lt;!-- 3.表格 table-border=所有边有边框 table-condensed=压缩列表，缩减单元格的内边距 table-striped=交替的行阴影(像斑马条纹) table-hover=在每行的周边添加灰色背景 table-responsive=创建响应式表格，当设备屏宽小于768px时表格会变为横向滑动 --&gt; &lt;div class=&quot;container table-responsive&quot;&gt; &lt;table class=&quot;table table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Column 1&lt;/th&gt; &lt;th&gt;Column 2&lt;/th&gt; &lt;th&gt;Column 3&lt;/th&gt; &lt;th&gt;Column 4&lt;/th&gt; &lt;th&gt;Column 5&lt;/th&gt; &lt;th&gt;Column 7&lt;/th&gt; &lt;th&gt;Column 8&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;td&gt;7&lt;/td&gt; &lt;td&gt;8&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;td&gt;7&lt;/td&gt; &lt;td&gt;8&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; 图片 &lt;!-- 4.图片 img-rounded=圆角图 img-circle=圆形图 img-thumbnail=极小图(自带自适应屏宽特性) img-responsive=创建响应式表格，当设备屏宽小于768px时图片自动调整尺寸适配屏幕大小 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;img src=&quot;http://images.freeimages.com/images/large-previews/b3d/flowers-1375316.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; class=&quot;img-rounded img-responsive&quot;/&gt;&lt;br&gt;&lt;br&gt; &lt;img src=&quot;http://images.freeimages.com/images/large-previews/b3d/flowers-1375316.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; class=&quot;img-circle&quot;/&gt;&lt;br&gt;&lt;br&gt; &lt;img src=&quot;http://images.freeimages.com/images/large-previews/b3d/flowers-1375316.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; class=&quot;img-thumbnail&quot;/&gt; &lt;/div&gt; 按钮 &lt;!-- 5.按钮 button该class可以用在&lt;button&gt;、&lt;a&gt;、&lt;input&gt;元素上 可用种类： btn-default、btn-primary、btn-success、btn-warning、btn-danger、btn-info、btn-link（以上其实与文字的种类类似，主要设置颜色特性）； btn-xs、btn-sm、btn-md、btn-lg（以上与网格列宽特性类似，设置按钮大小特性）； active=可用（与其它种类配套使用，像 class=&quot;btn-default btn-xs active&quot;） disabled=不可用 btn-block=与父容器宽一致。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn&quot;&gt;Basic&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;Default&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;Primary&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot;&gt;Success&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-warning&quot;&gt;Warning&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-danger&quot;&gt;Danger&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot;&gt;Info&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot;&gt;Link&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-xs&quot;&gt;Extra Small&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-sm&quot;&gt;Small&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-md&quot;&gt;Medium&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-lg&quot;&gt;Large&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn active&quot;&gt;Active&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn disabled&quot;&gt;Disabled&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-block&quot;&gt;Block&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-success btn-xs active btn-block&quot;&gt;Combine&lt;/button&gt; &lt;/div&gt; 表单 &lt;!-- 6.表单 * 表单用于接收输入，可以包括多行文本输入、选择性列表、单选按钮、多选框。默认都是垂直布局。 * 用&lt;form&gt;包裹整个表单。 * 用form-group类的&lt;div&gt;包裹普通输入&lt;input&gt;，文本输入&lt;textarea&gt;，选择列表&lt;radio&gt;或&lt;checkbox&gt;。 * 文本类输入需使用form-control类(&lt;textarea&gt;是用其作为type)。 * 可以将&lt;input&gt;放入&lt;label&gt;来创建一个多选或单选按钮，可各自放到checkbox类或radio类的&lt;div&gt;里，组成一个列表。 * 要在单行中显示多选或单选按钮组，则不能使用&lt;div&gt;包括选项按钮，并且要增加checkbox-inline类或radio-inline类到所有行内的label元素上。 * Bootstrap支持HTML5的输入type，包括：email、text、password、datetime、datetime-local、date、month、time、week、number、url、search、tel、color。 * &lt;form&gt;可以使用form-line类来使所有form内的元素在单行显示，单行显示的form会在屏宽少于768px时转换为竖表形式。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;email&quot;&gt;Email:&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;info&quot;&gt;Info:&lt;/label&gt; &lt;textarea type=&quot;form-control&quot; rows=&quot;3&quot; id=&quot;info&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;sellist&quot;&gt;Select One&lt;/label&gt; &lt;select class=&quot;form-control&quot; id=&quot;sellist&quot;&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;label class=&quot;radio-inline&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;rb&quot;&gt;Radio 1&lt;/label&gt; &lt;label class=&quot;radio-inline&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;rb&quot;&gt;Radio 2&lt;/label&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt;&lt;input type=&quot;checkbox&quot;&gt;Checkbox 1&lt;/label&gt; &lt;label&gt;&lt;input type=&quot;checkbox&quot;&gt;Checkbox 2&lt;/label&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; 下拉表单 &lt;!-- 7.下拉表单 * 将一个触发按钮和选项列表包裹在dropdown类的&lt;div&gt;内； * 触发按钮要设置为dropdown-toggle类（可搭配其它类设置样式），以及data-toggle属性为dropdown； * 在触发按钮里还需创建一个&lt;span&gt;元素，设其为caret类，让按钮右侧带有导三角指示符； * 创建类属性为dropdown-menu的ul列表元素； * 在ul列表中还是可以通过divider类和dropdown-header类的&lt;li&gt;做列表中的分隔线和分隔标题，还有active和disabled类，可对选项设置可用性。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;dropdown&quot;&gt; &lt;button class=&quot;btn btn-primary dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt; Languages &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;English&lt;/li&gt; &lt;li&gt;Spanish&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li class=&quot;dropdown-header&quot;&gt;Coding&lt;/li&gt; &lt;li&gt;C++&lt;/li&gt; &lt;li&gt;Java&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; 进度条 &lt;!-- 8.进度条 * 将progress-bar类的&lt;div&gt;放在progress类的&lt;div&gt;里，progress类的&lt;div&gt;相当于进度条的外框，默认总长是100%，progress-bar类的&lt;div&gt;相当于进度条内的一个进度对象，可放入多个进度对象，会在进度条框中堆叠； * progress-bar类的&lt;div&gt;还需设置role属性为progressbar，设置style属性的宽度为当前进度的百分比； * progress-bar类的&lt;div&gt;还可设置普通的HTML进度条属性value、min、max，分别对应aria-valuenow、aria-valuemin、aria-valuemax，均为可选的属性; * 额外的样式还包括：progress-bar-info、progress-bar-success、progress-bar-warning、progress-bar-danger、progress-bar-striped； --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;59&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width: 59%&quot;&gt; 59% Complete! &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-success&quot; role=&quot;progressbar&quot; style=&quot;width: 50%&quot;&gt;50&lt;/div&gt; &lt;div class=&quot;progress-bar progress-bar-warning&quot; role=&quot;progressbar&quot; style=&quot;width: 20%&quot;&gt;25&lt;/div&gt; &lt;div class=&quot;progress-bar progress-bar-danger&quot; role=&quot;progressbar&quot; style=&quot;width: 10%&quot;&gt;10&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 巨幕 &lt;!-- 9.超大屏 一个圆角的灰色大框；区分开当前页面的其它元素，突出显示；框内的文本也会被放大；若放到container之外，会扩展到屏幕的各个边界。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;h1&gt;SoloLearn&lt;/h1&gt; &lt;p&gt;Learn to code for FREE!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 警告框 &lt;!-- 10.警告框 * 警告框必须使用以下样式中的其中一个指定:alert-info、alert-success、alert-warning、alert-danger; * 若需要alert是可消失的，需对类型属性添加alert-dismissable类，然后在alert中的&lt;link&gt;或&lt;button&gt;中添加class=&quot;close&quot;和data-dismiss=&quot;alert&quot;，使其触发能同时关闭alert； --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;alert alert-success&quot;&gt;Success Alert!&lt;/div&gt; &lt;div class=&quot;alert alert-warning&quot;&gt;Warning Alert!&lt;/div&gt; &lt;div class=&quot;alert alert-danger&quot;&gt;Danger Alert!&lt;/div&gt; &lt;div class=&quot;alert alert-info alert-dismissable&quot;&gt; &lt;a class=&quot;close&quot; data-dismiss=&quot;alert&quot; href=&quot;#&quot;&gt;Close&lt;/a&gt; Information Alert! &lt;/div&gt; &lt;/div&gt; 嵌井 &lt;!-- 11.嵌井 一个圆角的灰色框，可以通过指定类控制其显示尺寸：well-sm、well-lg; 通常用于给元素一个嵌入的简单效果。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;well well-sm&quot;&gt;Small well&lt;/div&gt; &lt;div class=&quot;well&quot;&gt;Normal well&lt;/div&gt; &lt;div class=&quot;well well-lg&quot;&gt;Large well&lt;/div&gt; &lt;/div&gt; 标记 标签 &lt;!-- 12.标记 标签 * 标记badge类可以给一个元素附上数值显示; * 标签label类可以给一个元素附上其它信息显示，且必须指定其中一个样式：label-default、label-primary、label-info、label-success、label-warning、label-danger； * 以上均使用span附加（放入）到要附加显示的元素上 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;button class=&quot;btn&quot;&gt; Click&lt;span class=&quot;badge&quot;&gt;59&lt;/span&gt; &lt;/button&gt; &lt;p&gt; Paragraph &lt;span class=&quot;label label-primary&quot;&gt;Label&lt;/span&gt; &lt;/p&gt; &lt;p&gt; Paragraph &lt;span class=&quot;label label-info&quot;&gt;Label&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; 媒体对象 &lt;!-- 13.媒体对象 * 为便于对齐媒体对象 * 使用media类的&lt;div&gt;包裹所有要对齐的所有内容； * 使用类media-left、media-right、media-top、media-middle、media-bottom(后三者一般用于当内容很大的情况)的&lt;div&gt;来包裹要对齐媒体标签，媒体标签的类且需为media-object； * 内容需要使用media-body类的&lt;div&gt;包裹； * 内容中的标题可以使用media-heading类设定； * 需要注意包裹内容和媒体的&lt;div&gt;顺序，根据其所设定的位置。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;media&quot;&gt; &lt;div class=&quot;media-left&quot;&gt; &lt;img src=&quot;http://www.sololearn.com/images/fb-story-icon.jpg&quot; width=&quot;40&quot; height=&quot;40&quot; class=&quot;media-object&quot;&gt; &lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;SoloLearn&lt;/h4&gt; Let&apos;s Collaborate! &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;media&quot;&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;FreeCodeCamp&lt;/h4&gt; Let&apos;s Collaborate! &lt;/div&gt; &lt;div class=&quot;media-right&quot;&gt; &lt;img src=&quot;http://avatars3.githubusercontent.com/u/9892522&quot; width=&quot;40&quot; height=&quot;40&quot; class=&quot;media-object&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 跑马灯 &lt;!-- 14.跑马灯 * 默认样式中，有小圆形的指示器标出各滑块的序号、当前激活的滑块；可手工来回切换幻灯片； * 用自定义id的&lt;div&gt;包裹所有跑马灯内容，&lt;div&gt;的类属性需要指定为carousel(可配合指定为slide，会带有过渡动画)，然后还要指定data-ride属性标记轮播在页面加载时就开始动画播放； * 在上述div里的外层内容，会包括指示器、媒体内容、控制器； * 指示器使用类carousel-indicators的&lt;ol&gt;实现，里面的每一项&lt;li&gt;都需要有属性data-target指向跑马灯div的id，和属性data-slide-to指出点击时显示哪个对应的滑块； * 媒体内容用carousel-inner类的div包裹，然后将不同的媒体用item类的div分离，同时指定active类表明当前显示的媒体； * item类div里除了包裹媒体，还包裹carousel-caption类的div，承载当前媒体滑块外的额外内容，item在carousel-inner类的div里是位于中下方； * 在carousel-inner类div里，也可以添加另外的&lt;a&gt;控件来控制切换，类属性设置为carousel-control(一般配合left或right类定控件在当前跑马灯上的位置)，href要指向跑马灯的id，同时要设置一个data-slide属性prev或next指定触发切换的向前一页还是向后一页。控件中可以指定指示图标&lt;span&gt;，默认可直接点击控件的阴影范围触发； * glyphicon来自于Glyphicon Halfings，Carousel是一个插件，在Bootstrap的JS文件中。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;logoCarousel&quot; class=&quot;carousel&quot; data-ride=&quot;carousel&quot;&gt; &lt;ol class=&quot;carousel-indicators black&quot;&gt; &lt;li data-target=&quot;#logoCarousel&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#logoCarousel&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div class=&quot;carousel-inner&quot;&gt; &lt;div class=&quot;item active&quot;&gt; &lt;img src=&quot;https://images.freeimages.com/images/large-previews/9fc/yet-another-flower-1399208.jpg&quot; style=&quot;width: 100%&quot;&gt; &lt;div class=&quot;carousel-caption&quot;&gt; &lt;h3&gt;Caption 1&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;https://images.freeimages.com/images/large-previews/b3d/flowers-1375316.jpg&quot; style=&quot;width: 100%&quot;&gt; &lt;div class=&quot;carousel-caption&quot;&gt; &lt;h3&gt;Caption 2&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;a class=&quot;left carousel-control&quot; href=&quot;#logoCarousel&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#logoCarousel&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 模态框 &lt;!-- 15.模态框 弹出一个显示在当前页面顶部对话窗/框，是一个插件。 通过指定按钮button的data-toogle属性为modal，data-target属性为modal类的div的id，那么按钮点击时就能触发出该modal类div的模态对象； * 模态对象中包裹模态对话框modal-dialog； * 模态框中包裹模态内容modal-content； * 模态内容可包括：modal-header(可在其中包含modal-title)、modal-boody、mode-footer，来指定模态窗中的不同部位内容; * 可以指定关闭模态框的按钮，按钮需要设定属性data-dismiss=&quot;modal&quot;才能在触发按钮时关闭模态框。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;button type=&quot;button&quot; data-toggle=&quot;modal&quot; data-target=&quot;#myModal&quot;&gt;Open Modal&lt;/button&gt; &lt;div id=&quot;myModal&quot; class=&quot;modal&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;h3 class=&quot;modal-title&quot;&gt;Header&lt;/h3&gt; &lt;button data-dismiss=&quot;modal&quot;&gt;X&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt;Body&lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt;Footer&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 悬浮 &lt;!-- 16.悬浮 将一个元素贴在页面的一个区域上，滚动页面时该悬浮元素保持固定在这个指定区域不动。 （放在该位置上可能因跑马灯的缘故无法显示，放置到页面初始显示的位置时能正常悬浮显示） --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;affixed&quot; data-spy=&quot;affix&quot;&gt;Affix&lt;/div&gt; &lt;div class=&quot;jumbotron&quot;&gt;Content for Scrolling&lt;/div&gt; &lt;div class=&quot;jumbotron&quot;&gt;Content for Scrolling&lt;/div&gt; &lt;div class=&quot;jumbotron&quot;&gt;Content for Scrolling&lt;/div&gt; &lt;/div&gt; 分组按钮 &lt;!-- 17.分组按钮 btn-group类的div为默认横排按钮组，btn-group-vertical为竖排。 按钮组的尺寸可以使用类指定包括btn-group-xs、btn-group-sm、btn-group-lg。 btn-group-justified类可使按钮组宽度根据屏宽适配。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;btn-group btn-group-xs&quot;&gt; &lt;button class=&quot;btn btn-success&quot;&gt;h1&lt;/button&gt; &lt;button class=&quot;btn btn-warning&quot;&gt;h2&lt;/button&gt; &lt;button class=&quot;btn btn-danger&quot;&gt;h3&lt;/button&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;btn-group-vertical&quot;&gt; &lt;button class=&quot;btn btn-success&quot;&gt;v1&lt;/button&gt; &lt;button class=&quot;btn btn-warning&quot;&gt;v2&lt;/button&gt; &lt;button class=&quot;btn btn-danger&quot;&gt;v3&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; 列表组 &lt;!-- 18.列表组 * 对&lt;ul&gt;的类属性指定为list-group，对&lt;li&gt;的类属性指定为list-group-item； * 可继续对&lt;li&gt;指定类属性为active或disabled； * 样式可以继续使用以下类设置：list-group-item-success、list-group-item-info、list-group-item-warning、list-group-item-danger; * 也可以使用div或a组成列表组，不局限于ul和li。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item active&quot;&gt;HTML&lt;/li&gt; &lt;li class=&quot;list-group-item disabled&quot;&gt;CSS&lt;/li&gt; &lt;li class=&quot;list-group-item list-group-item-success&quot;&gt;JS&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 嵌板 &lt;!-- 19.嵌板 * 镶边框，先用panel类的div包裹一层，同时有以下种类可以设样式：panel-default、panel-primary、panel-success、panel-info、panel-warning、panel-danger； * 然后用以下类添加第二层div：panel-heading、panel-body、panel-footer； * 可以用panel-group类的div组织起panel类的div。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;panel panel-success&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt;Head&lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt;Body&lt;/div&gt; &lt;div class=&quot;panel-footer&quot;&gt;Foot&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;panel panel-danger&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt;Head&lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt;Body&lt;/div&gt; &lt;div class=&quot;panel-footer&quot;&gt;Foot&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 折叠 &lt;!-- 20.折叠 收纳或显示大量的内容，通过按钮触发 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;button data-toggle=&quot;collapse&quot; data-target=&quot;#myCollapsible&quot; class=&quot;btn btn-warning&quot;&gt;Show/Hide&lt;/button&gt; &lt;div id=&quot;myCollapsible&quot; class=&quot;collapse&quot;&gt;Bootstrap Collapsibel&lt;/div&gt; &lt;/div&gt; 页标 &lt;!-- 21.页标 尺寸大小可以使用这些类控制：pagination-sm、pagination-lg --&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 路径导航 &lt;!-- 22.痕迹导航 作为分层导航表单的一种页标，即是导航的路径 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul class=&quot;breadcrumb&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Languages&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Programming&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;C&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Intro&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 翻页器 &lt;!-- 23.翻页器 * 上一页、下一页； * 若要分别将上一页和下一页按钮放在屏幕左边和右边，给li的类属性设为对应的previous和next。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul class=&quot;pager&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Previous&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Next&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul class=&quot;pager&quot;&gt; &lt;li class=&quot;previous&quot;&gt;&lt;a href=&quot;#&quot;&gt;Previous&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;next&quot;&gt;&lt;a href=&quot;#&quot;&gt;Next&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 导航栏 &lt;!-- 24.导航栏 * 使用&lt;nav&gt;标签，并设置类属性为navbar和navbar-default/navbar-inverse（即默认或倒置样式）； * 在&lt;nav&gt;里创建类属性为navbar-header的&lt;div&gt;，并在其中创建类属性为navbar-brand的&lt;a&gt;元素作为主要的头项； * 在&lt;nav&gt;里继续创类属性为nav和navbar-nav的&lt;ul&gt;，作为次要的子项列表； * 可以对项指定类属性active或disabled设定是否可用； * 可使用navbar-right作为子项列表的类属性，来设置子项列表在导航栏中的对齐方向； * 使用navbar-fixed-top、navbar-fixed-bottom作为&lt;nav&gt;的类属性可以设定导航栏固定在页面的顶部或底部，不会在滚动时移出页面。 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;navbar-brand&quot;&gt;Home&lt;/a&gt; &lt;/div&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Page0&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Page2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Page 4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; 滚动&lt;!-- 25.滚动 * 为自动更新在基于滚动位置的导航栏中的链接，可以使用scrollspy； * &lt;body&gt;的数据监测属性设为scroll，数据偏移属性设为20（预留导航栏高度）； * 可滚动区域需要CSS的位置属性是与scrollspy关联才有效； * 是一个JS插件。 --&gt; &lt;body data-spy=&quot;scroll&quot; data-offset=&quot;20&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;nav class=&quot;navbar navbar-inverse navbar-fixed-top&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;navbar-brand&quot;&gt;Home&lt;/a&gt; &lt;/div&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#p0&quot;&gt;Part 0&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#p1&quot;&gt;Part 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#p2&quot;&gt;Part 2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div id=&quot;p0&quot;&gt;0:Scroll and See the Navigation Bar&lt;/div&gt; &lt;div id=&quot;p1&quot;&gt;1:Scroll and See the Navigation Bar&lt;/div&gt; &lt;div id=&quot;p2&quot;&gt;2:Scroll and See the Navigation Bar&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 其它&lt;!-- 26.其它 * 选项卡：tabbable、nav-tabs、tab-content、tab-pane * 手风琴切换：panel-collapse --&gt; 代码参考自SoloLearn]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>bootstrap</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vapor（七）工具篇]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FVapor%EF%BC%88%E4%B8%83%EF%BC%89%E5%B7%A5%E5%85%B7%E7%AF%87%2F</url>
    <content type="text"><![CDATA[搬最后一篇关于Vapor的砖，介绍一下Vapor中可选用的工具，包括Command、Console、Crypto。 TerminalTerminal和Console二选一使用，两者只是创建方式不一样 import Vapor let terminal = Terminal() print(terminal is Console) // true terminal.print(&quot;Hello&quot;) let console = try req.make(Console.self) console.print(&quot;Hello&quot;) 无论是使用 print(_ :) 还是 warning(_ :)，实质都是调用强大的output(_:)实现 /// Prints &quot;Hello, world&quot;, but the word &apos;world&apos; is blue. console.output(&quot;Hello, &quot; + &quot;world&quot;.consoleText(color: .blue)) 也可以使用Log，实现Logger协议来自定义输出的信息，默认有效的是PrintLogger let logger = try req.make(Logger.self) logger.info(&quot;Logger created!&quot;) 输入 /// Accepts input from the terminal until the first newline. let input = console.input() console.print(&quot;You wrote: \(input)&quot;) /// Outputs the prompt then requests input. let name = console.ask(&quot;What is your name?&quot;) console.print(&quot;You said: \(name)&quot;) /// Prompts the user for yes / no input. if console.confirm(&quot;Are you sure?&quot;) &#123; // they are sure &#125; else &#123; // don&apos;t do it! &#125; SPM let package = Package( name: &quot;Project&quot;, dependencies: [ ... /// 💻 APIs for creating interactive CLI tools. .package(url: &quot;https://github.com/vapor/console.git&quot;, from: &quot;3.0.0&quot;), ], targets: [ .target(name: &quot;Project&quot;, dependencies: [&quot;Console&quot;,&quot;Logging&quot;, ... ]) ] ) Command命令行工具 /// Generates ASCII picture of a cow with a message. struct CowsayCommand: Command &#123; var arguments: [CommandArgument] &#123; return [.argument(name: &quot;message&quot;)] &#125; var options: [CommandOption] &#123; return [ .value(name: &quot;eyes&quot;, short: &quot;e&quot;, default: &quot;oo&quot;, help: [&quot;Change cow&apos;s eyes&quot;]), .value(name: &quot;tongue&quot;, short: &quot;t&quot;, default: &quot; &quot;, help: [&quot;Change cow&apos;s tongue&quot;]), ] &#125; var help: [String] &#123; return [&quot;Generates ASCII picture of a cow with a message.&quot;] &#125; /// See `Command`. func run(using context: CommandContext) throws -&gt; Future&lt;Void&gt; &#123; let message = try context.argument(&quot;message&quot;) /// We can use requireOption here since both options have default values let eyes = try context.requireOption(&quot;eyes&quot;) let tongue = try context.requireOption(&quot;tongue&quot;) let padding = String(repeating: &quot;-&quot;, count: message.count) let text: String = &quot;&quot;&quot; \(padding) &lt; \(message) &gt; \(padding) \\ ^__^ \\ (\(eyes)\\_______ (__)\\ )\\/\\ \(tongue) ||----w | || || &quot;&quot;&quot; context.console.print(text) return .done(on: context.container) &#125; &#125; //in configure.swift /// Create a `CommandConfig` with default commands. var commandConfig = CommandConfig.default() /// Add the `CowsayCommand`. commandConfig.use(CowsayCommand(), as: &quot;cowsay&quot;) /// Register this `CommandConfig` to services. services.register(commandConfig) $ swift run Run xxx --help $ swift run Run cowsay &apos;Good job!&apos; -e ^^ -t U SPM let package = Package( name: &quot;Project&quot;, dependencies: [ ... /// 💻 APIs for creating interactive CLI tools. .package(url: &quot;https://github.com/vapor/console.git&quot;, from: &quot;3.0.0&quot;), ], targets: [ .target(name: &quot;Project&quot;, dependencies: [&quot;Command&quot;, ... ]) ] ) Crypto待完成。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>command</tag>
        <tag>vapor</tag>
        <tag>swift</tag>
        <tag>crypto</tag>
        <tag>console</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vapor（六）视图篇]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FVapor%EF%BC%88%E5%85%AD%EF%BC%89%E8%A7%86%E5%9B%BE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Vapor里的视图主要是通过Leaf实现的，Leaf是一种简单的模板语言，通过模板来实现在HTML中的动态Web，就是在Leaf模板中通过规定的语法来渲染出对应的内容。Leaf有以下目标 Small set of strictly enforced rules 小套严格执行规则 Consistency 一致性 Parser first mentality 解析器第一心态 Extensibility 可扩展性 而动态Web，则是指在页面里嵌套了程序，这种网站对一些框架相同，更新较快的信息页面进行内容与形式的分离，将信息内容以记录的形式存入了网站的数据库中，以便于网站各处调用。这样，我们看到的一个页面可能在服务器上并不一一对应某个 html 的文件，网页框架里也套了很多数据库里记录的内容。 TemplateKitTemplateKit是为了定义通用的模板结构和序列处理的模板语言能更容易被实现而设计的。 Leaf使用TemplateKit来渲染视图，通过遵从TemplateParser协议的解析器LeafParser，将leaf解析到抽象的语法树（AST）上 //greeting.leaf -&gt; LeafParser -&gt; AST //leaf Hello, #capitalize(name)! //parser func parse(scanner: TemplateByteScanner) throws -&gt; [TemplateSyntax] //AST [ .raw(data: &quot;Hello. &quot;), .tag( name: &quot;capitalize&quot;, parameters: [.identifier(&quot;name&quot;)] ), .raw(data: &quot;!&quot;), ] 然后通过遵从TemplateRenderer的LeafRenderer填充AST中的变量，最后渲染出视图View //AST + Data -&gt; TemplateSerializer -&gt; View //填充AST中的变量 let data = TemplateData.dictionary([&quot;name&quot;: &quot;vapor&quot;]) //render public func render(_ path: String, _ context: TemplateData) -&gt; Future&lt;View&gt; //View Hello, Vapor! 小结整个渲染的流程就是 LeafRenderer | |----------------------------------------------------------------| greeting.leaf -&gt; LeafParser -&gt; AST -&gt; TemplateSerializer -&gt; View ^ / TemplateData LeafLeaf是一种使用Swift思维语法的模板语言。使用它能够为前端产生动态的HTML页面，或生产通过API发送的富邮件。 设置//In SPM let package = Package( name: &quot;MyApp&quot;, dependencies: [ .package(url: &quot;https://github.com/vapor/leaf.git&quot;, from: &quot;3.0.0&quot;), ], targets: [ .target(name: &quot;App&quot;, dependencies: [&quot;Leaf&quot;, ...]) ] ) //In configure.swift import Leaf try services.register(LeafProvider()) config.prefer(LeafRenderer.self, for: ViewRenderer.self) //解决有多个视图渲染器时的冲突，选择优先使用者。 文件夹结构Leaf expects the views folder to be a ./Resources/Viewsrelative to your project’s root. Leaf需要放在下面的结构的Views文件夹中，并且路径也需按此规划。 VaporApp ├── Package.swift ├── Resources │ ├── Views │ │ └── hello.leaf ├── Public │ ├── images (images resources) │ ├── styles (css resources) └── Sources └── ... 渲染//In leaf Hello, #(name)! //In routes.swift import Leaf router.get(&quot;hello&quot;) &#123; req -&gt; Future&lt;View&gt; in return try req.view().render(&quot;hello&quot;, [&quot;name&quot;: &quot;Leaf&quot;]) &#125; 语法Leaf内建tag的用法 #(variable) #embed(&quot;template&quot;) #set(&quot;title&quot;) &#123; Welcome to Vapor &#125; #count(friends) #for(friend in friends) &#123; &lt;li&gt;#(friend.name)&lt;/li&gt; &#125; 上下文 只要实现了Encodable，都可以传值给Leaf struct WelcomeContext: Encodable &#123; var title: String var number: Int &#125; return try req.view().make(&quot;home&quot;, WelcomeContext(title: &quot;Hello!&quot;, number: 42)) //In leaf &lt;h1&gt;#(title)&lt;/h1&gt; &lt;p&gt;#(number)&lt;/p&gt; 条件 //In leaf #if(title) &#123; The title is #(title) &#125; else &#123; No title was provided. &#125; #if(title == &quot;Welcome&quot;) &#123; This is a friendly web page. &#125; else &#123; No strangers allowed! &#125; #if(lowercase(title) == &quot;welcome&quot;) &#123; This is a friendly web page. &#125; else &#123; No strangers allowed! &#125; #if(title == &quot;Welcome&quot;) &#123; This is a friendly web page. &#125; else if (1 == 2) &#123; What? &#125; else &#123; No strangers allowed! &#125; 循环 struct SolarSystem: Codable &#123; let planets = [&quot;Venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;] &#125; return try req.view().render(..., SolarSystem()) //In leaf Planets: &lt;ul&gt; #for(planet in planets) &#123; &lt;li&gt;#(planet)&lt;/li&gt; &#125; &lt;/ul&gt; #for(planet in planets) &#123; #if(isFirst) &#123; #(planet) is first! &#125; //isFirst、isLast、index &#125; 嵌套 //In child.leaf #set(&quot;body&quot;) &#123; &lt;p&gt;Welcome to Vapor!&lt;/p&gt; &#125; #embed(&quot;master&quot;) //嵌套了 master.leaf 的内容到这里 //In master.leaf &lt;html&gt; &lt;head&gt; &lt;title&gt;#(title)&lt;/title&gt; &lt;/head&gt; &lt;body&gt;#get(body)&lt;/body&gt; &lt;/html&gt; //In context [&quot;title&quot;: &quot;Hi there!&quot;] //In View &lt;html&gt; &lt;head&gt; &lt;title&gt;Hi there!&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;p&gt;Welcome to Vapor!&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 注释 #// Say hello to the user Hello, #(name)! #/* Say hello to the user */ Hello, #(name)! 日期 render(..., [&quot;now&quot;: Date()]) //In leaf The time is #date(now) The date is #date(now, &quot;yyyy-MM-dd&quot;) 大小写 #capitalize(name) //首字母大写 #uppercase(name) #lowercase(name) 包含 //#contains #if(contains(planets, &quot;Earth&quot;)) &#123; Earth is here! &#125; else &#123; Earth is not in this array. &#125; 计数 Your search matched #count(matches) pages. //返回数组的元素个数 自定义标签 实现TagRenderer final class NowTag: TagRenderer &#123; init() &#123; &#125; func render(tag: TagContext) throws -&gt; EventLoopFuture&lt;TemplateData&gt; &#123; let formatter = DateFormatter() switch tag.parameters.count &#123; case 0: formatter.dateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot; case 1: guard let string = tag.parameters[0].string else &#123; throw ... &#125; formatter.dateFormat = string default: throw ... &#125; let string = formatter.string(from: .init()) return tag.container.future(.string(string)) &#125; &#125; 配置标签 services.register &#123; container -&gt; LeafTagConfig in var config = LeafTagConfig.default() config.use(NowTag(), as: &quot;now&quot;) return config &#125; 使用效果 The time is #now()]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>vapor</tag>
        <tag>swift</tag>
        <tag>leaf</tag>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vapor（五）网络篇]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FVapor%EF%BC%88%E4%BA%94%EF%BC%89%E7%BD%91%E7%BB%9C%E7%AF%87%2F</url>
    <content type="text"><![CDATA[这篇主要内容是再介绍一下Route的通用方法，网络传输数据的编码格式，Vapor中HTTP服务端和客户端的详细使用说明，以及WebSocket。 RouteRouting (vapor/routing)是像HTTP请求一样寻找某些东西路径的一个库，可以通过使用嵌套、动态路径组件的路由器注册或查找路由。 收集动态组件值的路由请求如下（组件之间是独立的关系，代表有users和comments两个组件，也可以分别单独请求） /users/:user_id/comments/:comment_id 通常会使用像HTTP响应这类型作为TriRouter的泛型，这里为简单演示使用了Double。 // Create a router that stores Doubles let router = TrieRouter(Double.self) // Register some routes and values to the router router.register(route: Route(path: [&quot;funny&quot;, &quot;meaning_of_universe&quot;], output: 42)) router.register(route: Route(path: [&quot;funny&quot;, &quot;leet&quot;], output: 1337)) router.register(route: Route(path: [&quot;math&quot;, &quot;pi&quot;], output: 3.14)) // Create empty Parameters to hold dynamic params (none yet) var params = Parameters() // Test fetching some routes print(router.route(path: [&quot;fun&quot;, &quot;meaning_of_universe&quot;], parameters: &amp;params)) // 42 print(router.route(path: [&quot;foo&quot;], parameters: &amp;params)) // nil 使用register(…)给路由器注册路由，使用route(…)抓取回该路由注册时设定返回的内容。 TrieRouter 使用了二叉树查找法定位路由的路径。 注册一个动态的路径组件，下面展示会变化路径的其中一部分的请求 /users/:user_id 路由设置 // Create a route for /users/:user_id let user = Route(path: [.constant(&quot;users&quot;), .parameter(&quot;user_id&quot;)], output: ...) // Create a router and register our route let router = TrieRouter(...) router.register(route: user) // Create empty Parameters to hold dynamic values var params = Parameters() // Route the path /users/42 _ = router.route(path: [&quot;users&quot;, &quot;42&quot;], parameters: &amp;params) // The params contains our dynamic value! print(params) // [&quot;user_id&quot;: &quot;42&quot;] .parameter(…) 设定的字符串就是用来从Parameters中抓取值的键。 注意这里演示所用的路由器是自定义的，应与应用App中默认的EngineRouter.default()区分开来。 URL-EncodedURL-Encoded是Web里面的一种广泛的编码方式，能序将Web表单序列化后通过POST请求发送出去，也能用于发送结构数据或URL的查询，但只对发送小量的数据时有效，数据也需要满足percent-encoded，而上传文件则参照下一点的Multipart。 解码Body 解码 application/x-www-form-urlencoded 的请求 form-urlencoded的请求格式 POST /users HTTP/1.1 Content-Type: application/x-www-form-urlencoded name=Vapor&amp;age=3&amp;luckyNumbers[]=5&amp;luckyNumbers[]=7 []是用来编码数组的。 对应的表单格式 &lt;form method=&quot;POST&quot; action=&quot;/users&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;luckyNumbers[]&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;luckyNumbers[]&quot;&gt; &lt;/form&gt; 对应模型 import Vapor struct User: Content &#123; var name: String var age: Int var luckyNumbers: [Int] &#125; 获取数据 router.post(&quot;users&quot;) &#123; req -&gt; Future&lt;HTTPStatus&gt; in return try req.content.decode(User.self).map(to: HTTPStatus.self) &#123; user in print(user.name) // &quot;Vapor&quot; print(user.age) // 3 print(user.luckyNumbers) // [5, 7] return .ok &#125; &#125; 编码Body router.get(&quot;multipart&quot;) &#123; req -&gt; User in let res = req.makeResponse() let user = User(name: &quot;Vapor&quot;, age: 3, luckyNumbers: [5, 7]) res.content.encode(user, as: .urlEncodedForm) return user &#125; Multipart将表单设为multipart/form-data，同时加入文件域，而后通过HTTP协议将文件内容发送到服务器，服务器端读取这个分段(multipart)的数据信息，就能将其中的文件内容提取出来。 POST /users HTTP/1.1 Content-Type: multipart/form-data; boundary=123 --123 Content-Disposition: form-data; name=&quot;name&quot; Vapor --123 Content-Disposition: form-data; name=&quot;age&quot; 3 --123 Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;droplet.png&quot; &lt;contents of image&gt; --123-- 这里使用标识123作为边界 上面的multipart请求格式对应的表单格式为 &lt;form method=&quot;POST&quot; action=&quot;/users&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;image&quot;&gt; &lt;/form&gt; 对应的模型格式为 import Vapor struct User: Content &#123; var name: String var age: Int var image: Data &#125; 获取数据 router.post(&quot;users&quot;) &#123; req -&gt; Future&lt;HTTPStatus&gt; in return try req.content.decode(User.self).map(to: HTTPStatus.self) &#123; user in print(user.name) // &quot;Vapor&quot; print(user.age) // 3 print(user.image) // Raw image data return .ok &#125; &#125; 这样，POST这个表单到/users时，就会接收到对应的数据。 若需要用到编码时，可以这样 router.get(&quot;multipart&quot;) &#123; req -&gt; User in let res = req.makeResponse() let user = User(name: &quot;Vapor&quot;, age: 3, image: Data(...)) res.content.encode(user, as: .formData) return user &#125; HTTPClient 抓取Vapor的主页 // Connect a new client to the supplied hostname. let client = try HTTPClient.connect(hostname: &quot;vapor.codes&quot;, on: ...).wait() print(client) // HTTPClient // Create an HTTP request: GET / let httpReq = HTTPRequest(method: .GET, url: &quot;/&quot;) // Send the HTTP request, fetching a response let httpRes = try client.send(httpReq).wait() print(httpRes) // HTTPResponse 可以看到首先需要连接到主域名来创建client，然后再指定请求的方式和路径，最后通过client发出该请求从而得到响应。发送请求前Vapor会自动解析域名与路径的关系。 Server 创建响应者HTTPServerResponder，它能直接响应连入的请求。注意，这里是一个Echo示例，直接将请求的内容作为响应回给客户端，实际会根据具体情况响应具体内容 /// Echoes the request as a response. struct EchoResponder: HTTPServerResponder &#123; /// See `HTTPServerResponder`. func respond(to req: HTTPRequest, on worker: Worker) -&gt; Future&lt;HTTPResponse&gt; &#123; // Create an HTTPResponse with the same body as the HTTPRequest let res = HTTPResponse(body: req.body) // We don&apos;t need to do any async work here, we can just // se the Worker&apos;s event-loop to create a succeeded future. return worker.eventLoop.newSucceededFuture(result: res) &#125; &#125; 创建服务器HTTPServer，绑定主域名、端口、响应者 // Create an EventLoopGroup with an appropriate number // of threads for the system we are running on. let group = MultiThreadedEventLoopGroup(numThreads: System.coreCount) // Make sure to shutdown the group when the application exits. defer &#123; try! group.syncShutdownGracefully() &#125; // Start an HTTPServer using our EchoResponder // We are fine to use `wait()` here since we are on the main thread. let server = try HTTPServer.start( hostname: &quot;localhost&quot;, port: 8123, responder: EchoResponder(), on: group ).wait() // Wait for the server to close (indefinitely). try server.onClose.wait() start(…) 方法会异步返回一个HTTPServer的future对象，当服务器完成启动起来后future就会完成，否则会抛出异常。 在等待服务器关闭的future完成时，应用能一直在激活状态。一般情况下服务器不会自己关闭。 message 请求消息，主要的参数是method和url let httpReq = HTTPRequest(method: .GET, url: &quot;/hello&quot;) var httpReq: HTTPRequest = ... httpReq.method = .POST httpReq.url = URL(...) //output GET /hello HTTP/1.1 Content-Length: 0 响应消息，主要参数时status let httpRes = HTTPResponse(status: .ok, body: &quot;hello&quot;) var httpRes: HTTPResponse = ... httpRes.status = .notFound HTTP/1.1 200 OK Content-Length: 5 Content-Type: text/plain hello status的类型可以参考httpstatuses.com 消息头，至少需要有Content-Length 或者 Transfer-Encoding 来定义消息体有多长，Content-Type来解释消息体的数据类型 Content-Length: 5 Content-Type: text/plain var message: HTTPMessage ... message.headers.firstValue(for: .contentLength) // 5 消息体，设置消息体会自动更新Content-Length 或者 Transfer-Encoding的内容 var message: HTTPMessage = ... message.body = HTTPBody(string: &quot;Hello, world!&quot;) message.contentType = .plainText var message: HTTPMessage = ... message.body = HTTPBody(string: &quot;&quot;&quot; &#123;&quot;message&quot;: &quot;Hello, world!&quot;&#125; &quot;&quot;&quot;) message.contentType = .json 可编码（Codable） HTTP定义两个便利的协议HTTPMessageEncoder和HTTPMessageDecoder去使用Codable，这两个编解码协议可以编解码自定义的Codable类型的数据到HTTP的消息体中，并设置适合的Content Type到消息头。 HTTP默认是提供了JSONEncoder和JSONDecoder的实现，但Vapor也包含了很多类型的编码方式 struct Greeting: Codable &#123; var message: String &#125; // Create an instance of Greeting let greeting = Greeting(message: &quot;Hello, world!&quot;) // Create a 200 OK response var httpRes = HTTPResponse(status: .ok) // Encode the greeting to the response try JSONEncoder().encode(greeting, to: &amp;httpRes, on: ...) WebSocket与HTTP不同，WebSockets可以一个开放、可交互的方式通讯，能发送文本或二进制格式的消息。客户端和服务端可以在同一时间发送多条消息而无需等待响应。但它还是基于HTTP发起设置的（在响应头中带有状态101的交换协议）。 WebSocket服务器可能同时连接着一个或多个WebSocket客户端，WebSocket服务器建立在HTTP服务器之上，并使用HTTP的upgrade机制。WebSocket servers are built on top of HTTP servers using the HTTP upgrade mechanism. // First, create an HTTPProtocolUpgrader let ws = HTTPServer.webSocketUpgrader(shouldUpgrade: &#123; req in // Returning nil in this closure will reject upgrade if req.url.path == &quot;/deny&quot; &#123; return nil &#125; // Return any additional headers you like, or just empty return [:] &#125;, onUpgrade: &#123; ws, req in // This closure will be called with each new WebSocket client ws.send(&quot;Connected&quot;) ws.onText &#123; ws, string in ws.send(string.reversed()) &#125; &#125;) // Next, create your server, adding the WebSocket upgrader let server = try HTTPServer.start( ... upgraders: [ws], ... ).wait() // Run the server. try server.onClose.wait() shouldUpgrade在收到HTTP的升级请求后回调，它决定了upgrade是否能完成，返回nil则代表拒绝upgrade。onUpgrade在每一个WebSocket客户端连接创建时回调。 注意，upgrade的闭包可能会被多个事件循环调用，如果必须访问外部变量时则需要避免资源竞争。 客户端连接到WebSocket服务端，就像WebSocket服务端使用HTTP服务端一样，WebSocket客户端也可以使用HTTP客户端。 // Create a new WebSocket connected to echo.websocket.org let ws = try HTTPClient.webSocket(hostname: &quot;echo.websocket.org&quot;, on: ...).wait() // Set a new callback for receiving text formatted data. ws.onText &#123; ws, text in print(&quot;Server echo: \(text)&quot;) &#125; // Send a message. ws.send(&quot;Hello, world!&quot;) // Wait for the Websocket to closre. try ws.onClose.wait() Vapor的便利WebSocket方法 Vapor的WebSocket服务端具有路由请求的能力 // Create a new NIO websocket server let wss = NIOWebSocketServer.default() // Add WebSocket upgrade support to GET /echo wss.get(&quot;echo&quot;) &#123; ws, req in // Add a new on text callback ws.onText &#123; ws, text in // Simply echo any received text ws.send(text) &#125; &#125; // Register our server services.register(wss, as: WebSocketServer.self) 启动服务器后，就能够运行一个WebSocket的upgrade，通过GET /echo，可以通过命令行工具wsta来测试 $ wsta ws://localhost:8080/echo Connected to ws://localhost:8080/echo hello, world! hello, world! 获取参数 // Add WebSocket upgrade support to GET /chat/:name wss.get(&quot;chat&quot;, String.parameter) &#123; ws, req in let name = try req.parameters.next(String.self) ws.send(&quot;Welcome, \(name)!&quot;) // ... &#125; $ wsta ws://localhost:8080/chat/Vapor Connected to ws://localhost:8080/chat/Vapor Welcome, Vapor! Vapor同样支持作为客户端去连接WebSocket服务器，最简单的方法是使用客户端的webSocket(...) // connect to echo.websocket.org let done = try app.client().webSocket(&quot;ws://echo.websocket.org&quot;).flatMap &#123; ws -&gt; Future&lt;Void&gt; in // setup an on text callback that will print the echo ws.onText &#123; ws, text in print(&quot;rec: \(text)&quot;) // close the websocket connection after we recv the echo ws.close() &#125; // when the websocket first connects, send message ws.send(&quot;hello, world!&quot;) // return a future that will complete when the websocket closes return ws.onClose &#125; print(done) // Future&lt;Void&gt; // wait for the websocket to close try done.wait()]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>vapor</tag>
        <tag>swift</tag>
        <tag>network</tag>
        <tag>http</tag>
        <tag>webSocket</tag>
        <tag>encoded</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vapor（四）验证篇]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FVapor%EF%BC%88%E5%9B%9B%EF%BC%89%E9%AA%8C%E8%AF%81%E7%AF%87%2F</url>
    <content type="text"><![CDATA[常用的服务端的验证方式有Cookie-Session、JWT，下面主要围绕这两种验证方式说明，顺带也介绍了Cookie的密码和Oauth Token两种验证方式。 JWTJSON WEB Token（JWT），是一种基于JSON的、用于在网络上声明某种主张的令牌（token）。JWT通常由三部分组成: 头信息（header）, 消息体（payload）和签名（signature）。 头信息: header = &apos;{&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}&apos;消息体: payload = &apos;{&quot;id&quot;: 42,&quot;name&quot;: &quot;Vapor Developer&quot;}&apos;未签名的令牌由base64url编码的头信息和消息体拼接而成（使用”.”分隔），签名则通过私有的key计算而成: key = &apos;secretkey&apos; unsignedToken = encodeBase64(header) + &apos;.&apos; + encodeBase64(payload) signature = HMAC-SHA256(key, unsignedToken) 后在未签名的令牌尾部拼接上base64url编码的签名（同样使用”.”分隔）就是JWT了: token = encodeBase64(header) + &apos;.&apos; + encodeBase64(payload) + &apos;.&apos; + encodeBase64(signature) //&lt;header&gt;.&lt;payload&gt;.&lt;signature&gt;实现的步骤一般是 客户端通过用户名和密码登录服务器； 服务端对客户端身份进行验证； 服务端对该用户生成Token，返回给客户端； 客户端将Token保存到本地浏览器，一般保存到cookie中； 客户端发起请求，需要携带该Token； 服务端收到请求后，首先验证Token，之后返回数据。优点是服务端不需要保存Token，只需要对Token中携带的信息进行验证即可；无论客户端访问后台(集群中的)的哪台服务器，只要可以通过用户信息的验证即可。 创建Codable类型的模型来承载JWT里的Payload struct User: JWTPayload &#123; var id: Int var name: String func verify(using signer: JWTSigner) throws &#123; // nothing to verify &#125; &#125; JWT的解析和验证 import JWT import Vapor router.get(&quot;hello&quot;) &#123; req -&gt; String in // fetches the token from `Authorization: Bearer &lt;token&gt;` header guard let bearer = req.http.headers.bearerAuthorization else &#123; throw Abort(.unauthorized) &#125; // parse JWT from token string, using HS-256 signer let jwt = try JWT&lt;User&gt;(from: bearer.token, verifiedUsing: .hs256(key: &quot;secret&quot;)) return &quot;Hello, \(jwt.payload.name)!&quot; &#125; 创建一个JWT给客户端保存 router.post(&quot;login&quot;) &#123; req -&gt; String in // create payload let user = User(id: 42, name: &quot;Vapor Developer&quot;) // create JWT and sign let data = try JWT(payload: user).sign(using: .hs256(key: &quot;secret&quot;)) return String(data: data, encoding: .utf8) ?? &quot;&quot; &#125; SessionsSession的中文翻译是“会话”，当用户打开某个web应用时，便与Web服务器产生一次Session。服务器使用Session把用户的信息（Token、账密）临时保存在了服务器上，用户离开网站后Session会被销毁。这种用户信息存储方式相对直接将用户信息存在Cookie来说更安全。可是Session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候Session会丢失。 或者说客户端在服务端登陆成功之后，服务端会生成一个sessionID返回给客户端，客户端将sessionID保存到Cookie中，再次发起请求的时候携带Cookie中的sessionID到服务端，服务端会缓存该Session（会话），当客户端请求到来的时候，服务端就知道是哪个用户的请求，并将处理(sessionID映射出用户信息进行验证)的结果返回给客户端，完成通信。缺点是访客量大时服务端需要消耗较大空间保存Session，其次是集群服务端下需采用缓存一致性技术保存Session。 一般通过中间件实现逻辑后添加在路由上。验证是检验用户的身份，不要和获取资源权限的授权混淆。 添加鉴定的中间件服务 config.prefer(MemoryKeyedCache.self, for: KeyedCache.self) //优先使用内存缓存 var middlewares = MiddlewareConfig() middlewares.use(SessionsMiddleware.self) // ... services.register(middlewares) 模型遵守鉴定协议 extension User: SessionAuthenticatable &#123; &#125; 具鉴定能力的路由器从请求头中取出sessionId，鉴定请求的用户 // 创建User的验证session中间件 let session = User.authSessionsMiddleware() // 创建被中间件包裹的路由器 let auth = router.grouped(session) // 在间接路由器auth中实现路由，并获取供鉴定的信息转为对应的模型 auth.get(&quot;hello&quot;) &#123; req -&gt; String in let user = try req.requireAuthenticated(User.self) //require前缀代表在验证失败时会抛出异常 return &quot;Hello, \(user.name)!&quot; &#125; 登录的路由，也必须使用鉴定中间件所捆绑的路由器中实现，并在响应前将用户model使用.authenticate缓存到服务端，否则后面(同一个用户)通过该路由器的其它请求里的验证会无效 auth.get(&quot;login&quot;) &#123; req -&gt; Future&lt;String&gt; in return User.find(1, on: req).map &#123; user in guard let user = user else &#123; throw Abort(.badRequest) &#125; try req.authenticate(user) return &quot;Logged in&quot; &#125; &#125; 登录成功后，会发现一个叫 “vapor-session” 的 Cookie 已经存在于浏览器上。而像/login/hello这样的访问路径，会先登录再访问hello。 Stateless这是一个最初级的验证方式。为保护接口端点，引入了一种无状态验证方法，同样也是一种验证用户身份的方法，而非获取资源权限的授权。 Cookie 密码验证（Basic） 实质就是利用Cookie保存用户名和密码在客户端，在每次请求时带上这个Cookie作为请求的验证头。 包含的账号名和密码，格式为 Authorization: Basic base64(username:password)同时需要可验证的目标模型遵从PasswordAuthenticatable，给中间件接入（需要注意密码应该使用hash值） extension User: PasswordAuthenticatable &#123; /// See `PasswordAuthenticatable`. static var usernameKey: WritableKeyPath&lt;User, String&gt; &#123; return \.email &#125; /// See `PasswordAuthenticatable`. static var passwordKey: WritableKeyPath&lt;User, String&gt; &#123; return \.passwordHash &#125; &#125; 创建可验证的模型后，就为要保护的路由添加中间件（在实践中要用basicAuthMiddleware去包裹authSessionsMiddleware包裹的路由器才能验证成功） // Use user model to create an authentication middleware let password = User.basicAuthMiddleware(using: BCryptDigest()) //使用 BCryptDigest 来验证存储为 BCrypt hash的密码。 // Create a route closure wrapped by this middleware router.grouped(password).get(&quot;hello&quot;) &#123; req in /// &#125; Oauth Token验证（Bearer） Token的意思是“令牌”，是用户身份的验证方式，最简单的Token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由Token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接Token请求服务器)。还可以把不变的参数也放进Token，避免多次查库。 在每一个请求API的验证头上添加一个暂时的token，一般是 Authorization: Bearer hash(uid+timestamp+sign)首先使可验证模型遵从Authenticatable协议 struct User: Model &#123; var id: Int? var name: String var email: String var passwordHash: String var tokens: Children&lt;User, UserToken&gt; &#123; return children(\.userID) &#125; &#125; extension User: TokenAuthenticatable &#123; /// See `TokenAuthenticatable`. typealias TokenType = UserToken &#125; 然后需要额外定义一个Token类 struct UserToken: Model &#123; var id: Int? var string: String var userID: User.ID var user: Parent&lt;UserToken, User&gt; &#123; return parent(\.userID) &#125; &#125; extension UserToken: Token &#123; /// See `Token`. typealias UserType = User /// See `Token`. static var tokenKey: WritableKeyPath&lt;UserToken, String&gt; &#123; return \.string &#125; /// See `Token`. static var userIDKey: WritableKeyPath&lt;UserToken, User.ID&gt; &#123; return \.userID &#125; &#125; 最后为要保护的路由添加中间件 // Use user model to create an authentication middleware let token = User.tokenAuthMiddleware() // Create a route closure wrapped by this middleware router.grouped(token).get(&quot;hello&quot;) &#123; req in let user = try req.requireAuthenticated(User.self) return &quot;Hello, \(user.name).&quot; &#125; Cookie 与 Session Cookie数据存放在客户的浏览器上，Session数据放在服务器上。 Cookie不是很安全，别人可以分析存放在本地的Cookie并进行Cookie欺骗，考虑到安全应当使用Session。 Session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面的话，应当使用Cookie。 单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie。 一般情况，将登陆信息等重要信息存放为Session，其他信息如果需要保留，可以放在Cookie中。 Token 与 SessionSession 和 Oauth Token并不矛盾，作为身份认证 Token安全性比Session好，因为每个请求都有签名还能防止监听以及重放攻击，而Session就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加Session来在服务器端保存一些状态。 App通常用restful api跟server打交道。Rest是stateless的，也就是App不需要像browser那样用Cookie来保存Session,因此用session token来标示自己就够了，session/state由api server的逻辑处理。 如果你的后端不是stateless的rest api, 那么你可能需要在App里保存Session。可以在app里嵌入webkit,用一个隐藏的browser来管理cookie session。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>vapor</tag>
        <tag>swift</tag>
        <tag>session</tag>
        <tag>token</tag>
        <tag>verification</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vapor（三）数据库篇]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FVapor%EF%BC%88%E4%B8%89%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%2F</url>
    <content type="text"><![CDATA[作为一个服务器，没有比数据库更重要的东西，在Vapor上有多种数据库提供选择，而且已经有良好的封装和中间件，简单的调用就能访问到数据库，同时横向兼容。 这篇文章讲解了Vapor中和数据库相关的一些配置、操作、原理等的内容。 数据库选型MySQL 和 PostgreSQL 的对比，网上已经很多分析，例如这篇PostgreSQL 与 MySQL 相比，优势何在？。为了感受一下潮流，我选择了PostgreSQL来学习和练习。 DatabaseKitConnectionDatabaseKit主要负责创建、管理和合并连接。又了连接我们才能访问数据库，而创建连接对应用来说是一件非常耗时的任务，以至于很多云服务都会限制一个服务能打开的连接数，关于性能方面的知识可以自行去了解。参考1 参考2 由路由传入request来请求连接时，如果连接池中没有可用的连接则创建一条新连接，若连接数达到了上限则等待被释放放回的连接。 再观察一下Request实现的协议 public final class Request: ContainerAlias, DatabaseConnectable, HTTPMessageContainer, RequestCodable, CustomStringConvertible, CustomDebugStringConvertible 其中就是DatabaseConnectable决定Request拥有连接数据库的能力 // 请求一条连接池中的连接，连到 `.psql` db req.withPooledConnection(to: .psql) &#123; conn in return conn.query(...) // do some db query &#125; 上面方法中的闭包会在req请求到有效连接时回调，而当闭包返回的Future完成时，此连接则会自动释放回连接池。 如果你想手动请求一条连接，就要对应地手动释放此条连接 // Request a connection from the pool and wait for it to be ready. let conn = try app.requestPooledConnection(to: .psql).wait() // Ensure the connection is released when we exit this scope. defer &#123; app.releasePooledConnection(conn, to: .psql) &#125; 可以配置连接数据库的连接池 // Create a new, empty pool config. var poolConfig = DatabaseConnectionPoolConfig() // Set max connections per pool to 8. poolConfig.maxConnections = 8 // Register the pool config. services.register(poolConfig) 为了避免竞争的状况出现，连接池绝对不能在事件循环之间共享使用。通常一个连接池对应一个数据库和一个事件循环。意味着应用打开指定数据库的连接数为 线程数 * 池中的最大连接数。 还可以单独地创建连接，但必须注意的是，不要在路由的回调闭包中这样使用，因为频繁的访问会导致创建出很多连接，而由路由回调闭包返回的连接则是从连接池中获取的。 // Creates a new connection to `.sqlite` db 。同样，使用闭包返回连接的形式能够在回调时自动释放连接，只是这里不是释放到池中而已。 app.withNewConnection(to: .sqlite) &#123; conn in return conn.query(...) // do some db query &#125; // Creates a new connection to `.sqlite` db 。 需手动释放连接。 let conn = try app.newConnection(to: .sqlite).wait() // Ensure the connection is closed when we exit this scope. defer &#123; conn.close() &#125; Logging配置数据库日志功能 // Enable logging on the SQLite database dbsConfig.enableLogging(for: .sqlite) //或 // Create a custom log handler. let myLogger: DatabaseLogHandler = ... // Enable logging on SQLite w/ custom logger. dbsConfig.enableLogging(for: .sqlite, logger: myLogger) Keyed Cache键缓存，是可通过键来获取、设置和移除Codable值的操作方式，有时会称作键值储存。 要创建一个键缓存，需要用到Container协议中的方法.keyedCache(for:) // Creates a DatabaseKeyedCache with .redis connection pool let cache = try app.keyedCache(for: .redis) // Sets &quot;hello&quot; = &quot;world&quot; try cache.set(&quot;hello&quot;, to: &quot;world&quot;).wait() // Gets &quot;hello&quot; let world = try cache.get(&quot;hello&quot;, as: String.self).wait() print(world) // &quot;world&quot; // Removes &quot;hello&quot; try cache.remove(&quot;hello&quot;).wait() RedisRedis是一个事件驱动、无阻塞、建立于SwiftNIO的库。可以通过发送Redis的命令与服务端直接交互，又或者通过Vapor的KeyedCache接口来当作缓存使用。 配置Redis //SPM let package = Package( name: &quot;MyApp&quot;, dependencies: [ // ⚡️Non-blocking, event-driven Redis client. .package(url: &quot;https://github.com/vapor/redis.git&quot;, from: &quot;3.0.0&quot;), ], targets: [ .target(name: &quot;App&quot;, dependencies: [&quot;Redis&quot;, ...]) ] ) //configure.swift import Redis // register Redis provider try services.register(RedisProvider()) 首先创建连到Redis数据库的新连接， router.get(&quot;redis&quot;) &#123; req -&gt; Future&lt;String&gt; in return req.withNewConnection(to: .redis) &#123; redis in // send INFO command to redis and map the resulting RedisData to a String return redis.command(&quot;INFO&quot;).map &#123; $0.string ?? &quot;&quot; &#125;//单行的略简语法 &#125; &#125; Redis命令集 Get/Set/Delete命令，通过这对命令可以在服务端（使用key:value的形式）存储、提取和删除对应的数据，可以传入任何Codable类型的数值。 router.get(&quot;set&quot;) &#123; req -&gt; Future&lt;HTTPStatus&gt; in // create a new redis connection return req.withNewConnection(to: .redis) &#123; redis in // save a new key/value pair to the cache return redis.set(&quot;hello&quot;, to: &quot;world&quot;) // convert void future to HTTPStatus.ok .transform(to: .ok) &#125; &#125; router.get(&quot;get&quot;) &#123; req -&gt; Future&lt;String&gt; in // create a new redis connection return req.withNewConnection(to: .redis) &#123; redis in // fetch the key/value pair from the cache, decoding a String return redis.get(&quot;hello&quot;, as: String.self) // handle nil case .map &#123; $0 ?? &quot;&quot; &#125; &#125; &#125; router.get(&quot;del&quot;) &#123; req -&gt; Future&lt;HTTPStatus&gt; in // create a new redis connection return req.withNewConnection(to: .redis) &#123; redis in // fetch the key/value pair from the cache, decoding a String return redis.delete(&quot;hello&quot;) // convert void future to HTTPStatus.ok .transform(to: .ok) &#125; &#125; 也可将Redis作为Vapor KeyedCache协议的后端 router.get(&quot;set&quot;) &#123; req -&gt; Future&lt;HTTPStatus&gt; in let string = try req.query.get(String.self, at: &quot;string&quot;) return try req.keyedCache(for: .redis).set(&quot;string&quot;, to: string) .transform(to: .ok) &#125; router.get(&quot;get&quot;) &#123; req -&gt; Future&lt;String&gt; in return try req.keyedCache(for: .redis).get(&quot;string&quot;, as: String.self) .unwrap(or: Abort(.badRequest, reason: &quot;No string set yet.&quot;)) &#125; FluentFluent 是一个构建ORMs（Object Relational Mapping 对象关系映射）的框架，通过Fluent能够整合多种数据库，但它本身并不是ORM，它需要数据库来驱动才能运作，最初的Fluent也是为了整合构建NoSQL和SQL两种数据库做而诞生。 数据库驱动（Database Driver）可以有多个选择，比如 MySQL、SQLite、MongoDB、PostgreSQL。 Vapor 2.0对应的版本在Vapor2.0的时候，Driver是通过Provider来封装的，然后Vapor直接使用Provider来操作数据库，例如PostgreSQLProvider import PackageDescription let package = Package( name: &quot;OneVideo-Vapor&quot;, dependencies: [ .Package(url: &quot;https://github.com/vapor/vapor.git&quot;, majorVersion: 2), .Package(url: &quot;https://github.com/vapor/fluent-provider.git&quot;, majorVersion: 1), //可独立于Vapor使用 //.Package(url: &quot;https://github.com/vapor/fluent.git&quot;, majorVersion: 2), .Package(url: &quot;https://github.com/vapor/postgresql-provider.git&quot;, majorVersion: 2, minor: 0) ], exclude: [ ... ] ) FluentProvider（fluent-provider/fluent）相当于一套标准接口，提供给Vapor使用，作用就是上面交代的整合数据库、构建数据库。PostgreSQLProvider（postgresql-provider，它会再依赖postgresql）则是Fluent接口与驱动postgresql的适配器、中间件，即按Fluent的标准提供由postgresql操作数据库的接口，而Vapor无感知。 若想直接使用PostgreSQL，不使用Fluent的情况下则 import PackageDescription let package = Package( name: &quot;Project&quot;, dependencies: [ ... .Package(url: &quot;https://github.com/vapor/postgresql.git&quot;, majorVersion: 2) ], exclude: [ ... ] ) Vapor 3.0对应的版本大致上与2.0的操作套路一样，只是库包的名称有所变化，同样拿PostgreSQL举例 // swift-tools-version:4.0 import PackageDescription let package = Package( name: &quot;MyApp&quot;, dependencies: [ /// Any other dependencies ... .package(url: &quot;https://github.com/vapor/fluent-postgresql.git&quot;, from: &quot;1.0.0&quot;), ], targets: [ .target(name: &quot;App&quot;, dependencies: [&quot;FluentPostgreSQL&quot;, ...]), .target(name: &quot;Run&quot;, dependencies: [&quot;App&quot;]), .testTarget(name: &quot;AppTests&quot;, dependencies: [&quot;App&quot;]), ] ) 以前的Provider/Driver叫做了FluentPostgreSQL(仍然会依赖postgresql)，这样命名更清晰直观，一看就知道是遵循Fluent的驱动，后半部分的命名则是具体驱动的数据库类型。 但不一定每个Driver都有Provider，也不一定每个Driver的Provider都满足最新版本的Vapor，具体要看社区在Vapor使用某种数据库的贡献程度。 如果只想引用PostgreSQL而不用Fluent的话，则 let package = Package( name: &quot;MyApp&quot;, dependencies: [ // 🐘 Non-blocking, event-driven Swift client for PostgreSQL. .package(url: &quot;https://github.com/vapor/postgresql.git&quot;, from: &quot;1.0.0&quot;), ], targets: [ .target(name: &quot;App&quot;, dependencies: [&quot;PostgreSQL&quot;, ...]), ... ] ) Model使用模型去查询数据库，返回的结果是确定类型的集合，而不像其它ORM语言返回的是不确定类型的集合。不同的数据库驱动提供了其对应的便利模型，例如PostgreSQLModel。 1.定义一个模型 //必须使用final修饰，也可以定义得更通配 final class User&lt;D&gt;: Model where D: Database final class User: Model &#123; /// See `Model.Database`。指定数据库，使Fluent可以动态地添加合适的方法和数据类型到`QueryBuilder`，若使用通配的方式定义模型时应写成 typealias Database = D typealias Database = FooDatabase /// See `Model.ID`。指定ID的类型 typealias ID = Int /// See `Model.idKey`。指定ID属性的KeyPath，且必须指向一个Optional类型的属性。 static let idKey: IDKey = \.id /// The unique identifier for this user. 模型的唯一标识，即ID属性 var id: Int? var name: String var age: Int /// Creates a new user. 必须实现的初始化方法 init(id: Int? = nil, name: String, age: Int) &#123; self.id = id self.name = name self.age = age &#125; &#125; Fluent 3 就是这样设计成让我们可以通过模型和驱动的联系来驾驭数据库的力量。 2.模型的生命周期方法 willCreate didCreate willUpdate didUpdate willRead willDelete final class User: Model &#123; /// ... /// See `Model.willUpdate(on:)` func willUpdate(on connection: Database.Connection) throws -&gt; Future&lt;Self&gt; &#123; /// Throws an error if the username is invalid try validateUsername() /// Return the user. No async work is being done, so we must create a future manually. return Future.map(on: connection) &#123; self &#125; &#125; &#125; 3.增删改查(CRUD)CRUD (create, read, update, delete) //在模型的数据库中增加一条记录，当模型没有ID时调用.save(on:)会转为调用该方法 //若模型为值类型(struct)的时候，.create(on:)返回的模型会带上新的ID let didCreate = user.create(on: req) print(didCreate) /// Future&lt;User&gt; ///找出ID == 1的那个模型 let user = User.find(1, on: req) print(user) /// Future&lt;User?&gt; ///找出所有name为&quot;Vapor&quot;的模型 let users = User.query(on: req).filter(\.name == &quot;Vapor&quot;).all() print(users) /// Future&lt;[User]&gt; ///更新模型，如果已经有ID则在调用.save(on:)时会转为调用该方法 let didUpdate = user.update(on: req) print(didUpdate) /// Future&lt;User&gt; ///删除模型 let didDelete = user.delete(on: req) print(didDelete) /// Future&lt;Void&gt; ///获取唯一的ID或抛出异常 let id = try user.requireID() 要查询数据，首先要连接数据库，最简单的连接方式就是使用路由返回的Request，它会使用模型的defaultDatabase属性作为连接目标，然后自动抓取一个合并了该数据库的连接。你也可以在Container容器上使用便利方法来手动创建连接。详细的查询方法在下面的 PostgreqSQL一节再作介绍。但是暂时还不支持Union查询。 Migration然后在Vapor3.0的Fluent里还增加了一个叫Migration的概念，其实就是一个可使模型的属性被动态识别的协议（建立属性与数据表各字段的关联），不一定必须扩展Model类型。默认情况下，只要也遵循Model协议Fluent就能自动推断出模型各属性及其类型并实现了prepare和revert方法 //User.swift import FluentPostgreSQL import Vapor final class User: PostgreSQLModel &#123; typealias Database = PostgreSQLDatabase typealias ID = Int var id: ID? var name: String init(id: ID? = nil, name: String) &#123; self.id = id self.name = name &#125; &#125; extension User: PostgreSQLMigration &#123; &#125; //configure.swift var migrations = MigrationConfig() migrations.add(model: User.self, database: .psql) services.register(migrations) 其它情况下可以重写prepare方法在准备创建数据表前通过builder声明及创建自定义需要的字段，或在revert方法中删除废弃的字段或数据表。 //User.swift extension User: PostgreSQLMigration &#123; //访问数据表前执行 static func prepare(on conn: PostgreSQLConnection) -&gt; Future&lt;Void&gt; &#123; //创建数据表 return PostgreSQLDatabase.create(User.self, on: conn) &#123; builder in builder.field(for: \.id, isIdentifier: true) builder.field(for: \.name) //try builder.field(for: \.name, type: &lt;#DataType#&gt;) //指定字段的类型 &#125; //结合判断发布的版本的逻辑，更新已有数据表的字段 return PostgreSQLDatabase.update(User.self, on: conn) &#123; builder in builder.field(for: \.mass) //当然模型需要新增上这个属性 builder.deleteField(for: \.name) &#125; //根据条件修改操作 return Galaxy.query(on: conn).filter(\.mass == 0).delete() &#125; //启动应用时执行 static func revert(on connection: PostgreSQLConnection) -&gt; Future&lt;Void&gt; &#123; return PostgreSQLDatabase.delete(User.self, on: connection) //直接返回一个预先完成的future return conn.future(()) &#125; &#125; //configure.swift var migrations = MigrationConfig() migrations.add(migration: CreateGalaxy.self, database: .psql) services.register(migrations) PostgreSQL的字段类型(DataType) 注意，设置自定义的Migration需要使用add(migration:database:)这个方法。 RelationFluent支持两种关系模型，分别是单对多（父-子 parent-child）和多对多（同辈 siblings）。 单对多示例 //父模型 extension Galaxy &#123; // this galaxy&apos;s related planets var planets: Children&lt;Galaxy, Planet&gt; &#123; return children(\.galaxyID) &#125; &#125; //子模型 extension Planet &#123; // this planet&apos;s related galaxy var galaxy: Parent&lt;Planet, Galaxy&gt; &#123; return parent(\.galaxyID) &#125; &#125; let galaxy: Galaxy = ... let planets = galaxy.planets.query(on: ...).all()//即是在Planet中查出含该galaxy的ID的模型 let planet: Planet = ... let galaxy = planet.galaxy.get(on: ...)//直接查出planet对应的galaxy（根据planet中的galaxy的ID） 多对多示例 struct PlanetTag: Pivot &#123; // ... typealias Left = Planet typealias Right = Tag //利用对应的keyPath，指定关系的依据 static var leftIDKey: LeftIDKey = \.planetID static var rightIDKey: RightIDKey = \.tagID var id: Int? var planetID: Int var tagID: Int &#125; extension Planet &#123; // this planet&apos;s related tags ，&lt;From, To, Through&gt; var tags: Siblings&lt;Planet, Tag, PlanetTag&gt; &#123; return siblings() &#125; &#125; extension Tag &#123; // all planets that have this tag ，&lt;From, To, Through&gt; var planets: Siblings&lt;Tag, Planet, PlanetTag&gt; &#123; return siblings() &#125; &#125; let planet: Planet = ... planet.tags.query(on: ...).all() //提供中途插入关系的方法 extension PlanetTag: ModifiablePivot &#123; init(_ planet: Planet, _ tag: Tag) throws &#123; planetID = try planet.requireID() tagID = try tag.requireID() &#125; &#125; let planet: Planet = ... let tag: Tag = ... planet.tags.attach(tag, on: ...) 官方说明需求案例 Transaction事务，在其未完成前，数据不会被保存到数据库。 var userA: User = ... var userB: User = ... return req.transaction(on: .&lt;#dbid#&gt;) &#123; conn in return userA.save(on: conn).flatMap &#123; _ in return userB.save(on: conn) &#125;.transform(to: HTTPStatus.ok) &#125; 上面的例子表示，只要userA或userB有一个save失败，则均不会保存到数据库。事务一完成，结果就会转换成HTTP的状态响应。 PostgreSQLPostgreSQL 是建立在 SwiftNIO 库之上的一个纯Swift库。它比 Fluent ORM 低一级，是Provider和Driver的主要功能实现者，但独立于封装它的Fluent Provider/Driver。即使是这样，PostgreSQL 还扩展了DatabaseKit的连接池和交互接口、Vapor的服务架构。 当你有以下条件或需求时，可以跨过Provider/Driver直接使用它 拥有非标准结构的数据库 依赖于复杂或重度自定义的SQL语句查询 不喜欢ORM 但这里以FluentPostgreSQL介绍PostgreSQL的应用。 先将环境搭建然后在项目中引用之。 安装与启动//安装postgresql brew install postgresql //开启postgresql方式一 brew services start postgresql //开启postgresql方式二 pg_ctl -D /usr/local/var/postgres start //开启postgresql方式三 postgres -D /usr/local/var/postgres/ //关闭postgresql pg_ctl -D /usr/local/var/postgres stop -s -m fast 配置//配置数据存放目录 initdb /usr/local/var/postgres -E utf8 //配置开机启动postgresql ln -sfv /usr/local/opt/postgresql/*.plist ~/Library/LaunchAgents launchctl load ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist createuser username -P #Enter password for new role: #Enter it again: 使用//创建数据库 createdb [-U username] dbname //删除数据库 dropdb [-U username] dbname //创建数据库并指定拥有者和编码格式（及显示操作指令） createdb dbname -O username -E UTF8 -e //查看已创建的数据库 psql -l //连接数据库 psql dbname //使用默认用户连接(当前Mac账号登入) psql -U username -d dbname -h 127.0.0.1 psql (9.6.2) Type &quot;help&quot; for help. //显示已创建的数据库 dbname=# \l //连接数据库 dbname=# \c dbname //显示数据库表 dbname=# \d //退出当前的数据库连接 dbname=# \q //创建表（并指定拥有者） dbname=# CREATE TABLE test(id int, text VARCHAR(50)) [ OWNER [ = ] user_name ]; //插入记录 dbname=# INSERT INTO test(id, text) VALUES(1, &apos;sdfsfsfsdfsdfdf&apos;); //查询记录 dbname=# SELECT * FROM test WHERE id = 1; //更新记录 dbname=# UPDATE test SET text = &apos;xx&apos; WHERE id = 1; //删除记录 dbname=# DELETE FROM test WHERE id = 1; //删除表 dbname=# DROP TABLE test; //删除数据库 dbname=# DROP DATABASE dbname; 详细可参考PostgreSQL新手入门PostgreSQL 结构及权限 管理下载pgAdmin4，添加数据库到pgAdmin4前应先确认账号和数据库均已创建好。 添加Server 指定Server的数据库 查看数据表 安装后会在这个地址中 http://127.0.0.1:49707/browser/ 启动 pgAdmin4。 应用上述的步骤完成后，意味着我们搭建好了使用PostgreSQL的环境。而要使用它还需要在项目中进行配置， 注册服务 //in configure.swift. import FluentPostgreSQL import Vapor // Register providers first try services.register(FluentPostgreSQLProvider()) // 若不使用Fluent的注册如下 try services.register(PostgreSQLProvider()) 添加数据库配置 // Configure a PostgreSQL database. 这里无论是直接使用PostgreSQL还是Fluent，都是一样的配置方式 let postgreSql = PostgreSQLDatabase(config: PostgreSQLDatabaseConfig(hostname: &quot;localhost&quot;, username: &quot;xx&quot;)) /// Register the configured PostgreSQL database to the database config. var databases = DatabasesConfig() databases.add(database: postgresql, as: .psql) services.register(databases) 数据库操作 //保存一个模型对象，返回带ID、默认值字段的模型对象 router.post(&quot;galaxies&quot;) &#123; req in let galaxy: Galaxy = ... //注意，req是实现了DatabaseConnectable协议的对象，在该参数中扮演的角色实质是connection链接，这一句的代码描述应该是：“将模型通过连接创建到数据库中去” return galaxy.create(on: req) &#125; //查找 Galaxy.find(42, on: conn) Galaxy.find(42, on: conn).unwrap(or: Abort(...)) Galaxy.query(on: conn).filter(\.name == &quot;Milky Way&quot;) Galaxy.query(on: conn).filter(\.mass &gt;= 500).filter(\.type == .spiral)//前后的filter链形成与的关系 Galaxy.query(on: conn).group(.or) &#123; $0.filter(\.mass &lt;= 250).filter(\.mass &gt;= 500) &#125;.filter(\.type == .spiral)//选择filter链的关系 Galaxy.query(on: conn).range(..&lt;50) Galaxy.query(on: conn).sort(\.name, .descending) Galaxy.query(on: conn).join(\Planet.galaxyID, to: \Galaxy.id) .filter(\Planet.name == &quot;Earth&quot;) //合并表查找，找出所有planet name为Earth的galaxy（Planet的表合并到Galaxy后，在Galaxy新增的Planet属性中过滤） (join and filter).alsoDecode(Planet.self).all()//对筛选的结果转换回合并前的模型编码，使用(Galaxy, Planet)元祖类型返回。 Galaxy.query(on: conn).all() Galaxy.query(on: conn).range(..&lt;50).all() Galaxy.query(on: conn).chunk(max: 32) &#123; galaxies in print(galaxies) // Array of 32 or less galaxies &#125; Galaxy.query(on: conn).filter(\.name == &quot;Milky Way&quot;).first() //更新 var planet: Planet ... // fetched from database planet.name = &quot;Earth&quot; planet.update(on: conn) //删除 var planet: Planet ... // fetched from database planet.delete(on: conn) 若不使用 Fluent 的情况（是的，会麻烦点），则 struct PostgreSQLVersion: Codable &#123; let version: String &#125; router.get(&quot;sql&quot;) &#123; req in return req.withPooledConnection(to: .psql) &#123; conn in return conn.raw(&quot;SELECT version()&quot;) .all(decoding: PostgreSQLVersion.self) &#125;.map &#123; rows in return rows[0].version &#125; &#125; SQL最后，看看SQL的应用，它在Vapor里是一个独立的库（vapor/sql），提供了在Swift中的序列化SQL查询功能，实现的主要协议包括DQL、DML、DDL，上面介绍的组件均基于它来实现查询。 支持的查询有 SELECT, INSERT, UPDATE, DELETE CREATE TABLE, ALTER TABLE, DROP TABLE CREATE INDEX, DROP INDEX 例如SELECT这个方法，它支持 , columns, and expressions like functions FROM JOIN GROUP BY ORDER BY SELECT * FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;name&quot; = ? 对应的vapor/sql实现就是 struct User: SQLTable, Codable &#123; static let sqlTableIdentifierString = &quot;users&quot; let id: Int? let name: String &#125; router.get(&quot;sql&quot;) &#123; req in return req.withPooledConnection(to: .psql) &#123; conn in let users = conn.select() .all().from(User.self) .where(\User.name == &quot;Vapor&quot;) .all(decoding: User.self) print(users) // Future&lt;[User]&gt; return users// use conn to perform a query &#125; &#125;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>vapor</tag>
        <tag>swift</tag>
        <tag>database</tag>
        <tag>postgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vapor（二）进阶篇]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FVapor%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[经过了解基础的概念后，可以再深一步来了解这些概念存在的意义和扩展的使用方法，包括Service、Client、Content、Session。 ServiceService是一个依赖注入的框架，以可维护的方式来进行注册、配置和创建应用依赖。其实Vapor里的这个Service的概念有点像iOS里面组件化的解耦方案，使用路由或者协议建立起一个调度中心，去给有功能调用需求的地方分发服务。那应用到的组件就不会散落在项目的各处，同时可以针对自己需要的情景、功能来配置、选择对应的服务。 注册服务 首先遵从一个空的协议Service（拿PrintLogger来举例） extension PrintLogger: Service &#123; &#125; 然后在configure.swift将实现服务的类注册到Services结构体中，使用工厂方法动态地创建服务 services.register(Logger.self) &#123; container in return PrintLogger() &#125; 另外，遵从并实现ServiceType协议后可以更简单地注册服务 extension PrintLogger: ServiceType &#123; /// See `ServiceType`. static var serviceSupports: [Any.Type] &#123; return [Logger.self] &#125; /// See `ServiceType`. static func makeService(for worker: Container) throws -&gt; PrintLogger &#123; return PrintLogger() &#125; &#125; //In configure.swift services.register(PrintLogger.self) 甚至可以指定注册的实例对象 services.register(PrintLogger(), as: Logger.self) 注意，如果使用引用类型（class）来注册服务的话，那么所有容器Container和子容器SubContainer都会共享这一个类型的这一个对象，同时要小心资源竞争的问题。 配置服务 如果同一个接口注册了多个服务，则需要指定优先的选择 services.register(PrintLogger.self) services.register(FileLogger.self) switch env &#123; case .production: config.prefer(FileLogger.self, for: Logger.self) default: config.prefer(PrintLogger.self, for: Logger.self) &#125; 当然，通过环境变量就能动态地决定注册的服务，而无需使用到配置（config）。 创建服务 当你注册过服务，那么就可以用容器Container来创建服务 let logger = try someContainer.make(Logger.self) logger.log(&quot;Hello, world!&quot;) // PrintLogger or FileLogger depending on the container&apos;s environment print(type(of: logger)) Provider 通过Provider协议可以更简单地整合外部服务到当前应用。像所有的Vapor官方包都使用它来展示它们的服务。Provider可以用来注册到Services结构体中，可以勾进容器的生命周期。 import Foo try services.register(FooProvider()) Vapor的第三方库一般都会选择实现它来组织代码 public final class LoggerProvider: Provider &#123; /// See `Provider`. public func register(_ services: inout Services) throws &#123; services.register(PrintLogger.self) services.register(FileLogger.self) &#125; /// See `Provider`. public func didBoot(_ container: Container) throws -&gt; Future&lt;Void&gt; &#123; let logger = try container.make(Logger.self) logger.log(&quot;Hello from LoggerProvider!&quot;) return .done(on: container) &#125; &#125; 实现Provider协议后，当注册LoggerProvider到应用的Services结构体中，它就会自动注册上面的两个服务。同时当容器启动的时候，就可以验证provider是否已经添加（注册服务）了。 Client作为客户端使用时，首先需要一个服务容器（Container）来创建客户端。通常如果像进入你服务器的请求结果一样请求外部API，你就应该使用请求容器来创建一个客户端 let res = try req.client().get(&quot;http://vapor.codes&quot;) print(res) // Future&lt;Response&gt; 只要容器（app、req）就能创建客户端 // Creates a generic Client let client = try container.client() 发送请求 let req: Request ... let res = try client.send(req) print(res) // Future&lt;Response&gt; let user: User ... let res = try client.post(&quot;http://api.vapor.codes/users&quot;) &#123; post in try post.content.encode(user) &#125; print(res) // Future&lt;Response&gt; Content有对应的编码器或解码器指定，模型才会按特定的序列形式在HTTP上进行通讯。 因为所有的HTTP请求都必须包含content type，所以Vapor能根据这自动选择合适的编码器或者报错。同时也可以在应用的配置设定Vapor默认的编码器和解码器 /// Create default content config var contentConfig = ContentConfig.default() /// Create custom JSON encoder var jsonEncoder = JSONEncoder() jsonEncoder.dateEncodingStrategy = .millisecondsSince1970 /// Register JSON encoder and content config contentConfig.use(encoder: jsonEncoder, for: .json) services.register(contentConfig) 便利解码为了更方便解码HTTP请求，Vapor提供了扩展的Router方法 //原始方法 router.post(&quot;login&quot;) &#123; req -&gt; Future&lt;HTTPStatus&gt; in return req.content.decode(LoginRequest.self).map(to: HTTPStatus.self) &#123; loginRequest in print(loginRequest.email) // user@vapor.codes print(loginRequest.password) // don&apos;t look! return .ok &#125; &#125; //效果同上的便利方法 router.post(LoginRequest.self, at: &quot;login&quot;) &#123; req, loginRequest in print(loginRequest.email) // user@vapor.codes print(loginRequest.password) // don&apos;t look! return HTTPStatus.ok &#125; 类型检测 自定义解码器和编码器（默认情况下都是会使用JSON解码器或者编码器） let user = try req.content.decode(User.self, using: JSONDecoder()) print(user) // Future&lt;User&gt; try res.content.encode(user, as: .urlEncodedForm) 响应默认返回的是200 OK的状态码，也可以进行自定义 //默认 router.get(&quot;user&quot;) &#123; req -&gt; User in return User(name: &quot;Vapor User&quot;, email: &quot;user@vapor.codes&quot;) &#125; //自定义 router.get(&quot;user&quot;) &#123; req -&gt; Future&lt;Response&gt; in return User(name: &quot;Vapor User&quot;, email: &quot;user@vapor.codes&quot;).encode(status: .created) &#125; //或者自定义 struct User: Content &#123; /// See `Content`. static let defaultContentType: MediaType = .urlEncodedForm ... &#125; 客户端 客户端的HTTP编码就像服务端返回的HTTP响应编码一样。 //编码后的请求 POST /login HTTP/1.1 Host: api.vapor.codes Content-Type: application/json &#123; &quot;email&quot;: &quot;user@vapor.codes&quot;, &quot;password&quot;: &quot;don&apos;t look!&quot; &#125; //发起编码的模型 import Vapor struct LoginRequest: Content &#123; var email: String var password: String &#125; //编码HTTP请求 let loginRequest = LoginRequest(email: &quot;user@vapor.codes&quot;, password: &quot;don&apos;t look!&quot;) let res = try req.client().post(&quot;https://api.vapor.codes/login&quot;) &#123; loginReq in // encode the loginRequest before sending try loginReq.content.encode(loginRequest) &#125; print(res) // Future&lt;Response&gt; //解码前的响应 HTTP/1.1 200 OK Content-Type: application/json &#123; &quot;name&quot;: &quot;Vapor User&quot;, &quot;email&quot;: &quot;user@vapor.codes&quot; &#125; //接收解码的模型 import Vapor struct User: Content &#123; var name: String var email: String &#125; //解码HTTP响应 let res: Future&lt;Response&gt; // from the Client let user = res.flatMap &#123; try $0.content.decode(User.self) &#125; print(user) // Future&lt;User&gt; 整个客户端的请求和接收响应的示例 // Create the LoginRequest data let loginRequest = LoginRequest(email: &quot;user@vapor.codes&quot;, password: &quot;don&apos;t look!&quot;) // POST /login let user = try req.client().post(&quot;https://api.vapor.codes/login&quot;) &#123; loginReq in // Encode Content before Request is sent return try loginReq.content.encode(loginRequest) &#125;.flatMap &#123; loginRes in // Decode Content after Response is received return try loginRes.content.decode(User.self) &#125; print(user) // Future&lt;User&gt; Query String当明确请求使用的编码是URL-Encoded Form时，可以直接使用所有Request都包含有的QueryContainer来解码Query String，对编码也一样 struct Flags: Content &#123; var search: String? var isAdmin: Bool? &#125; let flags = try req.query.decode(Flags.self) print(flags) // Flags let flags: Flags ... try req.query.encode(flags) 便利JSON由于有部分数据的编码没有规范标准，所以Vapor让自定义的JSON解码器更方便地处理这些数据 // Conforms to Encodable let user: User ... // Encode JSON using custom date encoding strategy try req.content.encode(json: user, using: .custom(dates: .millisecondsSince1970)) // Decode JSON using custom date encoding strategy let user = try req.content.decode(json: User.self, using: .custom(dates: .millisecondsSince1970)) 动态属性为响应添加属性这样的处理，即是处理Content，是完全基于Codable的。 Sessionsession 主要是维护客户端的连接状态，其通过为每个客户端创建唯一标识，并要求客户端在每一次请求中提供这个标识。这个标识可以利用任何的格式传递，但基本上都是使用cookies来完成。 当一个新客户端的连接和session数据设置后，Vapor返回一个用于设置Cookieheader的值，然后客户端就会被要求在每次请求的Cookieheader上重复返回该值，所有浏览器都会自动完成这个流程。如果你想让session失效，Vapor就会删除相关的所有数据并通知客户端它们的cookie已经不再有效。 要实现session的功能，首先要将中间件MiddlewareConfig配置到全局 //In configure.swift. var middlewares = MiddlewareConfig.default() middlewares.use(SessionsMiddleware.self) services.register(middlewares) 然后在每个路由中使用grouped(...)方法 // create a grouped router at /sessions w/ sessions enabled let sessions = router.grouped(&quot;sessions&quot;).grouped(SessionsMiddleware.self) // create a route at GET /sessions/foo sessions.get(&quot;foo&quot;) &#123; req in // use sessions &#125; Vapor 默认下会将sessions保持在内存，也可以在配置中重写这个形式。还能使用Fluent的数据库或缓存来持久化sessions。 当中间件生效后，就可以使用req.session()去访问 // create a route at GET /sessions/get sessions.get(&quot;get&quot;) &#123; req -&gt; String in // access &quot;name&quot; from session or return n/a return try req.session()[&quot;name&quot;] ?? &quot;n/a&quot; &#125; // create a route at GET /sessions/set/:name sessions.get(&quot;set&quot;, String.parameter) &#123; req -&gt; String in // get router param let name = try req.parameters.next(String.self) // set name to session at key &quot;name&quot; try req.session()[&quot;name&quot;] = name // return the newly set name return name &#125; // create a route at GET /sessions/del sessions.get(&quot;del&quot;) &#123; req -&gt; String in // destroy the session try req.destroySession() // signal success return &quot;done&quot; &#125;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>vapor</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vapor的部署]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FVapor%E7%9A%84%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[最近计划搭个后端，开始实践Swift的后台开发，借此了解后台数据库的操作，为之后学习前端和在客户端搞点事情时做一些接口的准备。 才过去了几个月，Vapor就升级到3.0版本，还提供了他们自家的云端 Vapor Cloud，通过 Vapor tool 就可简单地将工程部署上去。 同时，在Swift4.0上，部署到Heroku的一些操作细节也不一样了，下面就来讲述一下部署到这两个平台的步骤 Vapor Cloud官方文档在此 1.先 build 好工程，然后运行看看是否正常（vapor run server该方法已经被抛弃，使用vapor xcode -y，在Xcode上运行代替）编译时若提示 –enable-prefetching option is unavailable in swift 4.1 则需检查Package.swift中指定的Vapor版本是否对应当前的Swift版本，即使用最新的Vapor tool创建的工程，默认配置的都可能对应不上，这里将3.0.0改为3.0.6就解决了 let package = Package( name: &quot;SavingThePlanet&quot;, dependencies: [ .package(url: &quot;https://github.com/vapor/vapor.git&quot;, from: &quot;3.0.6&quot;), .package(url: &quot;https://github.com/vapor/fluent-sqlite.git&quot;, from: &quot;3.0.0&quot;) ], targets: [ .target(name: &quot;App&quot;, dependencies: [&quot;FluentSQLite&quot;, &quot;Vapor&quot;]), .target(name: &quot;Run&quot;, dependencies: [&quot;App&quot;]), .testTarget(name: &quot;AppTests&quot;, dependencies: [&quot;App&quot;]) ] ) 2.按着文档中的步骤一步步配置 先在他们家的后台(https://dashboard.vapor.cloud/)注册账号，然后创建一个应用，应用要与本地项目目录名一致， 也可以在本地通过指令创建，创建前先登录 vapor cloud login vapor cloud create proj部署前先为项目添加Git 然后开始部署 vapor cloud deploy中途会有各种询问 指定创建的应用名 指定模块名 指定主域名 创建项目环境 指定部署的分支 指定复制容量 增加数据库（可选，使用创建指令提前创建 vapor cloud create db） 指定构建类型 就这样，轻松部署完毕。 项目其中的文件 cloud.yml 是一个设置可选项的扩展配置文件，需要增加自定义的设置可在上面添加。 Heroku现在Heroku后台(https://dashboard.heroku.com)注册账号，然后创建一条pipeline，再在此pipline上创建应用。 在应用的Settings做一些环境配置（这里我使用Github做仓库管理，没用Heroku的Git）： 指定GitHub Repo 指定Buildpacks，交代应用的依赖库和配置环境（一般使用 https://github.com/kylef/heroku-buildpack-swift.git） 指定域名和SSL（可选） 然后在应用的Deploy做一些发布配置 发布方式指定（这里选择GitHub） 自动发布指定（根据Git的push动作自动重编译和发布） 发布的分支指定 最后，将能在本地通过build和run的项目push到GitHub，Activity里就有当前build的进度和日志显示，访问Heroku提供的默认域名地址后，在More的View logs里能看到访问的情况。 ** 特别提示： ** 不同Vapor版本，不同的Procfile在使用 Vapor 2 的时候，项目根目录中的Procfile文件需要填入以下内容 web: Run –env=production –port=$PORT 在使用 Vapor 3 的时候，Procfile则需要填入以下内容 web: Run serve --env production --hostname 0.0.0.0 --port $PORT使用Procfile可以为web服务器设置运行进程。因为一开始不知道Vapor 3下的配置格式而使用了Vapor 2的旧格式配置，导致卡了很久都没能在云端访问成功（发布显示成功了），访问时一直提示Application Error，日志中打印status=503 code=H10/H14 app crash。 自定义swift版本同时还要指定一个.swift-version文件，里面填入需要依赖的Swift版本号（这里填入4.1.2），同样放在项目的根目录下。 迁移项目目录需要先清掉历史的build，再重新build，否则run会失败（一些文件中的路径没更新） vapor build –clean 搞定后再推到GitHub上，等待Heroku编译和发布，访问成功。需要多谢这篇文章的指引。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>vapor</tag>
        <tag>swift</tag>
        <tag>heroku</tag>
        <tag>cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vapor（一）基础篇]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FVapor%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[其实这个Vapor系列的文章和官网介绍的差不多，但为了加深个人理解和方便日后查阅，还是逐点再撸一遍，并且将知识点做了一下归类。过程中会有类比到其它系统、语言，又或者是旧版本的Vapor，分析它们的特性、设计模式等，使学习起来更加融会贯通。 第一篇，先介绍一下Vapor的一些基础概念，像文件结构、服务、路由、异步等等。 文件结构├── Public ├── Sources │ ├── App │ │ ├── Controllers │ │ ├── Models │ │ ├── boot.swift │ │ ├── configure.swift │ │ └── routes.swift │ └── Run │ └── main.swift ├── Tests │ └── AppTests └── Package.swift PublicPublic文件夹用于存放样式表、图片和脚本。当Vapor响应一个请求时会优先检查该文件夹里是否有要请求的内容，有则跳过后台应用的逻辑并直接使用该文件返回。例如请求localhost:8080/favicon.ico，会检查Public/favicon.ico，有则直接返回。 App两个存放源码的地方之一，这是最重要的文件夹，所有后台应用的逻辑均在此处 Controllers：组织应用逻辑的地方，有大量的函数来接收请求和回馈响应。 Models：存放支持Content类型的模型和Fluent模型的地方。 boot.swift：后台应用启动后，但在真正运行前，会执行其中的函数。适合将需要在应用启动时初始化的工作放在此处。（可以看作是iOS AppDelegate中的didFinishLaunching方法） configure.swift：此处包含一个函数用于接收配置、环境和服务，给后台应用作为输入。适合将注册服务或更改配置放到此处执行。 routes.swift：配置路由的地方。 AppTests存放单元测试文件的地方 Package.swift依赖包清单。 服务（Services）Vapor使用个 Services 是一个依赖注入式的框架，在应用里可以通过它来注册、配置、初始化任何需要的内容。 Vapor不支持静态访问，若要访问一个类或结构体，则要通过方法或初始化。因为避免静态访问变量有助于使Vapor通过停止使用线程安全锁或信号量的来提升性能。 使用服务好处是能够解耦调用者与实现者的关系，而且Services相当于一个大型的调控中心，将各种服务保存起来，供需要时从这统一调用，注册服务时也统一通过它来进行。 在注册服务的时候可以指定一致的协议 /// Register routes to the router let router = EngineRouter.default() try routes(router) services.register(router, as: Router.self) // services belongs to app let router = app.make(Router.self) let engineRouter = app.make(EngineRouter.self) print(router) // Router (actually EngineRouter) print(engineRouter) // EngineRouter print(router === engineRouter) // true 容器（Container）容器由四个部分组成 Services Config Environment Worker Vapor里常用的容器有 Application、Request、Response 通过容器能够创建出服务（遵指定特定协议或类来获得一个对象，前提是容器要预先注册好该服务），因为容器里面有属于它自己的一个Services属性（当然使用Services的单例除外） /// Register to sevices. let sqlite = SQLiteDatabase(storage: .memory) services.register(sqlite) // services belongs to app let db = app.make(SQLiteDatabase.self) print(db) // SQLiteDatabase (the one we registered earlier) let leaf = try req.make(LeafRenderer.self) print(leaf) /// Definitely a LeafRenderer let view = try req.make(ViewRenderer.self) print(view) /// ViewRenderer, might be a LeafRenderer 路由（Route）在Vapor里默认的路由类是EngineRouter，也可以自定义路由类，但需要遵从Router协议。 若自定义了路由类的话，在configure.swift中应使用自定义路由类创建对象来注册服务。 在routes.swift的配置路由的函数routes中使用入参router配置路由时，支持用英文逗号分隔开路径，或直接使用反斜杠连接显示 router.get(&quot;path&quot;, &quot;to&quot;, &quot;something&quot;) &#123;...&#125; router.get(&quot;path/to/something&quot;) &#123;...&#125; 可以将路由的实现交由controller的方法完成 let helloController = HelloController() router.get(&quot;greet&quot;, use: helloController.greet) final class HelloController &#123; func greet(_ req: Request) throws -&gt; String &#123; return try req.make(BCryptHasher.self).hash(&quot;hello&quot;) &#125; &#125; 获取参数 router.get(&quot;users&quot;, Int.parameter) &#123; req -&gt; String in let id = try req.parameters.next(Int.self) return &quot;requested id #\(id)&quot; &#125; GET /users/:id 环境（Environment）通过环境的设置，能赋予应用方便地动态切换情景，执行不一样的（配置、服务、初始化）版本，在启动App时指定 swift run Run --env prod 容器在默认环境下是.development，可以通过.environment属性获取，一般用在configure.swift中使用 services.register &#123; container -&gt; BCryptConfig in let cost: Int switch container.environment &#123; case .production: cost = 12 default: cost = 4 &#125; return BCryptConfig(cost: cost) &#125; let sqlite: SQLiteDatabase if env.isRelease &#123; /// Create file-based SQLite db using $SQLITE_PATH from process env sqlite = try SQLiteDatabase(storage: .file(path: Environment.get(&quot;SQLITE_PATH&quot;)!)) &#125; else &#123; /// Create an in-memory SQLite database sqlite = try SQLiteDatabase(storage: .memory) &#125; services.register(sqlite) 配置（Config）当有多个服务遵从同一个协议时，需要使用Config结构体来声明该协议优先对应的服务 /// Declare preference for MemoryKeyedCache anytime a container is asked to create a KeyedCache config.prefer(MemoryKeyedCache.self, for: KeyedCache.self) /// ... /// Create a KeyedCache using the Request container let cache = req.make(KeyedCache.self) print(cache is MemoryKeyedCache) // true 内容（Content）在Vapor 3中，JSON, protobuf, URLEncodedForm, Multipart等，所有的Content类型都一样，需要序列化和解析的Content都要是一个Codable的类或结构体（即是要遵从Content协议）。 像下面返回Response的例子中，因为User遵从了Content协议，所以在下面注册路由里的实现能直接返回User对象作为Response，回调得到的User对象会被调用其Content协议中的方法进行编码成JSON返回 //HTTP响应 HTTP/1.1 200 OK Content-Type: application/json &#123; &quot;name&quot;: &quot;Vapor User&quot;, &quot;email&quot;: &quot;user@vapor.codes&quot; &#125; //预期的结构体或类 struct User: Content &#123; var name: String var email: String &#125; //编码HTTP响应 router.get(&quot;user&quot;) &#123; req -&gt; User in return User( name: &quot;Vapor User&quot;, email: &quot;user@vapor.codes&quot; ) &#125; Request的用法也差不多，指定需要解码出的对象类型，就能从JSON转换成对应的模型对象 //HTTP请求 POST /login HTTP/1.1 Content-Type: application/json &#123; &quot;email&quot;: &quot;user@vapor.codes&quot;, &quot;password&quot;: &quot;don&apos;t look!&quot; &#125; //预期的结构体或类 struct LoginRequest: Content &#123; var email: String var password: String &#125; //解码HTTP请求 router.post(&quot;login&quot;) &#123; req -&gt; Future&lt;HTTPStatus&gt; in return req.content.decode(LoginRequest.self).map(to: HTTPStatus.self) &#123; loginRequest in print(loginRequest.email) // user@vapor.codes print(loginRequest.password) // don&apos;t look! return .ok &#125; &#125; 异步（Async）当应用启动时通常会创建一个事件循环给运行它的每个CPU核心。每个事件循环有一条线程。但和Node.js中的只能运行一个事件循环不同，Vapor基于Swift支持多线程的特性，其能够在一个进程中运行多个事件循环，而其它方面则都非常地相似。 每一次有客户端连接服务器时，服务器就能够指派一个事件循环给客户端进行通信，并且均在此同一个事件循环上进行。 事件循环负责跟踪每一个连接了的客户状态。如果有一个等待服务端接收的请求，事件循环会触发接收通知来促使数据被接收。当整个请求被接收完毕后，某个等待返回请求数据future就会被触发完成。 核心就是利用Future&lt;T&gt;这样一个类型 去接收异步任务的返回； 执行指定的回调任务； 实现链式响应。 第一个最简单的例子，futureString获得等待异步任务返回的任命后，在它身上设置上异步任务返回后需要执行的回调任务，指定的方法就是.map(to:)，参数是说明回调执行后的返回值，闭包中的string其实就是futureString收到异步返回后的真正结果。 但大家可能会有疑问，若就在这么一行代码之间，设置回调前异步的任务就已经返回了的话，后面的设的回调会不会没有机会执行了，不用慌，.map(to:)方法里有状态判断到底futureString等待的异步任务是否返回了，若已经返回了的话当然设置完回调就立马执行了。 还有一个要注意的点，.map(to:)返回的结果也是Future&lt;T&gt;，其中的T就是to参数中的类型了，继续返回Future的类型是为了下面会说到链式响应而设计的。当你还要用这个最后的future结果处理其它逻辑时，可继续给它指定回调任务，如此类推地设置你需要在第一级异步任务执行后的一系列任务。 /// Assume we get a future string back from some API let futureString: Future&lt;String&gt; = ... /// Map the future string to an integer let futureInt = futureString.map(to: Int.self) &#123; string in print(string) // The actual String return Int(string) ?? 0 &#125; /// We now have a future integer print(futureInt) // Future&lt;Int&gt; 第二个例子，当回调里的任务也是异步的怎么办？最后得到的结果岂不是变成Future&lt;Future&gt;？ 为了避免这个问题，Vapor定义了 .flatMap(to:) 这样一个方法，直译就是“平面映射”。原理应该是当前future在执行其回调闭包后，获得返回结果也是future对象时，会等待该返回的future等待的异步任务完成后，再将其t对象拿出传入下一个future的回调闭包中去。 反正就是若回调闭包中返回Future类型的结果，则需要使用.flatMap(to:)方法设置回调。 /// Assume we get a future string back from some API let futureString: Future&lt;String&gt; = ... /// Assume we have created an HTTP client let client: Client = ... /// Flat-map the future string to a future response let futureResponse = futureString.flatMap(to: Response.self) &#123; string in return client.get(string) // Future&lt;Response&gt; &#125; /// We now have a future response print(futureResponse) // Future&lt;Response&gt; Future的链式响应 /// Assume we get a future string back from some API let futureString: Future&lt;String&gt; = ... /// Assume we have created an HTTP client let client: Client = ... /// Transform the string to a url, then to a response let futureResponse = futureString.map(to: URL.self) &#123; string in guard let url = URL(string: string) else &#123; throw Abort(.badRequest, reason: &quot;Invalid URL string: \(string)&quot;) &#125; return url &#125;.flatMap(to: Response.self) &#123; url in return client.get(url) &#125; print(futureResponse) // Future&lt;Response&gt; 变换，用来修改future对象的值，一般用于修改Future这种类型，因为这类型经常会作为一种回调信号，单单只是需要知道完成了就可以的情况，修改它值也没有什么重要的影响。 /// Assume we get a void future back from some API let userDidSave: Future&lt;Void&gt; = ... /// Transform the void future to an HTTP status let futureStatus = userDidSave.transform(to: HTTPStatus.ok) print(futureStatus) // Future&lt;HTTPStatus&gt; Future对象一般是通过Promises类来创建，但大部分情况下，Promises不需我们管理，而在Vapor的API里完成创建Future对象并返回 Application、Request、Response这三个类同时也是最常用的Worker，所谓Worker就是执行异步任务或者访问事件循环。 /// Assume we have a Request and some ViewRenderer let req: Request = ... let view: ViewRenderer = ... /// Render the view, using the Request as a worker. /// This ensures the async work happens on the correct event loop. /// /// This assumes the signature is: /// func render(_: String, on: Worker) view.render(&quot;home.html&quot;, on: req) 若没有多重的异步任务执行时，可以使用Future简单的do/catch方法来等待异步的返回即可 /// Assume we get a future string back from some API let futureString: Future&lt;String&gt; = ... futureString.do &#123; string in print(string) // The actual String &#125;.catch &#123; error in print(error) // A Swift Error &#125; 也可以使用always方法来执行异步返回后的回调，无论成功与否 /// Assume we get a future string back from some API let futureString: Future&lt;String&gt; = ... futureString.always &#123; print(&quot;The future is complete!&quot;) &#125; 同步等待，注意千万不要用在路由的闭包里，因为在事件循环中阻塞了线程，会使所有用户都无法访问，直到阻塞结束。 /// Assume we get a future string back from some API let futureString: Future&lt;String&gt; = ... /// Block until the string is ready let string = try futureString.wait() print(string) /// String]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>vapor</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的使用环境配置]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FPython%E7%9A%84%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[公司更换新Mac，i7的cpu跑起来还是挺爽的，电脑还是买顶配的划算，无论从使用时间、使用期限和使用体验上，都是物有所值。 为了维护我们客户端自己的Web版工具，新电脑上得重新配置一次开发环境，但无奈以前配置环境时没有总结，导致又多踩一遍坑。这次总结会包括 安装Python3.x 配置项目的Python虚拟环境 配置PyCharm的编译环境 更新Django版本 顺带记录一下其它使用Python的工具或者管理器的问题，像Qgis、Anaconda。 安装Python最简单不过的就是通过Homebrew安装了 $ brew search python 也可以下载安装包手动安装。 更新python brew upgrade python 更新pip python -m pip install --upgrade pip 升级python后提示找不到python3，这时需软连接到 /usr/local/bin 目录就能解决 ln -s /usr/local/Cellar/python/3.6.5_1/bin/python3 /usr/local/bin/python3 pip3 的软连接 ln -s /usr/local/Cellar/python/3.6.5_1/bin/pip3.6 /usr/local/bin/pip3 配置PyCharm的编译环境字符编码问题安装python3后，在pycharm的preference里设置解析器，若要新建环境而又提示venv环境已存在则要先移除venv文件夹。选择要使用的python版本，python3.x的版本位于/usr/local/bin/python3.x(系统默认的位于/usr/bin/python2.7)。 当点击OK保存时提示了以下错误 UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position XX 这是字符编码的问题，可尝试在/usr/local/lib/python3.x/site-packages/sitecustomize.py中加入以下代码 import sys sys.setdefaultencoding(&apos;UTF-8&apos;) 如果还是不行，那要考虑将环境创建在没有中文的路径下。 找不到Django模块问题上面的问题搞定后，又出现新的报错，提示 no module named django.core.management 先查询Django版本 $ django-admin --version 查询无果则应先安装Django，若有版本信息则可能是venv使用的Python版本不对，这里找不到是因为Django(从1.9)更新到最新的2.x了 $ pip3 install django 然后，再重新设置interpreter，venv必须选用site-packages包含Django的Python版本，否则仍然无法import django 一开始选择了错误的版本路径 /usr/local/lib/python3.6 后来选择正确的版本路径为 /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6 然后运行起项目 python manage.py runserver 在项目设置中，Parameters填的就是此命令中的runserver，Script path填的是manager.py的文件路径，Working directory是manager.py所在的目录路径，Python interpreter选择刚创建好的venv的python版本 Django版本兼容问题1.CASCADE 若运行失败，出现报错 TypeError: init() missing 1 required positional argument: ‘on_delete’ 是因为django升级到2.x后的一个变动导致的，官方说明如下 Deprecated since version 1.9:on_delete will become a required argument in Django 2.0. In older versions it defaults to CASCADE 即是以前不用指定默认的on_delete参数，现在需要显式指定，如以往没有指定on_delete，则代码可以更新为以下样子 categorie = models.ForeignKey( &apos;Categorie&apos;, on_delete=models.CASCADE, ) CASCADE 代表串联删除，官方更新说明地址。 2.reverse 其次2.x的django还将reverse存放的包变更了，可以用下面方式向下兼容 try: from django.core.urlresolvers import reverse except BaseException: from django.urls import reverse 3.urllib 然后python3.6也有一个更新，使用urllib库访问https连接，会返回错误 ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:645) 解决方法是在终端直接运行以下命令安装certifi模块 /Applications/Python\ 3.6/Install\ Certificates.command 然后在用到ssl的地方import ssl。参考地址。 4.MIDDLEWARE_CLASSES普通业务模块正常运作，但使用host:8000/admin去访问中间件Django管理时，页面显示404，提示找不到该url路径。“The current path, admin, didn’t match any of the URLconf defined in web_server.urls”这篇stackoverflow有提出相关的解决办法，但检查后没发现错误。 有说在python3.6下要将settings.py中的老式MIDDLEWARE_CLASSES替换为新式的MIDDLEWARE，有说将新式替换为老式的，但试过均无法解决。在python3下替换为新式的会提示： ImportError: Module “django.contrib.auth.middleware” does not define a “SessionAuthenticationMiddleware” attribute/class django.core.exceptions.ImproperlyConfigured: WSGI application ‘web_server.wsgi.application’ could not be loaded; Error importing module. 若是提示WSGIRequest类的user属性找不到可以参考这篇，‘WSGIRequest’ object has no attribute ‘user’ Django admin。 最后还是还原回代码最初使用的环境，将django还原回1.10.3的版本如果是使用2.7的python，先使用easy_install安装pip $ sudo easy_install pip 然后使用2.7的pip安装1.10.3的django $ pip2.7 install django==1.10.3 5.虚拟环境也顺带了解一下Python的虚拟环境。 我们可以同时安装多个Python版本在系统上，通过在python指令后加版本数字来区分使用的python版本。但在开发应用时，也可能会存在不同应用需要不同的python版本，甚至不同的python工具包的版本，这时就需要用到venv这个基于一个或多个项目“独立”的Python运行环境，来解决不同应用间多版本的冲突问题。 有一个叫virtualenv的工具，可通过pip（管理Python库的工具）安装得到 $ pip3 install virtualenv 通过这个工具，使用命令virtualenv可以创建一个独立的Python运行环境，我们还可以加上参数--no-site-packages使系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。新建的Python环境被放到当前目录下的venv目录。可以用source命令进入该环境： $ source venv/bin/activate 退出当前的venv环境，使用deactivate命令： $ deactivate 其与其它env工具的区别可以参考这里 Qgis的环境问题安装Qgis后提示找不到python3.6，软连接到这里即可解决 sudo ln -s /usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework /Library/Frameworks/Python.framework Qgis需要的库 pip3 install owslib PyYaml psycopg2 jinja2 pygments plotly 其中osgeo需要安装gdal sudo python3 -m pip install gdal 如果报错提示 Command “python setup.py egg_info” failed with error code 1 in /private/var/folders/xxx/ 可以换用brew安装 brew install gdal 如果还报错提示 Error: gdal contains conflicting version recursive dependencies: python@2, pythonView these with brew deps --tree gdal. 最后在这里找到解决方法，要使用qgis3.0版本，就需要安装gdal2.0版本 $ brew unlink gdal $ brew tap osgeo/osgeo4mac &amp;&amp; brew tap --repair $ brew install jasper netcdf $ brew install gdal2 --with-armadillo --with-complete --with-libkml --with-unsupported $ brew link --force gdal2 安装完毕后到.bash_profile添加下面的一句后保存及激活 $ vi ~/.bash_profile export PATH=&quot;/usr/local/opt/gdal2/bin:$PATH&quot; $ source ~/.bash_profile Anaconda1.Anaconda安装的Python库目录root环境下安装的Python库文件目录为: /Users/userName/anaconda/lib/python2.7/site-packages python27环境下安装的Python库文件目录为: /Users/userName/anaconda/envs/python27/lib/python2.7/site-packages python3环境下安装的Python库文件目录为: /Users/zj_macbook/anaconda/envs/python3/lib/python3.6/site-packages 2.pip安装的Python库目录pip安装的Python库文件目录: /usr/local/lib/python2.7/site-packages pip3安装的Python库文件目录: /usr/local/lib/python3.6/site-packages 3.另外当Anaconda图形交换界面上选择的第三方库下载很慢的时候，可以直接找出Anaconda下的pip去终端执行命令行来下载，速度会有显著的提升。 brew会为可执行程序创建链接，位于: /usr/local/bin 实际安装的位置在 /usr/local/Cellar]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>PyCharm</tag>
        <tag>Django</tag>
        <tag>Python</tag>
        <tag>Anaconda</tag>
        <tag>Qgis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac命令行工具及其问题收录]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2FMac%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%85%B6%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[问题集OSX使用oh-my-zsh后.bash_profile自定义失效原因：oh-my-zsh的配置文件为.zshrc，而默认shell（bash）的配置文件为.bash_profile解决：将.bash_profile的配置移到.zshrc中去。在.zshrc添加source ~/.bash_profile会产生打开终端初始化过久的问题。 使用brew安装命令行工具时，提示”Error: undefined method `sdk_path_if_needed’ for OS::Mac:Module”原因：brew版本过老解决：运行 brew update-reset 去更新brew 更新Cocoapods报错”Operation not permitted”更新gem，sudo gem update –systemsudo gem install cocoapods报错：Operation not permitted - /usr/bin/xcodeproj解决：sudo gem install -n /usr/local/bin cocoapods 功能集vim分屏vim -on file1_path file2_path .sqlite3文件查看$ sqlite xx.sqlite3 //打开数据库文件 sqlite&gt;.help //帮助 sqlite&gt;.quit //退出 sqlite&gt;.tables //查所有表 sqlite&gt;.show //查配置 sqlite&gt;.mode list/line/column //设置查询结果排列格式 sqlite&gt;.headers on //是否显示头 sqlite&gt;select * from xx_table //查表语句执行 当然可以下载以下工具应用使用代替 Sqlite Database brower Datum Sqlite Professional mac 匹配字符当前目录下 查找”hello,world!”字符串grep -rn “hello,world!” * *: 表示当前目录所有文件，也可以是某个文件名-r 是递归查找-n 是显示行号-R 查找所有文件包含子目录-i 忽略大小写 其它命令行参数：grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，grep -l pattern files ：只列出匹配的文件名，grep -L pattern files ：列出不匹配的文件名，grep -w pattern files ：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），grep -C number pattern files ：匹配的上下文分别显示[number]行，grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行，grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。 &lt; 和 &gt; 分别标注单词的开始与结尾:grep man * 会匹配 ‘Batman’、‘manic’、‘man’等，grep ‘&lt;man’ * 匹配‘manic’和‘man’，但不是‘Batman’，grep ‘&lt;man&gt;‘ 只匹配‘man’，而不是‘Batman’或‘manic’等其他的字符串。‘^’：指匹配的字符串在行首，‘$’：指匹配的字符串在行尾， 文件字符转码iconv -f UTF8 -t GB18030 a.csv &gt;b.csv 查找文件find /Applications/Xcode.app -name stdio.h 查看文件大小分布du -sh *du -d 1 h(Xcode的缓存和各版本的iOS SDK占用量极大，会造成系统占用磁盘比例极高) 根据占用端口杀进程lsof -i:端口号kill -9 PID 执行Xcode功能（xcrun）# 截图 xcrun simctl io booted screenshot /pictures/test.png # 录屏 xcrun simctl io booted recordVideo /videos/test.mp4 # 查看已安装设备 xcrun simctl list xcrun instruments -s # 启动模拟器 （Xcode9以下） xcrun simctl boot $UUID xcrun instruments -w &quot;iPhone 8(11.2)&quot; xcrun simctl boot &quot;iPhone 8(11.2)&quot; （Xcode9或以上） open -a &apos;Simulator&apos; --args -CurrentDeviceUDID &lt;device_udid_here&gt; # 关闭模拟器 xcrun simctl shutdown $UUID # 重置模拟器 xcrun simctl erase $UUID # 安装指定app xcrun simctl install booted &lt;app路径&gt; xcrun simctl install &lt;device&gt; &lt;app路径&gt; # 运行指定app xcrun simctl launch booted &lt;bundle identifier&gt; xcrun simctl launch &lt;device&gt; &lt;bundle identifier&gt; # 关闭app xcrun simctl terminate booted &lt;bundle identifer&gt; xcrun simctl terminate &lt;device&gt; &lt;bundle identifier&gt; # 卸载app xcrun simctl uninstall booted &lt;bundle identifer&gt; xcrun simctl uninstall &lt;device&gt; &lt;bundle identifier&gt; # 模拟器与Mac之间复制粘贴 pbcopy pbpaste xcrun simctl pbcopy booted xcrun simctl pbpaste booted xcrun simctl pbsync sourceDevice destDevice # 帮助 xcrun simctl -h]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>command</tag>
        <tag>Mac</tag>
        <tag>question</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Firebase实现的推送功能系统]]></title>
    <url>%2Funcategorized%2F%E5%88%A9%E7%94%A8Firebase%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[本文不是一篇介绍如何接入Notification的教程，而主要是关联起应用业务来讲述关于到点的推送模式的实现过程，以及补充一些推送接入时的注意点。接入教程的话，喵神的这篇《活久见的重构 - iOS 10 UserNotifications 框架解析》已经十分有条理地把UserNotification的细节说得非常清晰。 业务背景业务需求是，利用Firebase Cloud Message（下文简称FCM）这个云消息系统作为中间工具，实现到点的推送，这里说的点并不是传统的指一台设备，而是指一个账号或者一个角色，例如推送给达到指定等级，或者满足了特定条件的用户群，又例如推送给加入了公会的成员，或者会长发送广播通知推送。 基于FCM的实现，会简化了很大一部分的工作，包括： iOS DeviceToken的管理：FCM会生成一个Instance Token来进行关联，它的后台使用这个映射关系找出DeviceToken然后发推送APNS。 服务端跨平台的对接：服务端提供给客户端接入的业务逻辑接口是统一的，而向FCM发消息的接口是单一的，给不同平台发送消息的部分封装在FCM的接口内部，所以不需要考虑区分iOS和Android的差异即能完成跨平台的对接。 分类推送功能：FCM会建立多个设备Instance Token对应Topices（主题）、Event（行为）的关系表，在发消息时可以选择针对某一Topic或者Event，实现特定用户群的推送。而表中的关系有客户端触发增加或删除，而控制客户端这个操作的则是业务需求而定了，下面将会讲述。 设备组推送功能：能自定义捆绑器一堆Instance Token，利用这个Token的捆绑包为单位作为一个推送点。 此处的业务应用是基于手游App上面展开的。 业务实现注册推送在合适的位置调用以下方法，来获取推送授权，注册推送。由于被拒绝授权后，重新获取授权会十分麻烦，所以这里应该尽量考虑放在能激起用户接收推送的位置或者时机再触发。 #ifdef __IPHONE_8_0 if ([application respondsToSelector:@selector(registerForRemoteNotifications)]) &#123; [application registerForRemoteNotifications]; [application registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes: UIUserNotificationTypeNone| UIUserNotificationTypeBadge| UIUserNotificationTypeSound categories:nil]]; &#125; else &#123; [application registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert|UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeSound]; &#125; #else [application registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert|UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeSound]; #endif 处理通知通知的接收分为以下几种情况 状态 类型 处理位置(UIApplicationDelegate/UNUserNotificationCenterDelegate) App在前台 远程通知 App在前台 本地通知 App在后台 远程通知 App在后台 本地通知 然后在推送消息中设计了一些附加字段控制消息的类型、内容、显示方式，一共有三个字段 FirebaseContentType：消息的类型，例如url、dialog FirebaseContent：消息的内容，例如对应url的一个地址、或者对应dialog的一段文本 FirebaseShowMode：消息展示方式，例如考虑游戏用户可能不想被打断操作，则应使用横幅提示的形式，其它情况可以考虑使用弹提示框询问、或者直接显示、甚至自定义显示形式。 本地通知处理未启动App的接收iOS10以前，在application:didFinishLaunchingWithOptions:里利用launchOptions携带的信息处理本地推送启动App的事件，但不做远程推送的处理，因为application:didReceiveRemoteNotification:fetchCompletionHandler:会在当前回调方法执行完之后接着被调用，这也是实现静默推送的方法，而application:didReceiveLocalNotification:不会被调用。 iOS10及以上，应在此回调中初始化UserNotificationCenter的delegate，并实现对应的UNUserNotificationCenterDelegate方法。 - (void)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; ··· #ifdef __IPHONE_10_0 if ([[UIDevice currentDevice] systemVersion].floatValue &gt;= 10.0) &#123; EFNFirebaseNontificationController *notificationController = [[[self class] alloc] init]; [UNUserNotificationCenter currentNotificationCenter].delegate = notificationController; return; &#125; #endif UILocalNotification *localNotification = launchOptions[UIApplicationLaunchOptionsLocalNotificationKey]; if (localNotification) &#123; NSString *contentType = localNotification.userInfo[EFNFirebaseNotificationUserInfoContentTypeKey]; NSString *content = localNotification.userInfo[EFNFirebaseNotificationUserInfoContentKey]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; //业务处理 [self private_handleNotificationWithContentType:contentType content:content]; &#125;); &#125; &#125; 这里有三个注意点 由于游戏的主Window初始化可能会比较慢，避免后面的一些在Window或者RootViewController的view上交互的UI出现显示异常，这里做了一个延迟执行的处理。 UIApplicationLaunchOptionsLocalNotificationKey已经被抛弃了，所以它应该只作为兼容处理，尽量使用UserNotification，设置[UNUserNotificationCenter currentNotificationCenter].delegate成为必须要实现的部分。 若通过点击本地推送消息启动App的话，launchOptions的结构则是这样的 //launchOptions &#123; UIApplicationLaunchOptionsLocalNotificationKey = &quot;&lt;UIConcreteLocalNotification: 0x17018cd90&gt;&#123;fire date = 2018\134U5e741\134U670815\134U65e5 \134U661f\134U671f\134U4e00 \134U4e2d\134U56fd\134U6807\134U51c6\134U65f6\134U95f4 \134U4e0b\134U53487:25:56, time zone = (null), repeat interval = 0, repeat count = UILocalNotificationInfiniteRepeatCount, next fire date = (null), user info = &#123;\134n FirebaseMsg = https://www.google.com;\134n FirebaseType = url;\134n&#125;&#125;&quot;; &#125; //localNotification.userInfo &#123; FirebaseContent = &quot;https://www.google.com&quot;; FirebaseContentType = url; &#125; 而通过点击远程推送消息启动App的话，在application:didFinishLaunchingWithOptions:的launchOptions结构是这样的 &#123; UIApplicationLaunchOptionsRemoteNotificationKey = &#123; FirebaseContent = &quot;https://www.google.com&quot;; FirebaseShowMode = none; FirebaseContentType = url; aps = &#123; alert = push6; &#125;; &quot;gcm.message_id&quot; = &quot;0:1516016736340703%99c10dc399c10dc3&quot;; &quot;gcm.n.e&quot; = 1; &quot;google.c.a.c_id&quot; = 7885967838754698804; &quot;google.c.a.e&quot; = 1; &quot;google.c.a.ts&quot; = 1516016735; &quot;google.c.a.udt&quot; = 0; &#125;; &#125; //FirebaseMsg、FirebaseShow、FirebaseType这三个附加字段是自定义的，用来控制业务逻辑，其它gcm、google的是Firebase定义的。而aps则是系统定义的，在只设置推送消息的body时，里面的alert的值则会是一个字符串，而把消息的title、subtitle等都设置上的话，alert的值则会是一个字段，里面才区分body、title、subtitle。 更多的Payload格式参考。 iOS10及以上时，采用UNUserNotificationCenterDelegate处理推送的话，通过点击推送（不分本地或是远程）启动App就会回调以下代理方法 #ifdef __IPHONE_10_0 - (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)(void))completionHandler &#123; NSDictionary *userInfo = response.notification.request.content.userInfo; NSString *contentType = userInfo[EFNFirebaseNotificationUserInfoContentTypeKey]; NSString *content = userInfo[EFNFirebaseNotificationUserInfoContentKey]; [self private_handleNotificationWithContentType:contentType content:content]; !completionHandler?:completionHandler(); &#125; #endif 若要知道推送的来源，则可通过判断response.notification.request.trigger的类型来区分，在UNNotificationTrigger的子类里面，除了UNPushNotificationTrigger是代表远程推送的trigger外，其它子类均代表本地推送。 前后台接收iOS10以下（UIApplicationDelegate） - (void)application:(UIApplication *)application didReceiveLocalNotification:(nonnull UILocalNotification *)notification &#123; NSString *contentType = notification.userInfo[EFNFirebaseNotificationUserInfoContentTypeKey]; NSString *content = notification.userInfo[EFNFirebaseNotificationUserInfoContentKey]; [[self class] private_handleNotificationWithContentType:contentType content:content]; &#125; iOS10及以上（UNUserNotificationCenterDelegate） - (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler &#123; NSDictionary *userInfo = notification.request.content.userInfo; NSDictionary *apsInfo = userInfo[@&quot;aps&quot;]; id alertInfo = apsInfo[@&quot;alert&quot;]; NSString *contentType = userInfo[EFNFirebaseNotificationUserInfoContentTypeKey]; NSString *content = userInfo[EFNFirebaseNotificationUserInfoContentKey]; NSString *showMode = userInfo[EFNFirebaseNotificationUserInfoPresentModeKey]; if (apsInfo) &#123; [[self class] private_handleRemoteNotificationWithContentType:contentType content:content showMode:showMode alertInfo:alertInfo]; &#125; else &#123; !completionHandler?:completionHandler(UNNotificationPresentationOptionAlert|UNNotificationPresentationOptionSound|UNNotificationPresentationOptionBadge); &#125; &#125; 这里采用判断notification.request.content.userInfo是否含有apsInfo来决定是否本地推送，若为本地推送的时候就不再采用系统的横幅再次提示。 远程通知处理iOS10以下（UIApplicationDelegate） - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler &#123; NSDictionary *apsInfo = userInfo[@&quot;aps&quot;]; id alertInfo = apsInfo[@&quot;alert&quot;]; NSString *contentType = userInfo[EFNFirebaseNotificationUserInfoContentTypeKey]; NSString *content = userInfo[EFNFirebaseNotificationUserInfoContentKey]; NSString *showMode = userInfo[EFNFirebaseNotificationUserInfoPresentModeKey]; [[self class] private_handleRemoteNotificationWithContentType:contentType content:content showMode:showMode alertInfo:alertInfo]; &#125; 注意 当推送消息体中的aps的content-available为1时，App在后台挂起时方法也会被执行，即是静默推送(Silent-Push)。 在iOS7以上，实现了application:didReceiveRemoteNotification:fetchCompletionHandler:此代理方法的话application:didReceiveRemoteNotification:就不会被调用。 前台或后台的接收以及App通过推送触发启动均通过此方法处理。 iOS10及以上，与本地推送共用UNUserNotificationCenterDelegate的代理方法，前台接收通过userNotificationCenter:willPresentNotification:withCompletionHandler:的回调处理，后台接收或App通过推送触发启动通过userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler:的回调处理。 单用户推送由我们的服务端建立用户与其设备的关系表，即通过客户端把用户每次登陆的user ID与当前设备的FCM Token上传给服务端插入表，这样每个用户就会有一个设备组对应，利用FCM的设备组推送功能，就能针对某一个或一群指定user ID的用户的所有登录中的设备实施推送，例如补偿奖励给特定玩家之后，对特定大R的通知等等。 当用户登出，或使用新账号登录，则上报新登录的user ID与当前设备的FCM Token到服务端，当没有该user ID的记录，则建立初始对应关系，若已有记录则向其已对应的设备组推送新设备的登录通知。FCM会返回推送失败的设备，这些设备可能是更新了FCM Token，旧Token失效所致。然后服务端就可以向FCM申请删除失效的Token和添加新关联的Token到当前user ID的设备组里面。此时设备组关系更新完毕，这就是平时我们经常看到的安全登录通知功能。 群推送根据账号的操作，决定用户所属的推送群。例如小白用户一直升级，到了5级就是触发进入5级推送群组里面，即当前设备会订阅在FCM预定义的5级主题（level5 Topic），这也会当作当前用户的一项属性存在服务端，当用户在其它设备或者重装应用后能被恢复。这样后台推送给level5 Topic时，所有达到此条件，即是订阅了此主题的用户都会收到通知，其他用户则不会收到。 但只使用单一主题控制群推送仍未能满足需求，由于游戏可能是多语言的，不同用户可能会切换到不同的语言，这样的情况下推送所用的语言也应该一致。但基于不同群主题再针对不同语言生成不同的Topic是不现实的，因为这样会导致产生大量的Topic，而Google对Topic的数量控制又是未知的。 我们利用了FCM Topic的逻辑关系控制推送接收的功能，解决上面这个问题。用户进入游戏都会先订阅一个游戏标识+语言标识命名的Topic，当用户切换语言时就会取消之前语言的Topic订阅，重新订阅游戏标识+新语言标识的Topic。服务端要推送消息时，先获取不同语言版本的消息体，然后将不同语言的消息体通过群Topic &amp;&amp; 语言Topic的方式对应推送，这样没有订阅其它语言Topic的，且没符合群条件的用户就不会收到其它语言的推送了。 同时这个游戏语言Topic可作为此游戏的总推送开关，取消订阅的话则所有推送都不再收到，因为其它Topic都需要&amp;&amp;这个游戏语言Topic来发送，不订阅它就无法接收。 当用户登出时，则把当前设备订阅过的Topic全取消订阅，避免与新用户的订阅混淆。然后等新用户登录后重新初始化用户推送群的订阅。 公会推送公会的推送是针对角色而不是用户的，所以这类推送是独立的（当然可以做成受总推送开关控制）。 当角色进入游戏后，首先会根据游戏当前语言订阅一个公会语言Topic（切换语言时这个订阅也要跟着切换）。 然后当角色加入某一公会时，则订阅游戏标识+公会标识的Topic。而当角色在公会里关闭公会推送功能，或者退出公会，则需要取消订阅游戏标识+公会标识的Topic。 登出角色或者登出账号时，也需要取消订阅游戏标识+公会标识的Topic，而公会语言Topic则不用变动，因为它根据游戏语言而定的，不受角色或者账号的变动影响。 发送官方的公会消息时将不同语言的消息体通过游戏公会Topic &amp;&amp; 公会语言Topic的方式对应推送。但公会长的消息则直接使用游戏公会Topic发送，因为是以会长的语言为准，这样只需要保持会长的原文进行推送即可，不需游戏公会Topic辅助逻辑。 架构实现类的结构如下 ├── EFNFirebaseNontificationController ├── EFNFirebaseNotification ├── EFNFirebaseGroupNotification ├── EFNFirebaseGuildNotification └── EFNFirebaseSingleNotification EFNFirebaseNontificationController：负责: 本地和远程、前台和后台的推送接收； 接收推送后的推送展示逻辑及展示实现； 作为一个环境角色类，负责执行策略方法，不关注具体的策略类。 EFNFirebaseNotification：抽象策略类，把单推、群推、公会推的功能抽象出来，提供给环境角色直接调用。 EFNFirebaseGroupNotification：群推的具体策略类。 EFNFirebaseGuildNotification：公会推的具体策略类。 EFNFirebaseSingleNotification：单推的具体策略类。 抽象的策略方法主要包括： setupNotificationWithUnitID: - 设定或恢复推送单位订阅并缓存，推送单位是指账号user ID或者角色role ID这些； clearLastUnitNotificationStatusInDevice - 清除推送单位的订阅和缓存 changeNotificationShouldSubscribe:unitID: - 切换推送单位的订阅开关 总结写了这么多，感觉写文章的思路还是比较混乱，特别当内容比较多，情况分类多，延伸的子情况也多的时候，就出现来回修改文章，多次排版的问题，段落划分也不清晰。看来要恶补一下技术文章撰写的技巧和反思一下文章布局的思维，下次写文章不能再出现这种混乱的情况，下键盘前需要思考一下整体的计划，锻炼语言的组织能力。 然后关于推送，还有好一些功能还没使用上，例如推送消息中的Category、图片、铃声音频，日期推送、定位推送等等，期待下次应用到的时候再次总结，从侧面来看，本不应待应用的时候才总结，当Apple有功能更新的时候就该试玩，然后总结，走在最前。 参考文章：活久见的重构 - iOS 10 UserNotifications 框架解析UIApplication Delegate launch Optionsios notification （一）ios 本地和远程通知（二）iOS开发——iOS静默推送介绍及使用场景How to handle remote notification with background mode enabled]]></content>
  </entry>
  <entry>
    <title><![CDATA[处理服务端API返回JSON的总结]]></title>
    <url>%2FiOS%2F%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E7%AB%AFAPI%E8%BF%94%E5%9B%9EJSON%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[当服务端API返回给客户端的数据中，有空字段时一般是使用null填充，这时若iOS客户端不对字段先作类型判断的话，就很容易出现崩溃，因为Cocoa在JSON对象转换时对null转为了NSNull对象，而不是nil，且nil也不能存放于集合对象中，不先作类型判断，直接使用该字段转出的对象就可能出现找不到访问的selector而崩溃了。（Android的空判断本来就是用null作依据，所以这个情况对它没有影响。） 所以开发API时，应该与服务端协商好规范约定，而客户端也应该做好防范措施。 规范约定当时与iOS客户端同事约定的规则： 客户端对服务端返回的JSON数据，必须要作类型及安全值判断（iOS统一动态地将NSNull调用无法识别的方法时返回nil）： 与服务端约定字段类型，若为不确定类型的需要先作类型判断； 字符串的字段，使用string.length &gt; 0（为nil时调用length是安全的）； 数字的字段，使用number.intValue、number.floatValue、number.doubleValue、number.boolValue等； 集合的字段，使用set.count &gt; 0（为nil时调用count是安全的）。 与服务端同事约定的规则： 与服务端设计API的约定 布尔值的字段统一使用true、false（不再使用”true”、”y”、“yes”、1等等）； 空字段统一采用设置默认值，不使用null或”null”，数字的使用0，字符串的使用””，数组使用[]，对象使用{}。 安全的NSNull为了实现“统一动态地将NSNull调用无法识别的方法时返回nil”，我参考了一个第三方库NullSafe去对现有的客户端工程打了一下补丁，其实也算不上一个库，只有一个m文件。使用前先分析了一下它的实现原理。 NullSafe首先NullSafe是NSNull的分类Category，其次它只有三个利用运行时实现的方法，一个是初始化缓存数据的，另外两个是实现消息转发的。消息转发的流程如下图 缓存策略NullSafe做了一个缓存机制，主要缓存两项内容 所有的NSObject子类； selector对应签名的集合； 因为查找NSObject子类和seletor的响应者时会历遍项目里的所有注册类和NSObject子类，这个过程消耗很大，缓存是十分必要的。 然后NSObject的子类是从所有注册类中筛选出来。通过objc_getClassList获取所有注册了的类，class_getSuperclass获取所有注册类的父类。这里大家可能会有疑问，为什么不直接使用superclass获取父类，原因是objc_getClassList获取到的类不一定都是NSObject的子类，所以就不一定都有superclass这个方法。关于更多的Objective-C Runtime方法说明可以查阅官方文档 签名Selector1.重写Selector的签名方法 - (NSMethodSignature *)methodSignatureForSelector:(SEL)selector 这个方法的作用是告诉系统该selector的参数有多少个、是什么类型（也可以通过调用instanceMethodSignatureForSelector获取指定类的selector的签名），返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出。 先检查缓存中是否已经存在selector的签名 若存在且签名是一个NSNull类对象的话，则返回nil终止消息转发流程（这个判断的意义在于缓存没有时，到NSObject的所有子类也找不到响应该selector的类或该类没有对应该selector的签名，简单说就是调用了全系统都木有的方法，理应继续崩溃）； 若不存在且缓存未初始化，则初始化缓存并收集起所有NSObject的子类； 历遍NSObject的子类 若响应当前selector，则将其对selector的签名进行缓存，并返回此签名，系统接着发送forwardInvocation消息; 若找不到响应selector的类或其签名为空，则将NSNull的null作为该selector的签名进行缓存，并返回nil（存上NSNull的null是为了方便后续对缓存结果的判断，是否一个合理范围的selector）。 有几个实现细节点值得学习 线程安全，利用@synchronized([NSNull class])对缓存的初始化、读取实施线程锁，同时缓存的读取在锁前和锁后分别做了两步判断，目的是防止等待解锁的过程中缓存更新的部分包含了目标值而重新执行一遍，降低了效率； 执行顺序，缓存初始化执行前先判断当前是否在主队列，是则直接执行，否则利用GCD的dispatch_sync同步方法在主队列执行，这样避免了主队列出现死锁的可能，同时使初始化下面的逻辑和锁外的逻辑按顺序地等初始化完成后再执行。 2.重写消息转发处理 - (void)forwardInvocation:(NSInvocation *)invocation 将转发的target设为nil，这样调用任何方法就都是安全的，后面也就不会再出现消息转发，最后找不到方法而抛出异常导致崩溃。 使用方法把唯一的m文件引入项目就完了，它会在运行时自动加载功能，不需要引用任何h文件。 若某些target或者scheme不想使用NullSafe，可以再build settings里配置预编译宏NULLSAFE_ENABLED=0，又或者在prefix.pch里添加 #ifdef DEBUG #define NULLSAFE_ENABLED 0 #endif JSON中的Boolean最后，还模拟确认了一下Java后端API的布尔值字段返回true和false给我们的效果 可以看出，Cocoa直接把true或false的Boolean转换为数字类1或者0，我们可以通过对该数字字段值调用boolValue这样的方法，方便阅读语义。（注意输出中的json object，NSDictionary的直接输出并不能直接当作JSON的格式，只能用作参考转换原生对象后的效果，像字符串已经不带双引号） 总结与服务端必须约定好交互API的数据格式和规范，避免掉坑，同时客户端也应该有自己的一套防御机制，不能完成倚靠别人为你做多少。而关于数据格式的，除了上面提到的Boolean，像float、double、date这些都是需要特别注意的类型，这里就不展开探讨，先抛出来。 参考ios runtime浅析(二)：消息转发API返回结果设计经验与总结Objective-C的“多继承”——消息转发]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>JSON</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vapor之初体验]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FVapor%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[比较出名的Swift Web框架有Vapor、Perfect、Kitura，现在这些框架都还没十分成熟，主要是缺少基础库，还有Swift Package Manager(SPM)不支持iOS。但基于苹果的Swift Server API计划，我们还是可以放心投入到Swift Web学习中去。这里先简单介绍一下Vapor的上手体验，开始Swift Web的入门之旅。 Swift环境搭建MacOS直接下载Xcode8（Swift3）或者 Xcode9（Swift4） 下载后输入 curl -sL check.vapor.sh | bash 输出下面的第一项就证明Swift环境OK了 {% asset_img checkVapor.png check %} Unbuntu需要额外多几个步骤 远程登录服务器 //填入你搬瓦工端口号和IP ssh -p 2222 root@11.11.11.11 安装依赖工具 sudo apt-get update sudo apt-get install clang libicu-dev binutils git libpython2.7-dev libcurl3 下载Swift #Ubuntu 14.04 wget https://swift.org/builds/swift-3.0-release/ubuntu1404/swift-3.0-RELEASE/swift-3.0-RELEASE-ubuntu14.04.tar.gz #Ubuntu 15.10 wget https://swift.org/builds/swift-3.0-release/ubuntu1510/swift-3.0-RELEASE/swift-3.0-RELEASE-ubuntu15.10.tar.gz 解压Swift # Ubuntu 14.04 tar zxf swift-3.0-RELEASE-ubuntu14.04.tar.gz # Ubuntu 15.10 tar zxf swift-3.0-RELEASE-ubuntu15.10.tar.gz 安装 # Ubuntu 14.04 mv swift-3.0-RELEASE-ubuntu14.04 /swift-3.0 # Ubuntu 15.10 mv swift-3.0-RELEASE-ubuntu15.10 /swift-3.0 设置路径 vi ~/.bashrc export PATH=/swift-3.0/usr/bin:&quot;$&#123;PATH&#125;&quot; 验证 sudo apt-get install curl curl -sL check.vapor.sh | bash Swiftenv在MacOS和Ubuntu除了以上介绍的方法，还可以使用Swiftenv工具安装Swift，它还可以同时兼容多套Swift的存在，方便地进行切换，类似python的pyenv一样。这里就不作具体说明，抛出一下知识点。 Vapor环境搭建主要是安装Vapor的Toolbox，它是一个Swift脚本的CLI（command line interface），需要Swift的环境支持。 安装输入以下指令 curl -sL toolbox.vapor.sh | bash 验证 vapor --help 更新 vapor self update 创建Vapor模板 vapor new &lt;name&gt; [--template=&lt;repo-url-or-github-path&gt;] Vapor的使用1.创建 cd /Users/xxx/(项目的路径) vapor new Hello 创建后提示如下 项目结构 2.修改用例 官方给出最最最简单的用例 import Vapor let drop = try Droplet() drop.get(&quot;hello&quot;) &#123; req in return &quot;Hello, world.&quot; &#125; try drop.run() 拉下来的模板默认没有GET请求的响应，我们通过找到main.swift文件添加上官方的这个用例。 3.编译 到项目路径下执行 vapor build #发布正式版时，提高性能 vapor build --release 编译成功后输出 当你把资源包(Packages文件夹)下载编译完成后，可以把资源包内的所有文件复制一份出来，下次新建项目时，把这些文件拷入Packages文件夹可免去这部分文件的重复下载。 4.运行 vapor run serve #需要权限时 sudo vapor run serve #某些linux系统下 sudo -i vapor run serve 此时，我们就可以使用 http://localhost:8080/hello 或者 http://0.0.0.0:8080/hello访问本地的服务端了。 部署Ubuntu在远程ubuntu上面，Vapor的环境搭建和使用和上面介绍的一样。但在编译运行前我们需要先进入远程服务器内，找到项目的Config文件夹内的servers.json，添加自己服务器的ip和端口80进去 &#123; &quot;http&quot;: &#123; &quot;host&quot;: &quot;11.11.11.11&quot;, &quot;port&quot;: 80 &#125; &#125; 配置好后再执行编译和运行。运行起来后，我们在找一个浏览器，输入：11.11.11.11:80/hello，即可看到结果。 HerokuHeroku平台的灵活性极高且支持多种编程语言。若想把程序部署到Heroku上，开发者要使用Git把程序推送到Heroku的Git服务器上。在服务器上，git push命令会自动触发安装、配置和部署程序。Heroku使用名为Dyno的计算单元衡量用量,并以此为依据收取服务费用，但Heroku的免费版已经完全可以满足我们日常练习的需求，并且其简单快捷的Git操作指令很易上手。 创建Heroku账户在Heroku官网创建自己的开发者账号。注意要记住自己的邮箱和密码，因为一会儿需要在终端进行登录。 安装Heroku CLIHeroku CLI是用来创建、管理Heroku上apps的命令行工具。（heroku 的命令行客户端将被安装到/usr/local/heroku，同时，/usr/local/heroku/bin将被添加到你的PATH环境变量） brew install heroku 安装完成之后执行如下指令来登录，输入邮箱和密码（把你的 SSH 公钥上传到 Heroku 这一点很重要，上传后才能使用 git push 命令。正常情况下，login 命令会自动创建并上传 SSH 公钥。） heroku login Enter your Heroku credentials. Email: adam@example.com Password (typing will be hidden): Authentication successful. 创建Git在Github或其它Git服务器上创建好远端仓库，然后进入你要部署的App，比如上文的Hello项目，执行 $cd Hello $git init $git remote add origin git@github.com:xxx/xxx.git $git add . $git commit -m &quot;add hello app&quot; $git push -u origin master 关联Git有两种操作方式关联项目的Git，一种是命令行，一种是网页。 命令行部署 vapor heroku init 这时Heroku CLI会问几个问题：Would you like to provide a custom Heroku app name? Answer ‘n’ and hit enter if you don’t have a custom name.Would you like to provide a custom Heroku buildpack? Answer ‘n’ and hit enter if you would like to use the default buildpack that Heroku provides.Are you using a custom Executable name? Answer ‘n’ and hit enter here if you aren’t using a custom executable name.Would you like to push to Heroku now? Answer ‘n’ and hit enter.若要配置在线数据库，最后一个问题需先选择‘n’。然后添加Postgres到Heroku $ heroku addons:create heroku-postgresql:hobby-dev 添加完成后查看数据库的URL $ heroku config 然后创建Procfile文件 $ vapor heroku init 并修改Procfile文件的内容为 web: App --env=production --workdir=&quot;./&quot; web: App --env=production --workdir=./ --config:servers.default.port=$PORT --config:postgresql.url=$DATABASE_URL 最后通过push到Git完成Heroku的部署 $ git push heroku master 平时更新 $ git commit -am &quot;Adds new code&quot; $ git push heroku master PS：创建heroku应用和关联Git的操作还可以用以下一条指令代替，但会关联到heroku的git仓库，而上面执行的是自定义关联的Git仓库 #创建app ➜ someAccount git:(rest) ✗ heroku apps:create some-app Creating some-app... done, stack is cedar-14 https://some-app.herokuapp.com/ | https://git.heroku.com/some-app.git Git remote heroku added #查看app ➜ someAccount git:(rest) ✗ heroku apps === My Apps some-app #查看远端git的URL git remote -v 还有，若执行git push heroku master时报错No default language could be detected for this app. remote: HINT: This occurs when Heroku cannot detect the buildpack to use for this application automatically.这说明heroku官方没有swift的buildpack，所以我们要自己添加 heroku create --buildpack https://github.com/kylef/heroku-buildpack-swift.git heroku buildpacks:set https://github.com/kylef/heroku-buildpack-swift.git 若还是报错error at=error code=H10 desc=”App crashed” method=GET path=”/plaintext”这时需要检查Procfile文件是否修改好，Procfile需要放到项目的根目录里 web: Run --env=production --workdir=./ --config:servers.default.port=$PORT 官网部署这个就花太多篇幅描述了，简单说一下流程创建新App，打开设置，在“Buildpacks”中输入 https://github.com/kylef/heroku-buildpack-swift （目的是告诉Heroku包是使用Swift编写且要采用Swift编译），然后打开“Deploy”选择Github或设置自定义的Git地址，并连接到项目的远程仓库，最后点击“Manual deploy”的“Deploy Branch”，等Build结束，部署成功后可以在“Domains”中查看自己的域名，类似 http://appname.herokuapp.com ，此时就可以通过这个域名在外网访问了。 Xcode上调试在项目路径下执行 vapor xcode 执行成功后会生成一个*.xcodeproj文件，打开工程后，对App.scheme的build和run就如同vapor build和vapor run指令一样，但是，像serve、–port、–release等参数，需要在scheme对应操作项的Arguments上设置 参考Swift服务端-Vapor初次使用 Swift后端Vapor的安装和部署 Vapor项目实战-从创建到部署，一步步踏入深坑]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>vapor</tag>
        <tag>swift</tag>
        <tag>heroku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Jekins]]></title>
    <url>%2Funcategorized%2F%E6%90%AD%E5%BB%BAJekins%2F</url>
    <content type="text"><![CDATA[介绍Jenkins是一种CI（Continuous integration，即可持续集成）系统工具。简单来说就是用于持续、自动地构建/测试软件项目和进行监控。具体来说的话，它可以实现 软件构建自动化 ：配置完成后，CI系统会依照预先制定的时间表，或者针对某一特定事件，对目标软件进行构建。 构建可持续的自动化检查 ：CI系统能持续地获取新增或修改后签入的源代码，也就是说，当软件开发团队需要周期性的检查新增或修改后的代码时，CI系统会不断确认这些新代码是否破坏了原有软件的成功构建。这减少了开发者们在检查彼此相互依存的代码中变化情况需要花费的时间和精力。 构建可持续的自动化测试 ：构建检查的扩展部分，构建后执行预先制定的一套测试规则，完成后触发通知(Email,RSS等等)给相关的当事人。 生成后后续过程的自动化 :当自动化检查和测试成功完成，软件构建的周期中可能也需要一些额外的任务，诸如生成文档、打包软件、部署构件到一个运行环境或者软件仓库。这样，构件才能更迅速地提供给用户使用。 Jenkins的主要目标是监控软件开发流程，快速显示问题，保证开发人员以及相关人员省时省力提高开发效率，其还有以下特性 Jenkins一切配置都可以在web界面上完成。有些配置如MAVEN_HOME和Email，只需要配置一次，所有的项目就都能用。当然也可以通过修改XML进行配置。 支持Maven的模块(Module)，Jenkins对Maven做了优化，因此它能自动识别Module，每个Module可以配置成一个job。相当灵活。 测试报告聚合，所有模块的测试报告都被聚合在一起，结果一目了然，使用其他CI，这几乎是件不可能完成的任务。 构件指纹(artifact fingerprint)，每次build的结果构件都被很好的自动管理，无需任何配置就可以方便的浏览下载。 插件支持，支持扩展插件，你可以开发适合自己团队使用的工具。 安装JDK在安装2.74版本的Jenkins前，首先需要安装JDK8。 10.12的Mac系统自搭载的JDK版本是1.7.0_73（即是JDK7）。 java -version 在终端使用上面指令可查看JDK的具体版本信息。安装完JDK8后，再使用该指令查看，会发现仍然显示JDK7的版本信息，这里就需要做一点小的调整才能把JDK版本由当前系统搭载的版本切换到自定义下载的版本。 which java 首先，使用上面指令查看现在java软件包的来源是 /usr/bin/java ，在该路径下发现这java是一个替身，真正的位置是 /System/Library/Frameworks/JavaVM.framework/Version/A/Commands/java ，这个framework就是系统自搭载的JDK了。 然后，输入以下指令进行当前使用版本的切换，用ln创建替身的源参数就是自定义下载的java所在位置，切换前也可以先验证替换的版本号。 /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java -version sudo rm /usr/bin/java sudo ln -s /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java /usr/bin 同时在~/.bashrc中添加下面一行。 export PATH=/Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin:$PATH 并执行以下指令，重载bashrc文件。 source ~/.bashrc 各种解决方案。 但是，在10.12的MacOS上，你可能无法完成移除 usr/bin/java ，因为新版的Mac系统为了防止系统软件被篡改，禁止了直接对 usr/bin 的操作，甚至乎是root权限。需要将切换版本的指令改为 sudo ln -s /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java /usr/local/bin 这样就覆盖了系统原有的(/usr/bin/)java程序。 /usr/bin 是用于存放系统管理的用户程序，/usr/local/bin 是用于不受系统管理的普通用户程序，未来的系统更新可能会更改会没有警告地删除 /usr/bin 中的内容，这存放用户程序的方案叫Package Management。 最后，再执行上面查看当前JDK版本信息的指令，就应该显示为1.8.0_144（macOS Sierra 10.12.4上）。 Jenkins2.74版本的Jenkins，下载好pkg包后，按提示逐步安装，这个过程非常简单，也可以通过下载jenkins.war，运行 java -jar jenkins.war 进行安装。 安装完毕后，Safari会自动打开，或者自己在浏览器中输入 http://localhost:8080 即可进入Jenkins的配置页面。 如果输入地址后报错“Safari can’t connect to server”，那可能是一些启动设置还没好，下面说一下遇到的问题点。 启动配置文件的权限不足这是问题是在一台搭建了Jenkins的服务器升级系统版本时遇到的，系统版本由10.11升到10.12后，Jenkins就无法启动了，解决贴在这。原因就是新的MacOS Sierra改变了Jenkins文件夹的权限，按以下步骤输入指令即可搞定。 sudo chmod u+x /Library/LaunchDaemons/org.jenkins-ci.plist sudo chown jenkins /var/log/jenkins sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist 服务进程没有开启通过以下两条指令可以控制服务进程的开关 sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist Jenkins使用的Java环境配置不对首先需要系统支持Java并已经安装好Java8，其次需要在 /Library/Application Support/Jenkins/jenkins-runner.sh 中添加以下一行 export JAVA_HOME=”/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home” 和修改最后两行成 echo “/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java” $javaArgs -jar “$war” $argsexec “/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java” $javaArgs -jar “$war” $args Jenkins官方的启动指引 配置谢天谢地，终于看见Jenkins的UI。 用户安装完Jenkins后，偏好设置中的用户会发现多了一个没有名字的用户，属性为普通成员。 这个时候，将锁解除，重新设置该账号的信息（鼠标右键-高级选项-全名：设置用户名），这就是拥有Jenkins文件夹绝对权限的用户，之后在模拟器上Build项目都必须登录到该用户的账号下才能正常运行，因为在后台可以运行Jenkins、Xcode，但不能运行模拟器。 Server回到Jenkins Server上，配置的第一页让我们输入Admin的初始密码，页面上有提示密码所在的路径 /Users/Shared/Jenkins/Home/secrets/initialAdminPassword ，如果当前登入账号不是Jenkins，则修改一下该文件的权限，再打开获取密码填入即可。 之后在创建Admin时或者进入到操作界面记得把密码改回来就是了，因为这初始密码不是给人记的。 接下来一路就是 安装默认插件 创建Admin账号（用户名、密码、全名、邮箱）如果有插件安装失败，先重试一下。 最后来到主界面，有以下菜单项 常用的有以下几项 新建：创建新的Item进行自动化的构建操作； 用户：设置可在当前安全域中登录的用户； 任务历史：列出构建过的所有记录，并有甘特图辅助观察； 系统管理：系统的全局设置，插件管理，用户管理，系统日志等等都在这里找到； 我的视图：可以将Item分配到不同的视图中进行相对分组； 凭证中心：用于Item中管理操作时，需要用到的账号、token、证书等验证信息时，可以从该凭证中心直接获取。是一个统一配置各种凭证的地方，可以查看各个凭证所用于的Item。 插件在系统管理下，可以进行全局的设置、管理插件、管理日志等 选择系统管理-&gt;管理插件-&gt;可选插件，就可以安装一些辅助插件，当时安装了这些： GitLab Plugin GitLab Hook Plugin Xcode integration Email Extension Plugin Item创建好的Item会在主界面上直接看到 包括 S(tatus)：最后一次构建的状态，成功呈蓝色，失败呈红色状； W(eather)：如果一直失败就是狂风暴雨，大部分成功偶尔失败则是晴到多云，每次都成功则是晴天； Name：Item的名称； Last Success：最后一次构建成功的时间及编号； Last Failue：最后一次构建失败的时间及编号； Last Persistent Time：上次构建持续的时间。 在Item里，有以下内容 状态：可查看工作区和最新修改记录，和历史构建记录的链接； 修改记录：Git上新Push的版本； 工作空间：即是工作区，可以查看Git上Check out下来的最新版本（相对于最后一次执行poll scm）的文件； 立即构建：手动执行构建； 删除Project：将Item移除； 配置：内容包含构建前后的操作、构建的触发器和环境、源码管理等等； Git Polling Log：轮询Git的日志。 配置Item是Jenkins里最重要的一个环节之一，它直接影响构建的执行，接下来就以Build Xcode Unit Test为例子，详细说一下如何配置一个Item。 创建 首先创建一个freestyle的软件项目构建Item。 常规设置 丢弃旧的构建，勾选了就可以控制构建保留的天数和最大个数，除此之外还可以在高级里配置包的保留天数和个数； 参数化构建过程，第一种用法是相当于预设环境变量，第二种用法是指定文件； 节制构建，控制构建的频率，例如一个小时最多只能构建一次； 关闭构建，顾名思义，勾选了该Item下的Project就不会执行构建； 必要时并发构建，一般情况下只会有一个构建在执行，其它构建请求会在构建队列中排队，但这项勾选了，在资源足够的情况下就会采取并发构建。 源码设置 None：没有源码时勾选。 Git：使用Git管理版本的勾选。需要填写好Repository URL和Credentials。Branch Specifier默认是master，即是只构建master分支上的版本，留空则会构建所有分支。由于当时使用的GitLab没有开启SSH功能，所以并没有在Credentials中配置SSH Username with private key的凭证，而采用原始的Username with password。如果填写Repository URL后报错，说明没有连通Git或者SVN，要再检查一下SSH Key或者User name和password。 Subversion：使用SVN管理版本的勾选，和Git类似。 触发器设置 触发远程构建：当你想通过一个指定的远端来触发一个新的构建，就得使用这项实现。例如在Git远端配置hook，推送地址按格式 JENKINS_URL/job/utility/build?token=TOKEN_NAME 填写。 这样Jenkins就能获取repository的所有commit通知。 Build after other projects are built：等待其它Project构建完再构建。如果上面勾选了并行构建，同时勾选该选项的话，意味着该Item下的构建会按顺序执行，但和其它Item的构建则是并行关系。 Build periodically：定期构建，不管Git上是否有版本更新。时间格式如下 第一位代表分钟（0-59） 第二位代表小时（0-23） 第三位代表日期（1-31） 第四位代表月份（1-12） 第五位代表周（0-7，0和7代表周日）如果你想每5分钟构建一次，则*/5 * * * *（注意空格，/代表每），如果你想每天8点构建，则0 8 * * *或者H 8 * * *。H和0的区别是，H H * * *代表每天构建一次且不与其它Item的构建时间点错开，即H代表一个随机值，而0 0 * * *则会扎堆在午夜0点爆发。 Build when a change is pushed to GitLab：和第一项作用一样，不确定是否安装GitLab hook插件时生成的项。 GitHub hook trigger for GITScm polling：和上面一项一样，只是针对GitHub而已。 Poll SCM：定期检查新版本，有新版本则check out并执行构建，没有则等待下次检查。时间格式和Build periodically中介绍的一样。 环境设置 这些看标题就能大概了解其作用，不多赘述。 构建设置 构建中可以选择不同的操作方式，包括Xcode、Execute Shell等，如下图 选择Xcode的话需要设置构建的Target、Code signing、Build options等。这里简单演示了Execute Shell的构建方式。你可以在脚本中获取各种环境变量，点击Command框下的链接就有参考。因为该shell脚本所在的路径为 /Users/Shared/Jenkins/Home/workspace/utility，所以先cd到xcworkspace所在的路径再构建。下面构建的是一个Unit test的scheme pwd cd Example xcodebuild test -workspace EfunUtilityModule.xcworkspace -scheme EfunUtilityModule_Tests -destination &apos;platform=iOS Simulator,OS=10.3.1,name=iPhone 7&apos; 额外说明，在Item里面，构建开始后，构建历史列表中会显示当前构建的进度，点击编号可进入构建记录。在构建记录中，最常查看的是Console Output，可以观察终端的所有log。 构建后设置 构建后可以添加一些可选性的后续操作，如下图 这里暂时只用到了发送通知邮件的功能 Content type： HTML (text/html)Default content： ${SCRIPT, template=”groovy-html.template”} 使用邮箱功能，先在全局设置那完成基本配置 先登录到个人邮箱，“设置”-&gt;“POP3/SMTP/IMAP”设置授权码，然后将授权码填入密码项，因为有些邮箱不允许直接从第三方使用帐密操作； 设置SMTP服务器，提醒一下，有些官方提供的服务器域名也不一定准确，如果没效就再多找找确认； 设置用户默认邮件后缀，这个提示可选，但一般都填上； 选择SSL协议的话一般对应465的SMTP端口。有些邮箱可能不支持SSL或者端口不一样。常见问题 然后回到Item里面的构建后设置，添加“邮件通知（Mail Notifcation）”的操作后，设置好“接收人（Recipients）”，多个接收人时用英文空格分隔（这里设置了接收人可以用全局变量获取之前全局设置的接收人，也可以重新指定覆盖掉全局的），最后可设置发送的触发条件”总是发送“或者”失败时发送“，另外还有两个附加选项： “每次不稳定的构建都发送邮件通知”是默认选项，当构建后结果失败或不稳定时发邮件给Recipients； “单独发送邮件给对构建造成不良影响的责任人”，即是向最后提交Git版本的人发通知，Jenkins会根据设置的Recipients的默认邮箱后缀加上提交版本的用户名作为邮箱地址。 问题小结这里遇到了一些坑 使用pod的一些工程，scheme默认是不在xcworkspace上的，而在xcproject上，需要在Xcode的Manage schemes中更改Scheme所在的位置和设置为share状态。 workspace参数不能用绝对路径，cd到对应路径下使用相对路径就好了。 电脑一定要在Jenkins账号下登录才能调出模拟器，否则构建失败。 RSA加解密和获取Bundle Seed ID的测试用例上，同为Xcode8，不同的小版本却测试出不一样的结果。 本文暂时只介绍了自动测试，分包的部分日后再补充吧。 参考文章Testing with Xcode一步一步构建iOS持续集成:Jenkins+GitLab+蒲公英+FTPContinuous Integration in iOS using JENKINSJenkins入门系列]]></content>
      <tags>
        <tag>Jenkins</tag>
        <tag>CI</tag>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ATS详解]]></title>
    <url>%2Funcategorized%2FATS%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[恰逢最近面试的时候有被问到这一块，工作中其实也会经常遇到这方面的问题，但是原理并没有明明白白地搞下来，现在就来详细了解一番吧。 来，先从基本的原理入手，首先介绍一下一些安全协议。 TLS(Transport Layer Security，传输层安全协议)是SSL的标准化版本，有1.0、1.1、1.2、1.3四个版本。是一种对基于网络的传输的加密协议，可以在受信任的第三方公证基础上做双方的身份认证。TLS可以用在TCP上，也可以用在无连接的UDP报文上。协议规定了身份认证、算法协商、密钥交换等的实现。而TLS 1.0和SSL 3.0几乎没有区别，就相当于SSL 3.1； SSL（Secure Socket Layer，安全套接字层）由网景Netscape公司开发的，有1、2、3三个版本，是TLS的前身，现在已不再更新； HTTPS是在基于TLS/SSL的安全套接字上的的应用层协议，除了传输层进行了加密外，其它与常规HTTP协议基本保持一致； 证书是TLS协议中用来对身份进行验证的机制，是一种数字签名形式的文件，包含证书拥有者的公钥及第三方的证书信息。 SSL工作原理SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol），它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 身份认证现假设Alice要认证Bob的身份: A–&gt;B hello,areyou bob?B–&gt;A Alice,This Is bob{digest[Alice,This Is Bob]}bobs-private-key Bod使用RSA的私钥加密一个消息摘要，例如对消息进行MD5 hash后加密，然后连同消息原文发给Alice。Alice使用RSA的公钥解密，将解密的信息与消息原文的摘要对比。此为数字签名。 为了解决中间人攻击，标准化组织在分发公钥这步协议上发明了证书。证书是由证书颁发者（即其上一级证书）使用其私钥签名而成，外界都可以通过证书知道颁发者的公钥。 这样就有了更安全的签名: A–&gt;B helloB–&gt;A Hi, I’m Bob, bobs-certificate(A:verify bobs-certificate)A–&gt;B prove itB–&gt;A Alice, This Is bob{ digest[Alice, This Is Bob] }bobs-private-key 交换秘钥有了证书的数字签名认证后，就可以进一步优化密文的交换方式。下面是先用不对称的加密算法法验证身份，然后用对称加密算法互通其他信息 A–&gt;B helloB–&gt;A Hi, I’m Bob, bobs-certificateA–&gt;B prove itB–&gt;A Alice, This Is bob{ digest[Alice, This Is Bob] }bobs-private-keyA–&gt;B ok bob, here is a secret {secret-key} bobs-public-keyB–&gt;A {some message}secret-key 但是上面这种先认证身份后再对称加密传输数据的方式还是有漏洞，中间人虽然无法破解加密信息，却可以在得到身份认证后破坏对称加密信息来进行暴力碰撞。所以再有一种协议来解决，就是加入消息验证码（MAC）。 消息验证消息验证码（MAC）根据对称秘钥和消息原文计算生成一个验证码，作为消息的一部分一并进行对称加密后传递，接收方解密后则将消息原文和对称秘钥再进行一次MAC制作，然后和接收到的MAC对比，一致就认定消息有效。例如可以使用MD5对some message + secret-key摘要式地生成一个MAC。 A–&gt;B helloB–&gt;A Hi, I’m Bob, bobs-certificateA–&gt;B prove itB–&gt;A Alice, This Is Bob{digest[Alice, This Is Bob] } bobs-private-keyA–&gt;B ok bob, here is a secret {secret} bobs-public-key(B: MAC = Digest[some message, secret])B–&gt;A {some message,MAC}secret-key TLSTLS的维基百科有满满的介绍，包括各个版本的更新点。 从技术上讲，TLS 1.0与SSL 3.0的差异非常微小。但正如RFC所述 the differences between this protocol and SSL 3.0 are not dramatic, but they are significant enough to preclude interoperability between TLS 1.0 and SSL 3.0. 本协议和SSL 3.0之间的差异并不是显著，却足以排除TLS 1.0和SSL 3.0之间的互操作性。 TLS 1.0包括可以降级到SSL 3.0的实现，这削弱了连接的安全性。 2014年10月，Google发布在SSL 3.0中发现设计缺陷，建议禁用此一协议。攻击者可以向TLS发送虚假错误提示，然后将安全连接强行降级到过时且不安全的SSL 3.0，然后就可以利用其中的设计漏洞窃取敏感信息。Google在自己公司相关产品中陆续禁止向后兼容，强制使用TLS协议。Mozilla也在11月25日发布的Firefox 34中彻底禁用了SSL 3.0。微软同样发出了安全通告。 TLS与SSL的差异 版本号：TLS记录格式与SSL记录格式相同，但版本号的值不同，TLS的版本1.0使用的版本号为SSLv3.1； 报文鉴别码：SSLv3.0和TLS的MAC算法及MAC计算的范围不同。TLS使用了RFC-2104定义的HMAC算法；SSLv3.0使用了相似的算法，两者差别在于SSLv3.0中，填充字节与密钥之间采用的是连接运算，而HMAC算法采用的是异或运算。但是两者的安全程度是相同的； 伪随机函数：TLS使用了称为PRF的伪随机函数来将密钥扩展成数据块，是更安全的方式； 报警代码：TLS支持几乎所有的SSLv3.0报警代码，而且TLS还补充定义了很多报警代码，如解密失败（decryption_failed）、记录溢出（record_overflow）、未知CA（unknown_ca）、拒绝访问（access_denied）等； 密文族和客户证书：SSLv3.0和TLS存在少量差别，即TLS不支持Fortezza密钥交换、加密算法和客户证书； certificate_verify和finished消息：SSLv3.0和TLS在用certificate_verify和finished消息计算MD5和SHA-1散列码时，计算的输入有少许差别，但安全性相当； 加密计算：TLS与SSLv3.0在计算主密值（master secret）时采用的方式不同； 填充：用户数据加密之前需要增加的填充字节。在SSL中，填充后的数据长度要达到密文块长度的最小整数倍。而在TLS中，填充后的数据长度可以是密文块长度的任意整数倍（但填充的最大长度为255字节），这种方式可以防止基于对报文长度进行分析的攻击。 TLS的主要目标就是使SSL更安全，并使协议的规范更精确和完善。 更安全的MAC算法； 更严密的警报； “灰色区域”规范的更明确的定义。 TLS对于安全性的改进 对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全； 增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的； 改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全； 一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型； 特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。 证书证书分为2类： 自签名证书 CA证书 自签名证书一般不能用来进行身份认证，如果一个server端使用自签名证书，client端要么被设置为无条件信任任何证书，要么需要将自签名证书的公钥和私钥加入受信任列表。 CA 根证书。数字证书认证机构（Certificate Authority, CA）签署和管理的 CA 根证书，会被纳入到你的浏览器和操作系统的可信证书列表中，并由这个列表判断根证书是否可信。信任链中如果只含有有效证书并且以可信锚点（trusted anchor）结尾，那么这个证书就被认为是有效的。例如 GlobalSign Root CA 。 花钱购买证书机构的签名。受信任的机构就可以用自己的私钥(sign.key)对其他人的证书进行签名。我们看到，只需要把证书请求(ssl.csr)发给证书机构，证书机构就可以生成出签名过的证书(ssl.crt)。目前购买证书签名服务的价格大约为100-400元/年。 像我们平时创建苹果开发者证书的时候，需要在开发者的电脑上通过钥匙串中证书助理处的从证书颁发机构请求证书获取.certSigningRequest，然后上传到苹果的develop后台去生成.cer，其实质就是请求苹果信任的 CA 对开发者的证书进行签名，使开发者的证书合法。 苹果develop后台创建.mobileprovision时，会将.cer的公钥附带上。在打包或者真机调试时，Xcode就会通过Bundle ID查找对应的.mobileprovision，然后利用Xcode指定的.cer的私钥加密生成一个签名去给.mobileprovision的公钥解密验证电脑的合法性。而.cer是不包含私钥的，.cer无法让别的电脑上正常地进行打包或者真机调试，但因为在创建.certSigningRequest时，证书源电脑本来持有的对应的私钥一直存在于其keychain上，所以证书源电脑能够正常工作。解决方法是将.cer导成.p12后给别的电脑安装，因为.p12里包含了公钥和私钥（安装了.p12后，别的电脑上的keychain中显示的cer就有了私钥）。 证书链数字证书的生成是分层级的，下一级的证书需要其上一级证书的私钥签名的。所以后者是前者的证书颁发者，也就是说上一级证书的 Subject Name 是其下一级证书的 Issuer Name。 server发送证书给client认证身份； client根据证书中的颁发者信息找该证书的上一级证书，然后验证该证书的合法性（即将该证书中的信息按其上级的签名算法计算签名，和使用上级证书的公钥解密该证书中的数字签名的原文作比较）； 若合法，则继续历遍验证证书链中的所有证书，直到数字证书认证机构（Certificate Authority, CA）签署和管理的 CA 根证书为止，则认为证书合法。 X.509 应该是比较流行的 SSL 数字证书标准，包含（但不限于）以下的字段： 字段 值说明 对象名称（Subject Name） 用于识别该数字证书的信息 共有名称（Common Name） 对于客户证书，通常是相应的域名 证书颁发者（Issuer Name） 发布并签署该证书的实体的信息 签名算法（Signature Algorithm） 签名所使用的算法 序列号（Serial Number） 由CA给予每一个证书分配的唯一的数字型编号 数字证书机构（Certificate Authority， CA） 给证书的唯一整数，一个数字证书一个序列号 生效期（Not Valid Before） – 失效期（Not Valid After） – 公钥（Public Key） 可公开的密钥 签名（Signature） 通过签名算法计算证书内容后得到的数据，用于验证证书是否被篡改 ATS（AppTransportSecurity）ATS默认的条件 服务器TLS版本至少是1.2版本 连接加密只允许几种先进的加密 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHATLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHATLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 证书必须使用SHA256或者更好的哈希算法进行签名，要么是2048位或者更长的RSA密钥，要么就是256位或更长的ECC密钥。 server需要提供HTTPS（TLS 1.2）的接口，可以在终端使用下面的命令验证server的API是否符合ATS标准。 nscurl --ats-diagnostics https://www.google.com ATS的Client配置在Xcode7或以上的版本中，新建的项目都默认使用ATS，即是访问的链接必须支持且使用HTTPS发起请求，否则将返回 的错误。 如果server还不支持ATS，则需要在app的info.plist中做一些如下的调整，使app能正常请求HTTP。 以下是info.plist里面与ATS有关的属性（分层级） NSAppTransportSecurity NSAllowsArbitraryLoads NSExceptionDomains &lt; domain-name-for-exception-as-string &gt; NSExceptionMinimumTLSVerion NSExceptionRequiresForwardSecrecy NSExceptionAllowsInsecureHTTPLoads NSIncludesSubdomains NSThirdPartyExceptionMinimumTLSVersion NSThirdPartyExceptionRequiresForwardSecrecy NSThirdPartyExceptionAllowsInsecureHTTPLoads NSAppTransportSecurity : 一个用于配置App Transport Security行为的属性，在Info.plist中是于Bundle Identifier同一级别的属性。 NSAllowsArbitraryLoads : 一个用于针对不在NSExceptionDomains中的域的配置项。如果设置成YES，则对于那些不在NSExceptionDomains的域则不需要通过ATS的验证。默认值是No，这时对于不在NSExceptionDomains里的域则是需要通过ATS的验证。 NSExceptionDomains : 用于配置例外的配置项。 &lt; domain-name-for-exception-as-string &gt; : 需要添加例外的域名字符串，如:www.baidu.com NSExceptionMinimumTLSVerion : 用于指定例外域名的TSL的版本号，可用的配置有TLSv1.0、TLSv1.1以及TLSv1.2三个配置项。 NSExceptionRequiresForwardSecrecy ： 用于指定所配置的域协议是否使用ATS的所要求的证书加密算法签名，如果是NO， 则加密算法必须是以下这几种。默认值是YES。 TLS_RSA_WITH_AES_256_GCM_SHA384TLS_RSA_WITH_AES_128_GCM_SHA256TLS_RSA_WITH_AES_256_CBC_SHA256TLS_RSA_WITH_AES_256_CBC_SHATLS_RSA_WITH_AES_128_CBC_SHA256TLS_RSA_WITH_AES_128_CBC_SHA NSExceptionAllowsInsecureHTTPLoads : 用于指明所配置的域是否HTTPS的服务器。用这个配置可用访问那些没有证书、自签名证书、过期证书以及证书与域名匹配不上的服务器。默认值是NO。 NSIncludesSubdomains : 用于指明子域名是否使用同样的配置。默认值是NO。 NSThirdPartyExceptionMinimumTLSVersion : 该变量在域名为第三方域名时，且开发人员无法控制的情况下进行配置。 NSThirdPartyExceptionRequiresForwardSecrecy : 该变量在域名为第三方域名时，且开发人员无法控制的情况下进行配置。 NSThirdPartyExceptionRequiresForwardSecrecy : 该变量在域名为第三方域名时，且开发人员无法控制的情况下进行配置。 举例使app请求的所有HTTP链接都能加载： &lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;!--Connect to anything (this is probably BAD)--&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;&lt;true/&gt; &lt;/dict&gt; 使app请求的部分（指定域名的）HTTP或者低版本的HTTPS(TLS 1.1/1.0)链接能加载： &lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;&lt;true/&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;yourserver.com&lt;/key&gt; &lt;dict&gt; &lt;!--Include to allow subdomains--&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt;&lt;true/&gt; &lt;!--Include to allow insecure HTTP requests--&gt; &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt;&lt;true/&gt; &lt;!--Include to allow securecy encrypt arithmetic--&gt; &lt;key&gt;NSExceptionRequiresForwardSecrecy&lt;/key&gt;&lt;true/&gt; &lt;!--Include to specify minimum TLS version--&gt; &lt;key&gt;NSTemporaryExceptionMinimumTLSVersion&lt;/key&gt;&lt;string&gt;TLSv1.1&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/dict&gt; 使app请求的指定域名的网址要经过ATS： &lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;&lt;true/&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;yourserver.com&lt;/key&gt; &lt;dict&gt; &lt;!--Include to allow subdomains--&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt;&lt;true/&gt; &lt;!--Include to allow insecure HTTP requests--&gt; &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt;&lt;false/&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/dict&gt; 自定义验证服务端验证客户端如果服务器的 response 中带有 WWW-Authenticate 的header信息，网络系统类就会调用它们的代理对象的代理方法去处理challenges。其它认证类型，例如 proxy authentication TLS trust validation 是不需要带上这个header也能触发。 在代码需要向认证的服务器请求资源时，服务器会使用http状态码401进行响应，即访问被拒绝需要验证。NSURLConnection会接收到响应并立刻使用认证challenge的一份副本来发送一条willSendRequestForAuthenticationChallenge:委托消息。过程如下所示： - (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge &#123; //以前的失败次数 if ([challenge previousFailureCount] == 0) &#123; //身份认证的类 NSURLCredential *newCredential; newCredential = [NSURLCredential credentialWithUser:@&quot;账号&quot; password:@&quot;密码&quot; persistence:NSURLCredentialPersistenceNone]; [[challenge sender] useCredential:newCredential forAuthenticationChallenge:challenge]; &#125; else &#123; [[challenge sender] cancelAuthenticationChallenge:challenge]; &#125; &#125; NSURLCredential代表的是一个身份验证证书。URL Loading系统支持3种类型的证书：password-based user credentials, certificate-based user credentials, and certificate-based server credentials。NSURLCredential适合大多数的认证请求，因为它可以表示由用户名/密码组合、客户端证书及服务器信任创建的认证信息。 为了认证，要创建一个含有服务端期望的认证信息的NSURLCredential对象。在系统提供的authentication challenge的protection space上调用 authenticationMethod 方法，可以获取服务器的认证方法。而NSURLCredential支持的authentication method有以下几种，可分别用括号中的NSURLCredential工厂方法创建对应的NSURLCredential对象。 NSURLAuthenticationMethodHTTPBasic (credentialWithUser:password:persistence) NSURLAuthenticationMethodHTTPDigest(credentialWithUser:password:persistence) NSURLAuthenticationMethodClientCertificate(credentialWithIdentity:certificates:persistence) NSURLAuthenticationMethodServerTrust(credentialForTrust:) 客户端验证服务端-URLSession:didReceiveChallenge:completionHandler: 回调中会收到一个 challenge，也就是质询，服务端需要你提供认证信息才能完成连接。 challenge 中还包含服务端提供的其自身的证明，可以通过 challenge.protectionSpace.authenticationMethod 取得保护空间要求我们认证的方式，如果这个值是 NSURLAuthenticationMethodServerTrust 的话，我们就可以插手 TLS 握手中“验证数字证书有效性”这一步，即是先验证服务端提供的身份，再返回客户端的认证信息给服务端建立SSL连接。 系统的默认实现（也即代理不实现这个方法）是验证这个信任链的，结果是有效的话则根据 serverTrust 创建 credential 用于同服务端确立 SSL 连接。否则会得到 “The certificate for this server is invalid…” 这样的错误而无法访问。 - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(nonnull NSURLAuthenticationChallenge *)challenge completionHandler:(nonnull void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler&#123; //以前的失败次数 if ([challenge previousFailureCount] == 0) &#123; NSURLCredential *credential = nil; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; /* 调用自定义的验证过程 */ SecTrustRef trust = challenge.protectionSpace.serverTrust; if ([self myCustomValidation:trust]) &#123; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; if (credential) &#123; disposition = NSURLSessionAuthChallengeUseCredential; &#125; &#125; else &#123; /* 无效的话，取消 */ disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge &#125; !completionHandler?:completionHandler(disposition,credential) &#125; else &#123; //身份认证的类 credential = [NSURLCredential credentialWithUser:@&quot;账号&quot; password:@&quot;密码&quot; persistence:NSURLCredentialPersistenceNone]; //以下调用的效果同执行completionHandler一样 [[challenge sender] useCredential:credential forAuthenticationChallenge:challenge]; &#125; &#125; else &#123; [[challenge sender] cancelAuthenticationChallenge:challenge]; &#125; &#125; 自定义的验证过程中，需要先读取challenge的protectionSpace属性的serverTrust属性，serverTrust 是一个 SecTrustRef 对象，它是一种执行信任链验证的抽象实体，包含着验证策略（SecPolicyRef）以及一系列受信任的锚点证书，而我们能做的也是修改这两样东西而已。 static BOOL myCustomValidation(SecTrustRef trust) &#123; BOOL allowConnection = NO; // 假设验证结果是无效的 SecTrustResultType trustResult = kSecTrustResultInvalid; // 函数的内部递归地从叶节点证书到根证书的验证 OSStatus statue = SecTrustEvaluate(trust, &amp;trustResult); if (statue == noErr) &#123; // kSecTrustResultUnspecified: 系统隐式地信任这个证书，即在证书链中找到 CA 颁发的证书 // kSecTrustResultProceed: 用户加入自己的信任锚点，显式地告诉系统这个证书是值得信任的 allowConnection = (trustResult == kSecTrustResultProceed || trustResult == kSecTrustResultUnspecified); &#125; return allowConnection; &#125; 打印 policiesRef 后，你会发现默认的验证策略就包含了域名验证，即服务器证书上的域名和请求域名是否匹配。如果你的一个证书需要用来连接不同域名的主机，或者你直接用 IP 地址去连接，那么你可以重设验证策略以忽略域名验证: CFArrayRef policiesRef; //打印出CFArrayRef会发现验证策略中默认是包含域名认证 SecTrustCopyPolicies(trust, &amp;policiesRef); NSMutableArray *policies = [NSMutableArray array]; // BasicX509 不验证域名是否相同 SecPolicyRef policy = SecPolicyCreateBasicX509(); [policies addObject:(__bridge_transfer id)policy]; SecTrustSetPolicies(trust, (__bridge CFArrayRef)policies); 然后再调用 myCustomValidation() 验证，SecTrustEvaluate函数就会根据trust的策略重新评估验证结果。 自签名证书验证想要 App 防止中间人攻击，可以将公钥证书打包进 App 中，然后在收到服务端证书链的时候，能够有效地验证服务端是否可信，这也是验证自签名的证书链所必须做的。 假设你的服务器返回：[你的自签名的根证书] – [你的二级证书] – [你的客户端证书]，系统是不信任这个三个证书的。所以你在验证的时候需要将这三个的其中一个设置为锚点证书，当然，多个也行。 比如将 [你的二级证书] 作为锚点后，SecTrustEvaluate() 函数只要验证到 [你的客户端证书] 确实是由 [你的二级证书] 签署的，那么验证结果为 kSecTrustResultUnspecified，表明了 [你的客户端证书] 是可信的。下面是设置锚点证书的做法： NSMutableArray *certificates = [NSMutableArray array]; NSDate *cerData = /* 在 App Bundle 中你用来做锚点的证书数据，证书是 CER 编码的，常见扩展名有：cer, crt...*/ SecCertificateRef cerRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)cerData); [certificates addObject:(__bridge_transfer id)cerRef]; // 设置锚点证书。 SecTrustSetAnchorCertificates(trust, (__bridge CFArrayRef)certificates); 然后再调用 myCustomValidation() 验证。 只调用 SecTrustSetAnchorCertificates () 这个函数的话，那么就只有作为参数被传入的证书作为锚点证书，连系统本身信任的 CA 证书都不能作为锚点验证的证书链。要想恢复系统中 CA 证书作为锚点的功能，还要再调用下面这个函数： // true 代表仅被传入的证书作为锚点，false 允许系统 CA 证书也作为锚点 SecTrustSetAnchorCertificatesOnly(trust, false); AFN的相关属性AFSecurityPolicy，内部有三个重要的属性，如下： AFSSLPinningMode SSLPinningMode; //该属性标明了AFSecurityPolicy是以何种方式来验证 BOOL allowInvalidCertificates; //是否允许不信任的证书通过验证，默认为NO BOOL validatesDomainName; //是否验证主机名，默认为YES AFSSLPinningMode枚举类型有三个值，分别是： AFSSLPinningModeNone代表了AFSecurityPolicy不做更严格的验证，”只要是系统信任的证书”就可以通过验证，不过，它受到allowInvalidCertificates和validatesDomainName的影响； AFSSLPinningModePublicKey是通过比较证书当中公钥(PublicKey)部分来进行验证，通过SecTrustCopyPublicKey方法获取本地证书和服务器证书，然后进行比较，如果有一个相同，则通过验证，此方式主要适用于自建证书搭建的HTTPS服务器和需要较高安全要求的验证； AFSSLPinningModeCertificate则是直接将本地的证书设置为信任的根证书，然后来进行判断，并且比较本地证书的内容和服务器证书内容是否相同，来进行二次判断，此方式适用于较高安全要求的验证。 如果HTTPS服务器满足ATS默认的条件，而且SSL证书是通过权威的CA机构认证过的，那么什么都不用做。如果上面的条件中有任何一个不成立，那么都只能修改ATS配置。 小结完成这篇文章后，才发现自己之前对网路编程的认识有多显浅。也才真正发现总结出一篇文章的好处，整理知识更系统（当然还要看文章的排版分类），而且大脑的记忆有限，有了文章日后回顾也方便直接。反正有意义有价值的的事都比较折腾，贵在坚持！ 参考文章SSL的工作原理SSL与TLS区别iOS 中对 HTTPS 证书链的验证iOS9 - NSAppTransportSecurityiOS9增加的ATS特性介绍Authentication Challenges and TLS Chain ValidationOverriding TLS Chain Validation Correctly]]></content>
      <tags>
        <tag>TLS</tag>
        <tag>SSL</tag>
        <tag>HTTPS</tag>
        <tag>ATS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Hexo博客]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2F%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[在15年的时候，同样是使用GitHub Page搭建博客，使用一款名为dbll的主题，但不知是主题不好用还是自己太懒的关系，只发布过可怜的几篇文章。 直到最近看了一些关于作为技术人员为什么要写博客的文章和文章等，同时网易那边的面试失败，使我产生了那种对知识掌握不够细致、不够深的挫折感与悔晚感，知识面也没有广阔到什么程度去，而下定了从此之后一定要写技术博客的决心。 好了，不扯太多自己的东西，开始正式介绍使用Hexo+GitHub Page搭建自己个人博客的教程。 为什么选择Hexo正如它主页说讲的：快速、简洁且高效。执行短短五条指令后就能运行起来看到效果 $npm install hexo-cli -g $hexo init blog $cd blog $npm install $hexo server 加上后期的一系列方便的操作指令，除了强大，想不到其它形容词，下面会介绍到这些指令。 其次是它支持Markdown解析文章。Markdown写文章有很多好处，例如不再担心排版，标记语法也很易读易记等等。这里有一些Markdown的必用语法介绍。 环境搭建安装Hexo前，必须确认已安装NodeJS和Git。查看NodeJS的版本 $node -v 查看Git的版本 $git --version 若都查不到对应版本号则证明还没安装。NodeJS可以通过nvm安装。nvm的cURL安装方式 $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh nvm的Wget安装方式 $ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 然后使用下面的指令就能安装上NodeJS $ nvm install stable 另外，也可以使用brew来安装。brew的安装 ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 然后使用下面的指令安装NodeJS brew install node 最后就可以安装Hexo了 $ npm install -g hexo-cli nvm是Node Version Manager，用于管理NodeJS的版本。npm是Node Package Manager，是随同NodeJS一起安装的包管理工具。上面安装Hexo的指令则代表安装一个全局的模块。 建站执行下面3条指令，就能将博客站点的搭建起来 $ hexo init [folder] $ cd [folder] $ npm install hexo init [folder]：代表在一个空的文件夹上建站，将Hexo站点模板拷贝到该目录下。 npm install：代表安装当前目录下编写好的所有NodeJS包。 然后目录看起来就是下面这样子 . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml：是站点的配置信息； package.json：里面有显示安装了哪些NodeJS包和Hexo这个site的一些信息，可以自由移除； scaffolds：模版文件夹。当您新建文章时，Hexo 会根据scaffold来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source：存放用户资源的地方，”_”开头和隐藏的文件会被忽略。里面的_drafts用于存放草稿，_posts用于存放正式发布的文章； themes 里用于存放主题包，这里我使用的是Next主题。 配置GitHub Pages因为要利用GitHub Pages来安放站点，所以先要在自己的GitHub上新建一个repository，命名必须遵从yourusername.github.io这样的规则，否则pages页面将无法构建生成。 然后可以选择性地绑定一个域名，如果不绑定域名，则你的站点只能通过yourusername.github.io这样的形式访问了。在刚创建的repository的Settings-GitHub Pages上面，将要绑定的域名配置到Custom Domain上，而且需要选择pages页面构建依赖的分支，如下图 域名可以通过阿里云、GoDaddy那些平台购买。由于网站使用的是GitHub的服务器，部署在外国的，所以我们的域名可以不用申请ICP备案。 我的域名是在阿里云购买的。购买到域名后，还需到阿里云控制台的域名管理处设置一下，为新买的域名添加解析，可参考阿里云官方教程，主要是为域名添加如下图的3个解析，包括两个DNS和一个Github Pages的地址。 这里选用别名CNAME的方式绑定，这样解析能允许多个域名映射到同一台主机。注意，最后一步，记得对域名做实名认证，估计是国情规定，如果到GoDaddy购买的com域名应该不需认证。 然后，回到站点文件夹中，在public文件夹里添加一个CNAME的文件(不能有任何扩展名)，里面填上自己的域名，不带http://这种协议。这个文件是用于告诉GitHub该pages绑定的域名是哪个，而放到public是为了给Hexo部署站点，把该CNAME文件push到GitHub的根目录上。 站点配置在站点配置信息_config.yml里，有一些参数最好修改一下再开始使用，不然正式上线的博客里面很多内容都是模板所提供的。其它具体的参数定义可到Hexo官网-配置参考。 title: Fung's Blog subtitle: description: 格言 author: fung fay language: zh-Hans timezone: Asia/Shanghai theme: next deploy: type: git repo: https://github.com/leo9763/leo9763.github.io 主题配置在主题配置信息themes/next/_config.yml里，也可以按自己的需要修改参数，可参考Next官网-配置。下面是我修改到的部分 #主题风格 # scheme: Muse scheme: Mist # scheme: Pisces #主菜单选项 menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html #个人资料中的链接 social: GitHub: https://github.com/leo9763 Twitter: https://twitter.com/Nero_Milk #页面icon favicon: uploads/qgithub.jpg #个人头像 avatar: uploads/qgithub.jpg #代码高亮的风格 highlight_theme: night #第三方评论工具hypercomments的ID，还可以选择disqus等 hypercomments_id: 93415 #站点统计分析工具googleAnalytics的ID，还可以选择Yandex等平台 google_analytics: UA-102751023-1 评论框要说一下评论模块的设置部分，现在多说已经用不了了，网易云跟贴也在月底下线，本来打算用disqus的，但按足提示步骤设置后评论框死活出不来，然后就改用了一款来自于战斗民族的hypercomments，这个平台的缺点是，后台纯英文（也有俄文- -），好吧，这其实不算什么缺点，然后是其只能使用Google的账号登录评论，不能翻墙的就byebye吧。但是优点也有很多 免费版本支持每月最多100K的加载次数。每小时最多1000次的请求。 界面简洁。 支持填写邮箱进行回复，不需要强制登录第三方账号。 支持emoji和回复添加附件。 评论框不需要访客翻墙也能显示出来。 只要主题的hypercomments_id参数开启并设置上ID，则page模板中的评论框部分的预设代码就会生效，这个好像是针对比较新的Next才有预设好代码，反正我使用的5.1.1是预设好的。 站点统计这里使用的是GoogleAnalytics，但当我生成好Analytics ID并设置好以后，GoogleAnalytics的后台一直没有检测到数据。 写作新建文章可以使用下面的指令完成一份草稿 $ hexo new draft &lt;title&gt; #新建草稿 $ hexo publish post &lt;title&gt; #发布到post里去 当然，还可以自定义模板，在scaffolds中设定好自定义模板xxx.md，然后在新建文件时选择自定义的模板 $ hexo new photo "gallery" 这样文章就会根据模板来layout。 分类和标签如果想主页菜单和文章中的tags和categories能点击后正常跳转页面的话，则需要先执行下面两个指令来创建出对应的资源文件夹 $ hexo new page tags $ hexo new page categories page这个参数代表选择了一个layout模板，而这两条指令的意思是新建一个page，名叫tags和categories，从而使主题配置中的菜单参数tags能访问到/tags。执行指令后站点的source目录下会多出tags和categories这两个文件夹，里面分别存有一个index.md文件（到部署站点的时候，source目录下的文件会被hexo识别选择添加到site的根目录上，即是public文件夹所模拟的目录）。 文章中指定分类和标签的示例如下 categories: - Papers - Diary tags: - PS3 - Games Hexo 中标签tag和分类categories两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。上面的示例中，Diary相当于Papers的一个子分类，而PS3和Games这两个标签则是独立存在的。 插图 官方方法。这个方法很实用，基本满足需求，且能在首页上也能正常显示文章的图片。 &#123;% asset_img example.jpg this is title %&#125; 第一个参数是固定值，代表寻找图片资源，还有asset_link、asset_path这些查找其它类型资源的定值。第二个参数是相对路径，Hexo会在与文章同名的文件夹中找出该参数名字的图片。第三个参数是图片的备注，会显示在图片的下方。 使用这种方法前，先在站点配置文件中将post_asset_folder设为true，这样就能在每次通过指令hexo new [layout] &lt;title&gt;创建新文章时对应建立一个同名文件，配对存放该文章的图片。 Markdown方法。这个方法会难于管理图片，在首页中还不能正常显示。图片一般放在source的images文件夹里存放。 ![](/images/image.jpg) 在线图片。这个方法的好处是节省了博客服务器的空间，但缺点是图片放在别人的地方，不知哪天随时会有什么情况影响显示，甚至找不回来，常用的有七牛、极简图床、Gimhoy图床。上传到云服务器后，将得到的图片链接用下面的方式插入到文章即可。 ![](http://ifungfay.com/uploads/qgithub.jpg) 想插入更多其它的内容请参考Next官方的标签插件介绍，例如引用块``代码块``文章等等。 发布在终端执行下面指令，就能在http://localhost:4000/上查看效果 $ hexo server #简写 hexo s 如果想本地站点的更新发布到远端，即是访问自己域名的时候要看到更新信息的话，则需要执行下面指令 $ hexo generate $ hexo deploy ``` 或者简写为下面这样，使站点生成完毕后自动部署网站 ``` bash $ hexo g -d 直到上面一条指令执行完为止，站点的静态文件就生成完毕，并自动将静态网站push到GitHub Page的仓库(即是以上说的站点配置文件中的deploy参数指定的git地址)上面去，这时自己域名访问到的内容也就更新了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
